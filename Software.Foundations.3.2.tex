\documentclass[12pt]{report}
\usepackage[utf8x]{inputenc}

%Warning: tipa declares many non-standard macros used by utf8x to
%interpret utf8 characters but extra packages might have to be added
%(e.g. "textgreek" for Greek letters not already in tipa).
%Use coqdoc's option -p to add new packages.
\usepackage{tipa}

\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage{coqdoc}
\usepackage{amsmath,amssymb}
\usepackage{url}
\usepackage[bookmarks=true]{hyperref} %
\usepackage{bookmark} %
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% This file has been automatically generated with the command
%% coqdoc -toc -interpolate -utf8 -pdf -Q . Top -o all.pdf Preface.v Basics.v Induction.v Lists.v Poly.v MoreCoq.v Logic.v Prop.v MoreLogic.v ProofObjects.v MoreInd.v SfLib.v Rel.v Imp.v ImpParser.v ImpCEvalFun.v Extraction.v Equiv.v Hoare.v Hoare2.v HoareAsLogic.v Smallstep.v Auto.v Types.v Stlc.v StlcProp.v MoreStlc.v Sub.v Typechecking.v Records.v References.v RecordSub.v Norm.v LibTactics.v UseTactics.v UseAuto.v PE.v Postscript.v 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pdfbookmark{\contentsname}{Contents} %
\tableofcontents
\coqlibrary{Top.Preface}{Library }{Top.Preface}

\begin{coqdoccode}
\end{coqdoccode}
\section{Preface}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Welcome}



 This electronic book is a course on \textit{Software Foundations}, the
    mathematical underpinnings of reliable software.  Topics include
    basic concepts of logic, computer-assisted theorem proving, the
    Coq proof assistant, functional programming, operational
    semantics, Hoare logic, and static type systems.  The exposition
    is intended for a broad range of readers, from advanced
    undergraduates to PhD students and researchers.  No specific
    background in logic or programming languages is assumed, though a
    degree of mathematical maturity will be helpful.


    The principal novelty of the course is that it is one hundred per
    cent formalized and machine-checked: the entire text is literally
    a script for Coq.  It is intended to be read alongside an
    interactive session with Coq.  All the details in the text are
    fully formalized in Coq, and the exercises are designed to be
    worked using Coq.


    The files are organized into a sequence of core chapters, covering
    about one semester's worth of material and organized into a
    coherent linear narrative, plus a number of ``appendices'' covering
    additional topics.  All the core chapters are suitable for both
    upper-level undergraduate and graduate students. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Overview}



 Building reliable software is hard.  The scale and complexity of
    modern systems, the number of people involved in building them,
    and the range of demands placed on them make it extremely
    difficult even to build software that is more or less correct,
    much less to get it 100\% correct.  At the same time, the
    increasing degree to which information processing is woven into
    every aspect of society continually amplifies the cost of bugs and
    insecurities.


    Computer scientists and software engineers have responded to these
    challenges by developing a whole host of techniques for improving
    software reliability, ranging from recommendations about managing
    software projects and organizing programming teams (e.g., extreme
    programming) to design philosophies for libraries (e.g.,
    model-view-controller, publish-subscribe, etc.) and programming
    languages (e.g., object-oriented programming, aspect-oriented
    programming, functional programming, ...) and to mathematical
    techniques for specifying and reasoning about properties of
    software and tools for helping validate these properties.


    The present course is focused on this last set of techniques.  The
    text weaves together five conceptual threads:


    (1) basic tools from \textit{logic} for making and justifying precise
        claims about programs;


    (2) the use of \textit{proof assistants} to construct rigorous logical
        arguments;


    (3) the idea of \textit{functional programming}, both as a method of
        programming and as a bridge between programming and logic;


    (4) formal techniques for \textit{reasoning about the properties of
        specific programs} (e.g., the fact that a loop terminates on
        all inputs, or that a sorting function or a compiler obeys a
        particular specification); and


    (5) the use of \textit{type systems} for establishing well-behavedness
        guarantees for \textit{all} programs in a given programming
        language (e.g., the fact that well-typed Java programs cannot
        be subverted at runtime).


    Each of these topics is easily rich enough to fill a whole course
    in its own right; taking all of them together naturally means that
    much will be left unsaid.  But we hope readers will find that the
    themes illuminate and amplify each other in useful ways, and that
    bringing them together creates a foundation from which it will be
    easy to dig into any of them more deeply.  Some suggestions for
    further reading can be found in the \coqdocvar{Postscript} chapter. 

\subsection{Logic}



 Logic is the field of study whose subject matter is \textit{proofs} --
    unassailable arguments for the truth of particular propositions.
    Volumes have been written about the central role of logic in
    computer science.  Manna and Waldinger called it ``the calculus of
    computer science,'' while Halpern et al.'s paper \textit{On the Unusual
    Effectiveness of Logic in Computer Science} catalogs scores of
    ways in which logic offers critical tools and insights.  Indeed,
    they observe that ``As a matter of fact, logic has turned out to be
    significiantly more effective in computer science than it has been
    in mathematics.  This is quite remarkable, especially since much
    of the impetus for the development of logic during the past one
    hundred years came from mathematics.''


    In particular, the fundamental notion of inductive proofs is
    ubiquitous in all of computer science.  You have surely seen them
    before, in contexts from discrete math to analysis of algorithms,
    but in this course we will examine them much more deeply than you
    have probably done so far. 

\subsection{Proof Assistants}



 The flow of ideas between logic and computer science has not been
    in just one direction: CS has also made important contributions to
    logic.  One of these has been the development of software tools
    for helping construct proofs of logical propositions.  These tools
    fall into two broad categories:



\begin{itemize}
\item  \textit{Automated theorem provers} provide ``push-button'' operation:
         you give them a proposition and they return either \textit{true},
         \textit{false}, or \textit{ran out of time}.  Although their capabilities
         are limited to fairly specific sorts of reasoning, they have
         matured tremendously in recent years and are used now in a
         huge variety of settings.  Examples of such tools include SAT
         solvers, SMT solvers, and model checkers.



\item  \textit{Proof assistants} are hybrid tools that automate the more
         routine aspects of building proofs while depending on human
         guidance for more difficult aspects.  Widely used proof
         assistants include Isabelle, Agda, Twelf, ACL2, PVS, and Coq,
         among many others.

\end{itemize}


    This course is based around Coq, a proof assistant that has been
    under development since 1983 at a number of French research labs
    and universities.  Coq provides a rich environment for interactive
    development of machine-checked formal reasoning.  The kernel of
    the Coq system is a simple proof-checker which guarantees that
    only correct deduction steps are performed.  On top of this
    kernel, the Coq environment provides high-level facilities for
    proof development, including powerful tactics for constructing
    complex proofs semi-automatically, and a large library of common
    definitions and lemmas.


    Coq has been a critical enabler for a huge variety of work across
    computer science and mathematics:



\begin{itemize}
\item  As a \textit{platform for modeling programming languages}, it has become
      a standard tool for researchers who need to describe and reason
      about complex language definitions.  It has been used, for
      example, to check the security of the JavaCard platform,
      obtaining the highest level of common criteria certification,
      and for formal specifications of the x86 and LLVM instruction
      sets.



\item  As an \textit{environment for developing formally certified software},
      Coq has been used to build CompCert, a fully-verified optimizing
      compiler for C, for proving the correctness of subtle algorithms
      involving floating point numbers, and as the basis for
      Certicrypt, an environment for reasoning about the security of
      cryptographic algorithms.



\item  As a \textit{realistic environment for programming with dependent
      types}, it has inspired numerous innovations.  For example, the
      Ynot project at Harvard embeds ``relational Hoare reasoning'' (an
      extension of the \textit{Hoare Logic} we will see later in this course)
      in Coq.



\item  As a \textit{proof assistant for higher-order logic}, it has been used
      to validate a number of important results in mathematics.  For
      example, its ability to include complex computations inside
      proofs made it possible to develop the first formally verified
      proof of the 4-color theorem.  This proof had previously been
      controversial among mathematicians because part of it included
      checking a large number of configurations using a program. In
      the Coq formalization, everything is checked, including the
      correctness of the computational part.  More recently, an even
      more massive effort led to a Coq formalization of the
      Feit-Thompson Theorem -- the first major step in the
      classification of finite simple groups.

\end{itemize}


   By the way, in case you're wondering about the name, here's what
   the official Coq web site says: ``Some French computer scientists
   have a tradition of naming their software as animal species: Caml,
   Elan, Foc or Phox are examples of this tacit convention. In French,
   'coq' means rooster, and it sounds like the initials of the
   Calculus of Constructions (CoC) on which it is based.''  The rooster
   is also the national symbol of France, and ``Coq'' are the first
   three letters of the name of Thierry Coquand, one of Coq's early
   developers. 

\subsection{Functional Programming}



 The term \textit{functional programming} refers both to a collection of
    programming idioms that can be used in almost any programming
    language and to a family of programming languages designed to
    emphasize these idioms, including Haskell, OCaml, Standard ML,
    F\#, Scala, Scheme, Racket, Common Lisp, Clojure, Erlang, and Coq.


    Functional programming has been developed over many decades --
    indeed, its roots go back to Church's lambda-calculus, which was
    invented in the 1930s before the era of the computer began!  But
    since the early '90s it has enjoyed a surge of interest among
    industrial engineers and language designers, playing a key role in
    high-value systems at companies like Jane St. Capital, Microsoft,
    Facebook, and Ericsson.


    The most basic tenet of functional programming is that, as much as
    possible, computation should be \textit{pure}, in the sense that the only
    effect of execution should be to produce a result: the computation
    should be free from \textit{side effects} such as I/O, assignments to
    mutable variables, redirecting pointers, etc.  For example,
    whereas an \textit{imperative} sorting function might take a list of
    numbers and rearrange its pointers to put the list in order, a
    pure sorting function would take the original list and return a
    \textit{new} list containing the same numbers in sorted order.


    One significant benefit of this style of programming is that it
    makes programs easier to understand and reason about.  If every
    operation on a data structure yields a new data structure, leaving
    the old one intact, then there is no need to worry about how that
    structure is being shared and whether a change by one part of the
    program might break an invariant that another part of the program
    relies on.  These considerations are particularly critical in
    concurrent programs, where every piece of mutable state that is
    shared between threads is a potential source of pernicious bugs.
    Indeed, a large part of the recent interest in functional
    programming in industry is due to its simple behavior in the
    presence of concurrency.


    Another reason for the current excitement about functional
    programming is related to the first: functional programs are often
    much easier to parallelize than their imperative counterparts.  If
    running a computation has no effect other than producing a result,
    then it does not matter \textit{where} it is run.  Similarly, if a data
    structure is never modified destructively, then it can be copied
    freely, across cores or across the network.  Indeed, the MapReduce
    idiom that lies at the heart of massively distributed query
    processors like Hadoop and is used by Google to index the entire
    web is a classic example of functional programming.


    For purposes of this course, functional programming has yet
    another significant attraction: it serves as a bridge between
    logic and computer science.  Indeed, Coq itself can be viewed as a
    combination of a small but extremely expressive functional
    programming language plus with a set of tools for stating and
    proving logical assertions.  Moreover, when we come to look more
    closely, we find that these two sides of Coq are actually aspects
    of the very same underlying machinery -- i.e., \textit{proofs are
    programs}.  

\subsection{Program Verification}



 The first third of the book is devoted to developing the
    conceptual framework of logic and functional programming and
    gaining enough fluency with Coq to use it for modeling and
    reasoning about nontrivial artifacts.  From this point on, we
    increasingly turn our attention to two broad topics of critical
    importance to the enterprise of building reliable software (and
    hardware): techniques for proving specific properties of
    particular \textit{programs} and for proving general properties of whole
    programming \textit{languages}.


    For both of these, the first thing we need is a way of
    representing programs as mathematical objects, so we can talk
    about them precisely, and ways of describing their behavior in
    terms of mathematical functions or relations.  Our tools for these
    tasks are \textit{abstract syntax} and \textit{operational semantics}, a method
    of specifying the behavior of programs by writing abstract
    interpreters.  At the beginning, we work with operational
    semantics in the so-called ``big-step'' style, which leads to
    somewhat simpler and more readable definitions, in those cases
    where it is applicable.  Later on, we switch to a more detailed
    ``small-step'' style, which helps make some useful distinctions
    between different sorts of ``nonterminating'' program behaviors and
    which is applicable to a broader range of language features,
    including concurrency.


    The first programming language we consider in detail is \textit{Imp}, a
    tiny toy language capturing the core features of conventional
    imperative programming: variables, assignment, conditionals, and
    loops. We study two different ways of reasoning about the
    properties of Imp programs.


    First, we consider what it means to say that two Imp programs are
    \textit{equivalent} in the sense that they give the same behaviors for
    all initial memories.  This notion of equivalence then becomes a
    criterion for judging the correctness of \textit{metaprograms} --
    programs that manipulate other programs, such as compilers and
    optimizers.  We build a simple optimizer for Imp and prove that it
    is correct.


    Second, we develop a methodology for proving that Imp programs
    satisfy formal specifications of their behavior.  We introduce the
    notion of \textit{Hoare triples} -- Imp programs annotated with pre- and
    post-conditions describing what should be true about the memory in
    which they are started and what they promise to make true about
    the memory in which they terminate -- and the reasoning principles
    of \textit{Hoare Logic}, a ``domain-specific logic'' specialized for
    convenient compositional reasoning about imperative programs, with
    concepts like ``loop invariant'' built in.


    This part of the course is intended to give readers a taste of the
    key ideas and mathematical tools used for a wide variety of
    real-world software and hardware verification tasks.


\subsection{Type Systems}



 Our final major topic, covering the last third of the course, is
    \textit{type systems}, a powerful set of tools for establishing
    properties of \textit{all} programs in a given language.


    Type systems are the best established and most popular example of
    a highly successful class of formal verification techniques known
    as \textit{lightweight formal methods}.  These are reasoning techniques
    of modest power -- modest enough that automatic checkers can be
    built into compilers, linkers, or program analyzers and thus be
    applied even by programmers unfamiliar with the underlying
    theories.  (Other examples of lightweight formal methods include
    hardware and software model checkers, contract checkers, and
    run-time property monitoring techniques for detecting when some
    component of a system is not behaving according to specification).


    This topic brings us full circle: the language whose properties we
    study in this part, called the \textit{simply typed lambda-calculus}, is
    essentially a simplified model of the core of Coq itself!


\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Practicalities}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Chapter Dependencies}



 A diagram of the dependencies between chapters and some suggested
    paths through the material can be found in the file \coqdocvar{deps.html}. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{System Requirements}



 Coq runs on Windows, Linux, and OS X.  You will need:



\begin{itemize}
\item  A current installation of Coq, available from the Coq home
         page.  Everything should work with version 8.4.



\item  An IDE for interacting with Coq.  Currently, there are two
         choices:



\begin{itemize}
\item  Proof General is an Emacs-based IDE.  It tends to be
             preferred by users who are already comfortable with
             Emacs.  It requires a separate installation (google
             ``Proof General'').



\item  CoqIDE is a simpler stand-alone IDE.  It is distributed
             with Coq, but on some platforms compiling it involves
             installing additional packages for GUI libraries and
             such. 
\end{itemize}

\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Exercises}



 Each chapter includes numerous exercises.  Each is marked with a
    ``star rating,'' which can be interpreted as follows:



\begin{itemize}
\item  One star: easy exercises that underscore points in the text
         and that, for most readers, should take only a minute or two.
         Get in the habit of working these as you reach them.



\item  Two stars: straightforward exercises (five or ten minutes).



\item  Three stars: exercises requiring a bit of thought (ten
         minutes to half an hour).



\item  Four and five stars: more difficult exercises (half an hour
         and up).

\end{itemize}


    Also, some exercises are marked ``advanced'', and some are marked
    ``optional.''  Doing just the non-optional, non-advanced exercises
    should provide good coverage of the core material.  Optional
    exercises provide a bit of extra practice with key concepts and
    introduce secondary themes that may be of interest to some
    readers.  Advanced exercises are for readers who want an extra
    challenge (and, in return, a deeper contact with the material).


    \textit{Please do not post solutions to the exercises in public places}:
    Software Foundations is widely used both for self-study and for
    university courses.  Having solutions easily available makes it
    much less useful for courses, which typically have graded homework
    assignments.  The authors especially request that readers not post
    solutions to the exercises anyplace where they can be found by
    search engines.
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Downloading the Coq Files}



 A tar file containing the full sources for the ``release version''
    of these notes (as a collection of Coq scripts and HTML files) is
    available here:
\begin{verbatim}
        http://www.cis.upenn.edu/~bcpierce/sf   
\end{verbatim}
    If you are using the notes as part of a class, you may be given
    access to a locally extended version of the files, which you
    should use instead of the release version.
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Note for Instructors}



 If you intend to use these materials in your own course, you will
    undoubtedly find things you'd like to change, improve, or add.
    Your contributions are welcome!


    Please send an email to Benjamin Pierce describing yourself and
    how you would like to use the materials, and including the result
    of doing ``htpasswd -s -n NAME'', where NAME is your preferred user
    name.  We'll set you up with read/write access to our subversion
    repository and developers' mailing list; in the repository you'll
    find a \coqdocvar{README} with further instructions. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Translations}



 Thanks to the efforts of a team of volunteer translators, \textit{Software 
    Foundations} can now be enjoyed in Japanese at \coqdocvar{http}://\coqdocvar{proofcafe.org}/\coqdocvar{sf}


 $Date: 2014-12-31 15:31:47 -0500 (Wed, 31 Dec 2014) $ \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{Top.Basics}{Library }{Top.Basics}

\begin{coqdoccode}
\end{coqdoccode}
\section{Basics: Functional Programming in Coq}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{admit} \{\coqdocvar{T}: \coqdockw{Type}\} : \coqdocvar{T}. \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Introduction}



 The functional programming style brings programming closer to
    simple, everyday mathematics: If a procedure or method has no side
    effects, then pretty much all you need to understand about it is
    how it maps inputs to outputs -- that is, you can think of it as
    just a concrete method for computing a mathematical function.
    This is one sense of the word ``functional'' in ``functional
    programming.''  The direct connection between programs and simple
    mathematical objects supports both formal proofs of correctness
    and sound informal reasoning about program behavior.


    The other sense in which functional programming is ``functional'' is
    that it emphasizes the use of functions (or methods) as
    \textit{first-class} values -- i.e., values that can be passed as
    arguments to other functions, returned as results, stored in data
    structures, etc.  The recognition that functions can be treated as
    data in this way enables a host of useful and powerful idioms.


    Other common features of functional languages include \textit{algebraic
    data types} and \textit{pattern matching}, which make it easy to construct
    and manipulate rich data structures, and sophisticated
    \textit{polymorphic type systems} that support abstraction and code
    reuse.  Coq shares all of these features.


    The first half of this chapter introduces the most essential
    elements of Coq's functional programming language.  The second
    half introduces some basic \textit{tactics} that can be used to prove
    simple properties of Coq programs.
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Enumerated Types}



 One unusual aspect of Coq is that its set of built-in
    features is \textit{extremely} small.  For example, instead of providing
    the usual palette of atomic data types (booleans, integers,
    strings, etc.), Coq offers an extremely powerful mechanism for
    defining new data types from scratch -- so powerful that all these
    familiar types arise as instances.  


    Naturally, the Coq distribution comes with an extensive standard
    library providing definitions of booleans, numbers, and many
    common data structures like lists and hash tables.  But there is
    nothing magic or primitive about these library definitions: they
    are ordinary user code.  To illustrate this, we will explicitly
    recapitulate all the definitions we need in this course, rather
    than just getting them implicitly from the library.


    To see how this mechanism works, let's start with a very simple
    example. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Days of the Week}



 The following declaration tells Coq that we are defining
    a new set of data values -- a \textit{type}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{day} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{monday} : \coqdocvar{day}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{tuesday} : \coqdocvar{day}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{wednesday} : \coqdocvar{day}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{thursday} : \coqdocvar{day}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{friday} : \coqdocvar{day}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{saturday} : \coqdocvar{day}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{sunday} : \coqdocvar{day}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The type is called \coqdocvar{day}, and its members are \coqdocvar{monday},
    \coqdocvar{tuesday}, etc.  The second and following lines of the definition
    can be read ``\coqdocvar{monday} is a \coqdocvar{day}, \coqdocvar{tuesday} is a \coqdocvar{day}, etc.''


    Having defined \coqdocvar{day}, we can write functions that operate on
    days. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{next\_weekday} (\coqdocvar{d}:\coqdocvar{day}) : \coqdocvar{day} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{d} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{monday}    \ensuremath{\Rightarrow} \coqdocvar{tuesday}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{tuesday}   \ensuremath{\Rightarrow} \coqdocvar{wednesday}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{wednesday} \ensuremath{\Rightarrow} \coqdocvar{thursday}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{thursday}  \ensuremath{\Rightarrow} \coqdocvar{friday}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{friday}    \ensuremath{\Rightarrow} \coqdocvar{monday}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{saturday}  \ensuremath{\Rightarrow} \coqdocvar{monday}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{sunday}    \ensuremath{\Rightarrow} \coqdocvar{monday}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
One thing to note is that the argument and return types of
    this function are explicitly declared.  Like most functional
    programming languages, Coq can often figure out these types for
    itself when they are not given explicitly -- i.e., it performs
    some \textit{type inference} -- but we'll always include them to make
    reading easier. 

 Having defined a function, we should check that it works on
    some examples.  There are actually three different ways to do this
    in Coq.  


    First, we can use the command \coqdockw{Eval} \coqdoctac{compute} to evaluate a
    compound expression involving \coqdocvar{next\_weekday}.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Eval} \coqdoctac{compute} \coqdoctac{in} (\coqdocvar{next\_weekday} \coqdocvar{friday}).\coqdoceol
\coqdocnoindent
\coqdockw{Eval} \coqdoctac{compute} \coqdoctac{in} (\coqdocvar{next\_weekday} (\coqdocvar{next\_weekday} \coqdocvar{saturday})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
If you have a computer handy, this would be an excellent
    moment to fire up the Coq interpreter under your favorite IDE --
    either CoqIde or Proof General -- and try this for yourself.  Load
    this file (\coqdocvar{Basics.v}) from the book's accompanying Coq sources,
    find the above example, submit it to Coq, and observe the
    result. 

 The keyword \coqdoctac{compute} tells Coq precisely how to
    evaluate the expression we give it.  For the moment, \coqdoctac{compute} is
    the only one we'll need; later on we'll see some alternatives that
    are sometimes useful. 

 Second, we can record what we \textit{expect} the result to be in
    the form of a Coq example: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_next\_weekday}:\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{next\_weekday} (\coqdocvar{next\_weekday} \coqdocvar{saturday})) = \coqdocvar{tuesday}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This declaration does two things: it makes an
    assertion (that the second weekday after \coqdocvar{saturday} is \coqdocvar{tuesday}),
    and it gives the assertion a name that can be used to refer to it
    later.  Having made the assertion, we can also ask Coq to verify it,
    like this: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The details are not important for now (we'll come back to
    them in a bit), but essentially this can be read as ``The assertion
    we've just made can be proved by observing that both sides of the
    equality evaluate to the same thing, after some simplification.'' 

 Third, we can ask Coq to \textit{extract}, from our \coqdockw{Definition}, a
    program in some other, more conventional, programming
    language (OCaml, Scheme, or Haskell) with a high-performance
    compiler.  This facility is very interesting, since it gives us a
    way to construct \textit{fully certified} programs in mainstream
    languages.  Indeed, this is one of the main uses for which Coq was
    developed.  We'll come back to this topic in later chapters.  More
    information can also be found in the Coq'Art book by Bertot and
    Casteran, as well as the Coq reference manual. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Booleans}



 In a similar way, we can define the standard type \coqdocvar{bool} of
    booleans, with members \coqdocvar{true} and \coqdocvar{false}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{bool} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{true} : \coqdocvar{bool}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{false} : \coqdocvar{bool}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Although we are rolling our own booleans here for the sake
    of building up everything from scratch, Coq does, of course,
    provide a default implementation of the booleans in its standard
    library, together with a multitude of useful functions and
    lemmas.  (Take a look at \coqdocvar{Coq.Init.Datatypes} in the Coq library
    documentation if you're interested.)  Whenever possible, we'll
    name our own definitions and theorems so that they exactly
    coincide with the ones in the standard library. 

 Functions over booleans can be defined in the same way as
    above: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{negb} (\coqdocvar{b}:\coqdocvar{bool}) : \coqdocvar{bool} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{b} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{true} \ensuremath{\Rightarrow} \coqdocvar{false}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{false} \ensuremath{\Rightarrow} \coqdocvar{true}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{andb} (\coqdocvar{b1}:\coqdocvar{bool}) (\coqdocvar{b2}:\coqdocvar{bool}) : \coqdocvar{bool} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{b1} \coqdockw{with} \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{true} \ensuremath{\Rightarrow} \coqdocvar{b2} \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{false} \ensuremath{\Rightarrow} \coqdocvar{false}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{orb} (\coqdocvar{b1}:\coqdocvar{bool}) (\coqdocvar{b2}:\coqdocvar{bool}) : \coqdocvar{bool} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{b1} \coqdockw{with} \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{true} \ensuremath{\Rightarrow} \coqdocvar{true}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{false} \ensuremath{\Rightarrow} \coqdocvar{b2}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The last two illustrate the syntax for multi-argument
    function definitions. 

 The following four ``unit tests'' constitute a complete
    specification -- a truth table -- for the \coqdocvar{orb} function: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_orb1}:  (\coqdocvar{orb} \coqdocvar{true}  \coqdocvar{false}) = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_orb2}:  (\coqdocvar{orb} \coqdocvar{false} \coqdocvar{false}) = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_orb3}:  (\coqdocvar{orb} \coqdocvar{false} \coqdocvar{true})  = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_orb4}:  (\coqdocvar{orb} \coqdocvar{true}  \coqdocvar{true})  = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
(Note that we've dropped the \coqdoctac{simpl} in the proofs.  It's not
    actually needed because \coqdoctac{reflexivity} automatically performs
    simplification.) 

 \textit{A note on notation}: In .v files, we use square brackets to
    delimit fragments of Coq code within comments; this convention,
    also used by the \coqdocvar{coqdoc} documentation tool, keeps them visually
    separate from the surrounding text.  In the html version of the
    files, these pieces of text appear in a \coqdocvar{different} \coqdocvar{font}. 

 The values \coqdocvar{Admitted} and \coqdocvar{admit} can be used to fill
    a hole in an incomplete definition or proof.  We'll use them in the
    following exercises.  In general, your job in the exercises is 
    to replace \coqdocvar{admit} or \coqdocvar{Admitted} with real definitions or proofs. 

\paragraph{Exercise: 1 star (nandb)}

 Complete the definition of the following function, then make
    sure that the \coqdockw{Example} assertions below can each be verified by
    Coq.  

 This function should return \coqdocvar{true} if either or both of
    its inputs are \coqdocvar{false}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{nandb} (\coqdocvar{b1}:\coqdocvar{bool}) (\coqdocvar{b2}:\coqdocvar{bool}) : \coqdocvar{bool} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Remove ``\coqdocvar{Admitted}.'' and fill in each proof with 
    ``\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.'' \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_nandb1}:               (\coqdocvar{nandb} \coqdocvar{true} \coqdocvar{false}) = \coqdocvar{true}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_nandb2}:               (\coqdocvar{nandb} \coqdocvar{false} \coqdocvar{false}) = \coqdocvar{true}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_nandb3}:               (\coqdocvar{nandb} \coqdocvar{false} \coqdocvar{true}) = \coqdocvar{true}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_nandb4}:               (\coqdocvar{nandb} \coqdocvar{true} \coqdocvar{true}) = \coqdocvar{false}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 1 star (andb3)}

 Do the same for the \coqdocvar{andb3} function below. This function should
    return \coqdocvar{true} when all of its inputs are \coqdocvar{true}, and \coqdocvar{false}
    otherwise. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{andb3} (\coqdocvar{b1}:\coqdocvar{bool}) (\coqdocvar{b2}:\coqdocvar{bool}) (\coqdocvar{b3}:\coqdocvar{bool}) : \coqdocvar{bool} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_andb31}:                 (\coqdocvar{andb3} \coqdocvar{true} \coqdocvar{true} \coqdocvar{true}) = \coqdocvar{true}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_andb32}:                 (\coqdocvar{andb3} \coqdocvar{false} \coqdocvar{true} \coqdocvar{true}) = \coqdocvar{false}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_andb33}:                 (\coqdocvar{andb3} \coqdocvar{true} \coqdocvar{false} \coqdocvar{true}) = \coqdocvar{false}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_andb34}:                 (\coqdocvar{andb3} \coqdocvar{true} \coqdocvar{true} \coqdocvar{false}) = \coqdocvar{false}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Function Types}



 The \coqdockw{Check} command causes Coq to print the type of an
    expression.  For example, the type of \coqdocvar{negb} \coqdocvar{true} is \coqdocvar{bool}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Check} (\coqdocvar{negb} \coqdocvar{true}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Functions like \coqdocvar{negb} itself are also data values, just like
    \coqdocvar{true} and \coqdocvar{false}.  Their types are called \textit{function types}, and
    they are written with arrows. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{negb}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The type of \coqdocvar{negb}, written \coqdocvar{bool} \ensuremath{\rightarrow} \coqdocvar{bool} and pronounced
    ``\coqdocvar{bool} arrow \coqdocvar{bool},'' can be read, ``Given an input of type
    \coqdocvar{bool}, this function produces an output of type \coqdocvar{bool}.''
    Similarly, the type of \coqdocvar{andb}, written \coqdocvar{bool} \ensuremath{\rightarrow} \coqdocvar{bool} \ensuremath{\rightarrow} \coqdocvar{bool}, can
    be read, ``Given two inputs, both of type \coqdocvar{bool}, this function
    produces an output of type \coqdocvar{bool}.'' \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Numbers}



 \textit{Technical digression}: Coq provides a fairly sophisticated
    \textit{module system}, to aid in organizing large developments.  In this
    course we won't need most of its features, but one is useful: If
    we enclose a collection of declarations between \coqdockw{Module} \coqdocvar{X} and
    \coqdockw{End} \coqdocvar{X} markers, then, in the remainder of the file after the
    \coqdockw{End}, these definitions will be referred to by names like \coqdocvar{X.foo}
    instead of just \coqdocvar{foo}.  Here, we use this feature to introduce the
    definition of the type \coqdocvar{nat} in an inner module so that it does
    not shadow the one from the standard library. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdocvar{Playground1}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The types we have defined so far are examples of ``enumerated
    types'': their definitions explicitly enumerate a finite set of
    elements.  A more interesting way of defining a type is to give a
    collection of ``inductive rules'' describing its elements.  For
    example, we can define the natural numbers as follows: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{nat} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{O} : \coqdocvar{nat}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{S} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The clauses of this definition can be read: 



\begin{itemize}
\item  \coqdocvar{O} is a natural number (note that this is the letter ``\coqdocvar{O},'' not
        the numeral ``0'').

\item  \coqdocvar{S} is a ``constructor'' that takes a natural number and yields
        another one -- that is, if \coqdocvar{n} is a natural number, then \coqdocvar{S} \coqdocvar{n}
        is too.

\end{itemize}


    Let's look at this in a little more detail.  


    Every inductively defined set (\coqdocvar{day}, \coqdocvar{nat}, \coqdocvar{bool}, etc.) is
    actually a set of \textit{expressions}.  The definition of \coqdocvar{nat} says how
    expressions in the set \coqdocvar{nat} can be constructed:



\begin{itemize}
\item  the expression \coqdocvar{O} belongs to the set \coqdocvar{nat}; 

\item  if \coqdocvar{n} is an expression belonging to the set \coqdocvar{nat}, then \coqdocvar{S} \coqdocvar{n}
      is also an expression belonging to the set \coqdocvar{nat}; and

\item  expressions formed in these two ways are the only ones belonging
      to the set \coqdocvar{nat}.

\end{itemize}
    The same rules apply for our definitions of \coqdocvar{day} and \coqdocvar{bool}. The
    annotations we used for their constructors are analogous to the
    one for the \coqdocvar{O} constructor, and indicate that each of those
    constructors doesn't take any arguments. 

 These three conditions are the precise force of the
    \coqdockw{Inductive} declaration.  They imply that the expression \coqdocvar{O}, the
    expression \coqdocvar{S} \coqdocvar{O}, the expression \coqdocvar{S} (\coqdocvar{S} \coqdocvar{O}), the expression
    \coqdocvar{S} (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{O})), and so on all belong to the set \coqdocvar{nat}, while other
    expressions like \coqdocvar{true}, \coqdocvar{andb} \coqdocvar{true} \coqdocvar{false}, and \coqdocvar{S} (\coqdocvar{S} \coqdocvar{false}) do
    not.


    We can write simple functions that pattern match on natural
    numbers just as we did above -- for example, the predecessor
    function: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{pred} (\coqdocvar{n} : \coqdocvar{nat}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{n} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{O} \ensuremath{\Rightarrow} \coqdocvar{O}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqdocvar{n'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The second branch can be read: ``if \coqdocvar{n} has the form \coqdocvar{S} \coqdocvar{n'}
    for some \coqdocvar{n'}, then return \coqdocvar{n'}.''  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqdocvar{Playground1}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{minustwo} (\coqdocvar{n} : \coqdocvar{nat}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{n} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{O} \ensuremath{\Rightarrow} \coqdocvar{O}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{O} \ensuremath{\Rightarrow} \coqdocvar{O}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{S} (\coqdocvar{S} \coqdocvar{n'}) \ensuremath{\Rightarrow} \coqdocvar{n'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Because natural numbers are such a pervasive form of data,
    Coq provides a tiny bit of built-in magic for parsing and printing
    them: ordinary arabic numerals can be used as an alternative to
    the ``unary'' notation defined by the constructors \coqdocvar{S} and \coqdocvar{O}.  Coq
    prints numbers in arabic form by default: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqdocvar{S} (\coqdocvar{S} (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{O})))).\coqdoceol
\coqdocnoindent
\coqdockw{Eval} \coqdoctac{compute} \coqdoctac{in} (\coqdocvar{minustwo} 4).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The constructor \coqdocvar{S} has the type \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat}, just like the
    functions \coqdocvar{minustwo} and \coqdocvar{pred}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{S}.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqdocvar{pred}.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqdocvar{minustwo}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
These are all things that can be applied to a number to yield a
    number.  However, there is a fundamental difference: functions
    like \coqdocvar{pred} and \coqdocvar{minustwo} come with \textit{computation rules} -- e.g.,
    the definition of \coqdocvar{pred} says that \coqdocvar{pred} 2 can be simplified to
    1 -- while the definition of \coqdocvar{S} has no such behavior attached.
    Although it is like a function in the sense that it can be applied
    to an argument, it does not \textit{do} anything at all! 

 For most function definitions over numbers, pure pattern
    matching is not enough: we also need recursion.  For example, to
    check that a number \coqdocvar{n} is even, we may need to recursively check
    whether \coqdocvar{n}-2 is even.  To write such functions, we use the
    keyword \coqdockw{Fixpoint}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{evenb} (\coqdocvar{n}:\coqdocvar{nat}) : \coqdocvar{bool} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{n} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{O}        \ensuremath{\Rightarrow} \coqdocvar{true}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{O}      \ensuremath{\Rightarrow} \coqdocvar{false}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{S} (\coqdocvar{S} \coqdocvar{n'}) \ensuremath{\Rightarrow} \coqdocvar{evenb} \coqdocvar{n'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can define \coqdocvar{oddb} by a similar \coqdockw{Fixpoint} declaration, but here
    is a simpler definition that will be a bit easier to work with: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{oddb} (\coqdocvar{n}:\coqdocvar{nat}) : \coqdocvar{bool}   :=   \coqdocvar{negb} (\coqdocvar{evenb} \coqdocvar{n}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_oddb1}:    (\coqdocvar{oddb} (\coqdocvar{S} \coqdocvar{O})) = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_oddb2}:    (\coqdocvar{oddb} (\coqdocvar{S} (\coqdocvar{S} (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{O}))))) = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Naturally, we can also define multi-argument functions by
    recursion.  (Once again, we use a module to avoid polluting the
    namespace.) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdocvar{Playground2}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{plus} (\coqdocvar{n} : \coqdocvar{nat}) (\coqdocvar{m} : \coqdocvar{nat}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{n} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{O} \ensuremath{\Rightarrow} \coqdocvar{m}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqdocvar{S} (\coqdocvar{plus} \coqdocvar{n'} \coqdocvar{m})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Adding three to two now gives us five, as we'd expect. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Eval} \coqdoctac{compute} \coqdoctac{in} (\coqdocvar{plus} (\coqdocvar{S} (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{O}))) (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{O}))).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The simplification that Coq performs to reach this conclusion can
    be visualized as follows: \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
As a notational convenience, if two or more arguments have
    the same type, they can be written together.  In the following
    definition, (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}) means just the same as if we had written
    (\coqdocvar{n} : \coqdocvar{nat}) (\coqdocvar{m} : \coqdocvar{nat}). \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{mult} (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{n} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{O} \ensuremath{\Rightarrow} \coqdocvar{O}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqdocvar{plus} \coqdocvar{m} (\coqdocvar{mult} \coqdocvar{n'} \coqdocvar{m})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_mult1}: (\coqdocvar{mult} 3 3) = 9.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
You can match two expressions at once by putting a comma
    between them: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{minus} (\coqdocvar{n} \coqdocvar{m}:\coqdocvar{nat}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{n}, \coqdocvar{m} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{O}   , \coqdocvar{\_}    \ensuremath{\Rightarrow} \coqdocvar{O}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{\_} , \coqdocvar{O}    \ensuremath{\Rightarrow} \coqdocvar{n}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{n'}, \coqdocvar{S} \coqdocvar{m'} \ensuremath{\Rightarrow} \coqdocvar{minus} \coqdocvar{n'} \coqdocvar{m'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \_ in the first line is a \textit{wildcard pattern}.  Writing \_ in a
    pattern is the same as writing some variable that doesn't get used
    on the right-hand side.  This avoids the need to invent a bogus
    variable name. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqdocvar{Playground2}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{exp} (\coqdocvar{base} \coqdocvar{power} : \coqdocvar{nat}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{power} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{O} \ensuremath{\Rightarrow} \coqdocvar{S} \coqdocvar{O}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{p} \ensuremath{\Rightarrow} \coqdocvar{mult} \coqdocvar{base} (\coqdocvar{exp} \coqdocvar{base} \coqdocvar{p})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star (factorial)}

 Recall the standard factorial function:
\begin{verbatim}
    factorial(0)  =  1 
    factorial(n)  =  n * factorial(n-1)     (if n>0)
\end{verbatim}
    Translate this into Coq. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{factorial} (\coqdocvar{n}:\coqdocvar{nat}) : \coqdocvar{nat} := \coqdoceol
\coqdocnoindent
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_factorial1}:          (\coqdocvar{factorial} 3) = 6.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_factorial2}:          (\coqdocvar{factorial} 5) = (\coqdocvar{mult} 10 12).\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

 We can make numerical expressions a little easier to read and
    write by introducing ``notations'' for addition, multiplication, and
    subtraction. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "x + y" := (\coqdocvar{plus} \coqdocvar{x} \coqdocvar{y})  \coqdoceol
\coqdocindent{11.50em}
(\coqdoctac{at} \coqdockw{level} 50, \coqdoctac{left} \coqdockw{associativity}) \coqdoceol
\coqdocindent{11.50em}
: \coqdocvar{nat\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} "x - y" := (\coqdocvar{minus} \coqdocvar{x} \coqdocvar{y})  \coqdoceol
\coqdocindent{11.50em}
(\coqdoctac{at} \coqdockw{level} 50, \coqdoctac{left} \coqdockw{associativity}) \coqdoceol
\coqdocindent{11.50em}
: \coqdocvar{nat\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} "x * y" := (\coqdocvar{mult} \coqdocvar{x} \coqdocvar{y})  \coqdoceol
\coqdocindent{11.50em}
(\coqdoctac{at} \coqdockw{level} 40, \coqdoctac{left} \coqdockw{associativity}) \coqdoceol
\coqdocindent{11.50em}
: \coqdocvar{nat\_scope}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} ((0 + 1) + 1).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
(The \coqdockw{level}, \coqdockw{associativity}, and \coqdocvar{nat\_scope} annotations
   control how these notations are treated by Coq's parser.  The
   details are not important, but interested readers can refer to the
   ``More on Notation'' subsection in the ``Advanced Material'' section at
   the end of this chapter.) 

 Note that these do not change the definitions we've already
    made: they are simply instructions to the Coq parser to accept \coqdocvar{x}
    + \coqdocvar{y} in place of \coqdocvar{plus} \coqdocvar{x} \coqdocvar{y} and, conversely, to the Coq
    pretty-printer to display \coqdocvar{plus} \coqdocvar{x} \coqdocvar{y} as \coqdocvar{x} + \coqdocvar{y}. 

 When we say that Coq comes with nothing built-in, we really
    mean it: even equality testing for numbers is a user-defined
    operation!  The \coqdocvar{beq\_nat} function tests \coqdocvar{nat}ural numbers for \coqdocvar{eq}uality,
    yielding a \coqdocvar{b}oolean.  Note the use of nested \coqdockw{match}es (we could
    also have used a simultaneous match, as we did in \coqdocvar{minus}.)  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{beq\_nat} (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}) : \coqdocvar{bool} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{n} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{O} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvar{m} \coqdockw{with}\coqdoceol
\coqdocindent{4.50em}
\ensuremath{|} \coqdocvar{O} \ensuremath{\Rightarrow} \coqdocvar{true}\coqdoceol
\coqdocindent{4.50em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{m'} \ensuremath{\Rightarrow} \coqdocvar{false}\coqdoceol
\coqdocindent{4.50em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvar{m} \coqdockw{with}\coqdoceol
\coqdocindent{6.00em}
\ensuremath{|} \coqdocvar{O} \ensuremath{\Rightarrow} \coqdocvar{false}\coqdoceol
\coqdocindent{6.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{m'} \ensuremath{\Rightarrow} \coqdocvar{beq\_nat} \coqdocvar{n'} \coqdocvar{m'}\coqdoceol
\coqdocindent{6.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Similarly, the \coqdocvar{ble\_nat} function tests \coqdocvar{nat}ural numbers for
    \coqdocvar{l}ess-or-\coqdocvar{e}qual, yielding a \coqdocvar{b}oolean. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{ble\_nat} (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}) : \coqdocvar{bool} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{n} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{O} \ensuremath{\Rightarrow} \coqdocvar{true}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{n'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{match} \coqdocvar{m} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqdocvar{O} \ensuremath{\Rightarrow} \coqdocvar{false}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{m'} \ensuremath{\Rightarrow} \coqdocvar{ble\_nat} \coqdocvar{n'} \coqdocvar{m'}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_ble\_nat1}:             (\coqdocvar{ble\_nat} 2 2) = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_ble\_nat2}:             (\coqdocvar{ble\_nat} 2 4) = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_ble\_nat3}:             (\coqdocvar{ble\_nat} 4 2) = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars (blt\_nat)}

 The \coqdocvar{blt\_nat} function tests \coqdocvar{nat}ural numbers for \coqdocvar{l}ess-\coqdocvar{t}han,
    yielding a \coqdocvar{b}oolean.  Instead of making up a new \coqdockw{Fixpoint} for
    this one, define it in terms of a previously defined function. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{blt\_nat} (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}) : \coqdocvar{bool} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_blt\_nat1}:             (\coqdocvar{blt\_nat} 2 2) = \coqdocvar{false}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_blt\_nat2}:             (\coqdocvar{blt\_nat} 2 4) = \coqdocvar{true}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_blt\_nat3}:             (\coqdocvar{blt\_nat} 4 2) = \coqdocvar{false}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Proof by Simplification}



 Now that we've defined a few datatypes and functions, let's
    turn to the question of how to state and prove properties of their
    behavior.  Actually, in a sense, we've already started doing this:
    each \coqdockw{Example} in the previous sections makes a precise claim
    about the behavior of some function on some particular inputs.
    The proofs of these claims were always the same: use \coqdoctac{reflexivity} 
    to check that both sides of the = simplify to identical values. 


    (By the way, it will be useful later to know that
    \coqdoctac{reflexivity} actually does somewhat more simplification than \coqdoctac{simpl} 
    does -- for example, it tries ``unfolding'' defined terms, replacing them with
    their right-hand sides.  The reason for this difference is that,
    when reflexivity succeeds, the whole goal is finished and we don't
    need to look at whatever expanded expressions \coqdoctac{reflexivity} has
    found; by contrast, \coqdoctac{simpl} is used in situations where we may
    have to read and understand the new goal, so we would not want it
    blindly expanding definitions.) 


    The same sort of ``proof by simplification'' can be used to prove
    more interesting properties as well.  For example, the fact that
    0 is a ``neutral element'' for + on the left can be proved
    just by observing that 0 + \coqdocvar{n} reduces to \coqdocvar{n} no matter what
    \coqdocvar{n} is, a fact that can be read directly off the definition of \coqdocvar{plus}.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_O\_n} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqdocvar{nat}, 0 + \coqdocvar{n} = \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
(\textit{Note}: You may notice that the above statement looks
    different in the original source file and the final html output. In Coq
    files, we write the \coqdockw{\ensuremath{\forall}} universal quantifier using the
    "\textit{forall}" reserved identifier. This gets printed as an
    upside-down ``A'', the familiar symbol used in logic.)  

 The form of this theorem and proof are almost exactly the
    same as the examples above; there are just a few differences.


    First, we've used the keyword \coqdockw{Theorem} instead of
    \coqdockw{Example}.  Indeed, the difference is purely a matter of
    style; the keywords \coqdockw{Example} and \coqdockw{Theorem} (and a few others,
    including \coqdockw{Lemma}, \coqdockw{Fact}, and \coqdockw{Remark}) mean exactly the same
    thing to Coq.


    Secondly, we've added the quantifier \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat}, so that our
    theorem talks about \textit{all} natural numbers \coqdocvar{n}.  In order to prove
    theorems of this form, we need to to be able to reason by
    \textit{assuming} the existence of an arbitrary natural number \coqdocvar{n}.  This
    is achieved in the proof by \coqdoctac{intros} \coqdocvar{n}, which moves the quantifier
    from the goal to a ``context'' of current assumptions. In effect, we
    start the proof by saying ``OK, suppose \coqdocvar{n} is some arbitrary number.''


    The keywords \coqdoctac{intros}, \coqdoctac{simpl}, and \coqdoctac{reflexivity} are examples of
    \textit{tactics}.  A tactic is a command that is used between \coqdockw{Proof} and
    \coqdockw{Qed} to tell Coq how it should check the correctness of some
    claim we are making.  We will see several more tactics in the rest
    of this lecture, and yet more in future lectures. 

 We could try to prove a similar theorem about \coqdocvar{plus} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_n\_O} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{n} + 0 = \coqdocvar{n}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
However, unlike the previous proof, \coqdoctac{simpl} doesn't do anything in
    this case \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
(Can you explain why this happens?  Step through both proofs with
    Coq and notice how the goal and context change.) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_1\_l} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat}, 1 + \coqdocvar{n} = \coqdocvar{S} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{mult\_0\_l} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat}, 0 \ensuremath{\times} \coqdocvar{n} = 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqdocvar{\_l} suffix in the names of these theorems is
    pronounced ``on the left.'' \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Proof by Rewriting}



 Here is a slightly more interesting theorem: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_id\_example} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m}:\coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} = \coqdocvar{m} \ensuremath{\rightarrow} \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} + \coqdocvar{n} = \coqdocvar{m} + \coqdocvar{m}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Instead of making a completely universal claim about all numbers
    \coqdocvar{n} and \coqdocvar{m}, this theorem talks about a more specialized property
    that only holds when \coqdocvar{n} = \coqdocvar{m}.  The arrow symbol is pronounced
    ``implies.''


    As before, we need to be able to reason by assuming the existence
    of some numbers \coqdocvar{n} and \coqdocvar{m}.  We also need to assume the hypothesis
    \coqdocvar{n} = \coqdocvar{m}. The \coqdoctac{intros} tactic will serve to move all three of these
    from the goal into assumptions in the current context. 


    Since \coqdocvar{n} and \coqdocvar{m} are arbitrary numbers, we can't just use
    simplification to prove this theorem.  Instead, we prove it by
    observing that, if we are assuming \coqdocvar{n} = \coqdocvar{m}, then we can replace
    \coqdocvar{n} with \coqdocvar{m} in the goal statement and obtain an equality with the
    same expression on both sides.  The tactic that tells Coq to
    perform this replacement is called \coqdoctac{rewrite}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}. \coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H}. \coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{H}. \coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The first line of the proof moves the universally quantified
    variables \coqdocvar{n} and \coqdocvar{m} into the context.  The second moves the
    hypothesis \coqdocvar{n} = \coqdocvar{m} into the context and gives it the (arbitrary)
    name \coqdocvar{H}.  The third tells Coq to rewrite the current goal (\coqdocvar{n} + \coqdocvar{n}
    = \coqdocvar{m} + \coqdocvar{m}) by replacing the left side of the equality hypothesis
    \coqdocvar{H} with the right side.


    (The arrow symbol in the \coqdoctac{rewrite} has nothing to do with
    implication: it tells Coq to apply the rewrite from left to right.
    To rewrite from right to left, you can use \coqdoctac{rewrite} \ensuremath{\leftarrow}.  Try
    making this change in the above proof and see what difference it
    makes in Coq's behavior.) 

\paragraph{Exercise: 1 star (plus\_id\_exercise)}

 Remove ``\coqdocvar{Admitted}.'' and fill in the proof. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_id\_exercise} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} = \coqdocvar{m} \ensuremath{\rightarrow} \coqdocvar{m} = \coqdocvar{o} \ensuremath{\rightarrow} \coqdocvar{n} + \coqdocvar{m} = \coqdocvar{m} + \coqdocvar{o}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 As we've seen in earlier examples, the \coqdocvar{Admitted} command
    tells Coq that we want to skip trying to prove this theorem and
    just accept it as a given.  This can be useful for developing
    longer proofs, since we can state subsidiary facts that we believe
    will be useful for making some larger argument, use \coqdocvar{Admitted} to
    accept them on faith for the moment, and continue thinking about
    the larger argument until we are sure it makes sense; then we can
    go back and fill in the proofs we skipped.  Be careful, though:
    every time you say \coqdocvar{Admitted} (or \coqdocvar{admit}) you are leaving a door
    open for total nonsense to enter Coq's nice, rigorous, formally
    checked world! 

 We can also use the \coqdoctac{rewrite} tactic with a previously proved
    theorem instead of a hypothesis from the context. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{mult\_0\_plus} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
(0 + \coqdocvar{n}) \ensuremath{\times} \coqdocvar{m} = \coqdocvar{n} \ensuremath{\times} \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{plus\_O\_n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars (mult\_S\_1)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{mult\_S\_1} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{m} = \coqdocvar{S} \coqdocvar{n} \ensuremath{\rightarrow} \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{m} \ensuremath{\times} (1 + \coqdocvar{n}) = \coqdocvar{m} \ensuremath{\times} \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Proof by Case Analysis}



 Of course, not everything can be proved by simple
    calculation: In general, unknown, hypothetical values (arbitrary
    numbers, booleans, lists, etc.) can block the calculation.  
    For example, if we try to prove the following fact using the 
    \coqdoctac{simpl} tactic as above, we get stuck. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_1\_neq\_0\_firsttry} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beq\_nat} (\coqdocvar{n} + 1) 0 = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The reason for this is that the definitions of both
    \coqdocvar{beq\_nat} and + begin by performing a \coqdockw{match} on their first
    argument.  But here, the first argument to + is the unknown
    number \coqdocvar{n} and the argument to \coqdocvar{beq\_nat} is the compound
    expression \coqdocvar{n} + 1; neither can be simplified.


    What we need is to be able to consider the possible forms of \coqdocvar{n}
    separately.  If \coqdocvar{n} is \coqdocvar{O}, then we can calculate the final result
    of \coqdocvar{beq\_nat} (\coqdocvar{n} + 1) 0 and check that it is, indeed, \coqdocvar{false}.
    And if \coqdocvar{n} = \coqdocvar{S} \coqdocvar{n'} for some \coqdocvar{n'}, then, although we don't know
    exactly what number \coqdocvar{n} + 1 yields, we can calculate that, at
    least, it will begin with one \coqdocvar{S}, and this is enough to calculate
    that, again, \coqdocvar{beq\_nat} (\coqdocvar{n} + 1) 0 will yield \coqdocvar{false}.


    The tactic that tells Coq to consider, separately, the cases where
    \coqdocvar{n} = \coqdocvar{O} and where \coqdocvar{n} = \coqdocvar{S} \coqdocvar{n'} is called \coqdoctac{destruct}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_1\_neq\_0} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beq\_nat} (\coqdocvar{n} + 1) 0 = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{destruct} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqdoctac{destruct} generates \textit{two} subgoals, which we must then
    prove, separately, in order to get Coq to accept the theorem as
    proved.  (No special command is needed for moving from one subgoal
    to the other.  When the first subgoal has been proved, it just
    disappears and we are left with the other ``in focus.'')  In this
    proof, each of the subgoals is easily proved by a single use of
    \coqdoctac{reflexivity}.


    The annotation ``\coqdockw{as} [| \coqdocvar{n'}]'' is called an \textit{intro pattern}.  It
    tells Coq what variable names to introduce in each subgoal.  In
    general, what goes between the square brackets is a \textit{list} of
    lists of names, separated by \ensuremath{|}.  Here, the first component is
    empty, since the \coqdocvar{O} constructor is nullary (it doesn't carry any
    data).  The second component gives a single name, \coqdocvar{n'}, since \coqdocvar{S}
    is a unary constructor.


    The \coqdoctac{destruct} tactic can be used with any inductively defined
    datatype.  For example, we use it here to prove that boolean
    negation is involutive -- i.e., that negation is its own
    inverse. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{negb\_involutive} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} : \coqdocvar{bool},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{negb} (\coqdocvar{negb} \coqdocvar{b}) = \coqdocvar{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{b}. \coqdoctac{destruct} \coqdocvar{b}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Note that the \coqdoctac{destruct} here has no \coqdockw{as} clause because
    none of the subcases of the \coqdoctac{destruct} need to bind any variables,
    so there is no need to specify any names.  (We could also have
    written \coqdockw{as} [|], or \coqdockw{as} [].)  In fact, we can omit the \coqdockw{as}
    clause from \textit{any} \coqdoctac{destruct} and Coq will fill in variable names
    automatically.  Although this is convenient, it is arguably bad
    style, since Coq often makes confusing choices of names when left
    to its own devices. 

\paragraph{Exercise: 1 star (zero\_nbeq\_plus\_1)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{zero\_nbeq\_plus\_1} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beq\_nat} 0 (\coqdocvar{n} + 1) = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{More Exercises}



\paragraph{Exercise: 2 stars (boolean\_functions)}

 Use the tactics you have learned so far to prove the following 
    theorem about boolean functions. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{identity\_fn\_applied\_twice} : \coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{f} : \coqdocvar{bool} \ensuremath{\rightarrow} \coqdocvar{bool}), \coqdoceol
\coqdocindent{1.00em}
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{x} : \coqdocvar{bool}), \coqdocvar{f} \coqdocvar{x} = \coqdocvar{x}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{b} : \coqdocvar{bool}), \coqdocvar{f} (\coqdocvar{f} \coqdocvar{b}) = \coqdocvar{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now state and prove a theorem \coqdocvar{negation\_fn\_applied\_twice} similar
    to the previous one but where the second hypothesis says that the
    function \coqdocvar{f} has the property that \coqdocvar{f} \coqdocvar{x} = \coqdocvar{negb} \coqdocvar{x}.\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars (andb\_eq\_orb)}

 Prove the following theorem.  (You may want to first prove a
    subsidiary lemma or two. Alternatively, remember that you do
    not have to introduce all hypotheses at the same time.) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{andb\_eq\_orb} : \coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{b} \coqdocvar{c} : \coqdocvar{bool}),\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{andb} \coqdocvar{b} \coqdocvar{c} = \coqdocvar{orb} \coqdocvar{b} \coqdocvar{c}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{b} = \coqdocvar{c}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars (binary)}

 Consider a different, more efficient representation of natural
    numbers using a binary rather than unary system.  That is, instead
    of saying that each natural number is either zero or the successor
    of a natural number, we can say that each binary number is either



\begin{itemize}
\item  zero,

\item  twice a binary number, or

\item  one more than twice a binary number.

\end{itemize}


    (a) First, write an inductive definition of the type \coqdocvar{bin}
        corresponding to this description of binary numbers. 


    (Hint: Recall that the definition of \coqdocvar{nat} from class,
    Inductive nat : Type :=
      | O : nat
      | S : nat -> nat.
    says nothing about what \coqdocvar{O} and \coqdocvar{S} ``mean.''  It just says ``\coqdocvar{O} is
    in the set called \coqdocvar{nat}, and if \coqdocvar{n} is in the set then so is \coqdocvar{S}
    \coqdocvar{n}.''  The interpretation of \coqdocvar{O} as zero and \coqdocvar{S} as successor/plus
    one comes from the way that we \textit{use} \coqdocvar{nat} values, by writing
    functions to do things with them, proving things about them, and
    so on.  Your definition of \coqdocvar{bin} should be correspondingly simple;
    it is the functions you will write next that will give it
    mathematical meaning.)


    (b) Next, write an increment function \coqdocvar{incr} for binary numbers, 
        and a function \coqdocvar{bin\_to\_nat} to convert binary numbers to unary numbers.


    (c) Write five unit tests \coqdocvar{test\_bin\_incr1}, \coqdocvar{test\_bin\_incr2}, etc.
        for your increment and binary-to-unary functions. Notice that 
        incrementing a binary number and then converting it to unary 
        should yield the same result as first converting it to unary and 
        then incrementing. 
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{More on Notation (Advanced)}



 In general, sections marked Advanced are not needed to follow the
    rest of the book, except possibly other Advanced sections.  On a
    first reading, you might want to skim these sections so that you
    know what's there for future reference. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "x + y" := (\coqdocvar{plus} \coqdocvar{x} \coqdocvar{y})  \coqdoceol
\coqdocindent{11.50em}
(\coqdoctac{at} \coqdockw{level} 50, \coqdoctac{left} \coqdockw{associativity}) \coqdoceol
\coqdocindent{11.50em}
: \coqdocvar{nat\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} "x * y" := (\coqdocvar{mult} \coqdocvar{x} \coqdocvar{y})  \coqdoceol
\coqdocindent{11.50em}
(\coqdoctac{at} \coqdockw{level} 40, \coqdoctac{left} \coqdockw{associativity}) \coqdoceol
\coqdocindent{11.50em}
: \coqdocvar{nat\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For each notation-symbol in Coq we can specify its \textit{precedence level}
    and its \textit{associativity}. The precedence level n can be specified by the
    keywords \coqdoctac{at} \coqdockw{level} \coqdocvar{n} and it is helpful to disambiguate
    expressions containing different symbols. The associativity is helpful
    to disambiguate expressions containing more occurrences of the same 
    symbol. For example, the parameters specified above for + and \ensuremath{\times}
    say that the expression 1+2*3*4 is a shorthand for the expression
    (1+((2*3)*4)). Coq uses precedence levels from 0 to 100, and 
    \textit{left}, \textit{right}, or \textit{no} associativity.


    Each notation-symbol in Coq is also active in a \textit{notation scope}.  
    Coq tries to guess what scope you mean, so when you write \coqdocvar{S}(\coqdocvar{O}\ensuremath{\times}\coqdocvar{O}) 
    it guesses \coqdocvar{nat\_scope}, but when you write the cartesian
    product (tuple) type \coqdocvar{bool}\ensuremath{\times}\coqdocvar{bool} it guesses \coqdocvar{type\_scope}.
    Occasionally you have to help it out with percent-notation by
    writing (\coqdocvar{x}\ensuremath{\times}\coqdocvar{y})\%\coqdocvar{nat}, and sometimes in Coq's feedback to you it
    will use \%\coqdocvar{nat} to indicate what scope a notation is in.


    Notation scopes also apply to numeral notation (3,4,5, etc.), so you
    may sometimes see 0\%\coqdocvar{nat} which means \coqdocvar{O}, or 0\%\coqdocvar{Z} which means the
    Integer zero.


\section{\texorpdfstring{\protect\coqdockw{Fixpoint}}{Fixpoint} and Structural Recursion (Advanced)}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{plus'} (\coqdocvar{n} : \coqdocvar{nat}) (\coqdocvar{m} : \coqdocvar{nat}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{n} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{O} \ensuremath{\Rightarrow} \coqdocvar{m}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqdocvar{S} (\coqdocvar{plus'} \coqdocvar{n'} \coqdocvar{m})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
When Coq checks this definition, it notes that \coqdocvar{plus'} is
    ``decreasing on 1st argument.''  What this means is that we are
    performing a \textit{structural recursion} over the argument \coqdocvar{n} -- i.e.,
    that we make recursive calls only on strictly smaller values of
    \coqdocvar{n}.  This implies that all calls to \coqdocvar{plus'} will eventually
    terminate.  Coq demands that some argument of \textit{every} \coqdockw{Fixpoint}
    definition is ``decreasing''.


    This requirement is a fundamental feature of Coq's design: In
    particular, it guarantees that every function that can be defined
    in Coq will terminate on all inputs.  However, because Coq's
    ``decreasing analysis'' is not very sophisticated, it is sometimes
    necessary to write functions in slightly unnatural ways. 

\paragraph{Exercise: 2 stars, optional (decreasing)}

 To get a concrete sense of this, find a way to write a sensible
    \coqdockw{Fixpoint} definition (of a simple function on numbers, say) that
    \textit{does} terminate on all inputs, but that Coq will reject because
    of this restriction. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

 $Date: 2014-12-31 15:31:47 -0500 (Wed, 31 Dec 2014) $ \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{Top.Induction}{Library }{Top.Induction}

\begin{coqdoccode}
\end{coqdoccode}
\section{Induction: Proof by Induction}



 The next line imports all of our definitions from the
    previous chapter. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqdocvar{Basics}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For it to work, you need to use \coqdocvar{coqc} to compile \coqdocvar{Basics.v}
    into \coqdocvar{Basics.vo}.  (This is like making a .class file from a .java
    file, or a .o file from a .c file.)


    Here are two ways to compile your code:



\begin{itemize}
\item  CoqIDE:


         Open \coqdocvar{Basics.v}.
         In the ``Compile'' menu, click on ``Compile Buffer''.



\item  Command line:


         Run \coqdocvar{coqc} \coqdocvar{Basics.v}

\end{itemize}


    \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Naming Cases}



 The fact that there is no explicit command for moving from
    one branch of a case analysis to the next can make proof scripts
    rather hard to read.  In larger proofs, with nested case analyses,
    it can even become hard to stay oriented when you're sitting with
    Coq and stepping through the proof.  (Imagine trying to remember
    that the first five subgoals belong to the inner case analysis and
    the remaining seven cases are what remains of the outer one...)
    Disciplined use of indentation and comments can help, but a better
    way is to use the \coqdocvar{Case} tactic. 

 \coqdocvar{Case} is not built into Coq: we need to define it ourselves.
    There is no need to understand how it works -- you can just skip
    over the definition to the example that follows.  It uses some
    facilities of Coq that we have not discussed -- the string
    library (just for the concrete syntax of quoted strings) and the
    \coqdockw{Ltac} command, which allows us to declare custom tactics.  Kudos
    to Aaron Bohannon for this nice hack! \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdocvar{String}. \coqdockw{Open} \coqdockw{Scope} \coqdocvar{string\_scope}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{move\_to\_top} \coqdocvar{x} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{reverse} \coqdockw{goal} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{H} : \coqdocvar{\_} \ensuremath{\vdash} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoctac{try} \coqdoctac{move} \coqdocvar{x} \coqdockw{after} \coqdocvar{H}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Tactic Notation} "assert\_eq" \coqdocvar{ident}(\coqdocvar{x}) \coqdockw{constr}(\coqdocvar{v}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{let} \coqdocvar{H} := \coqdoctac{fresh} \coqdoctac{in}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{x} = \coqdocvar{v}) \coqdockw{as} \coqdocvar{H} \coqdoctac{by} \coqdoctac{reflexivity};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{clear} \coqdocvar{H}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Tactic Notation} "Case\_aux" \coqdocvar{ident}(\coqdocvar{x}) \coqdockw{constr}(\coqdocvar{name}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{first} [\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{set} (\coqdocvar{x} := \coqdocvar{name}); \coqdocvar{move\_to\_top} \coqdocvar{x}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{assert\_eq} \coqdocvar{x} \coqdocvar{name}; \coqdocvar{move\_to\_top} \coqdocvar{x}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdoctac{fail} 1 "because we are working on a different case" ].\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Tactic Notation} "Case" \coqdockw{constr}(\coqdocvar{name}) := \coqdocvar{Case\_aux} \coqdocvar{Case} \coqdocvar{name}.\coqdoceol
\coqdocnoindent
\coqdockw{Tactic Notation} "SCase" \coqdockw{constr}(\coqdocvar{name}) := \coqdocvar{Case\_aux} \coqdocvar{SCase} \coqdocvar{name}.\coqdoceol
\coqdocnoindent
\coqdockw{Tactic Notation} "SSCase" \coqdockw{constr}(\coqdocvar{name}) := \coqdocvar{Case\_aux} \coqdocvar{SSCase} \coqdocvar{name}.\coqdoceol
\coqdocnoindent
\coqdockw{Tactic Notation} "SSSCase" \coqdockw{constr}(\coqdocvar{name}) := \coqdocvar{Case\_aux} \coqdocvar{SSSCase} \coqdocvar{name}.\coqdoceol
\coqdocnoindent
\coqdockw{Tactic Notation} "SSSSCase" \coqdockw{constr}(\coqdocvar{name}) := \coqdocvar{Case\_aux} \coqdocvar{SSSSCase} \coqdocvar{name}.\coqdoceol
\coqdocnoindent
\coqdockw{Tactic Notation} "SSSSSCase" \coqdockw{constr}(\coqdocvar{name}) := \coqdocvar{Case\_aux} \coqdocvar{SSSSSCase} \coqdocvar{name}.\coqdoceol
\coqdocnoindent
\coqdockw{Tactic Notation} "SSSSSSCase" \coqdockw{constr}(\coqdocvar{name}) := \coqdocvar{Case\_aux} \coqdocvar{SSSSSSCase} \coqdocvar{name}.\coqdoceol
\coqdocnoindent
\coqdockw{Tactic Notation} "SSSSSSSCase" \coqdockw{constr}(\coqdocvar{name}) := \coqdocvar{Case\_aux} \coqdocvar{SSSSSSSCase} \coqdocvar{name}.\coqdoceol
\end{coqdoccode}
Here's an example of how \coqdocvar{Case} is used.  Step through the
   following proof and observe how the context changes. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{andb\_true\_elim1} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c} : \coqdocvar{bool},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{andb} \coqdocvar{b} \coqdocvar{c} = \coqdocvar{true} \ensuremath{\rightarrow} \coqdocvar{b} = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{b} \coqdocvar{c} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{b}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "b = true". \coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "b = false". \coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdocvar{Case} does something very straightforward: It simply adds a
    string that we choose (tagged with the identifier ``Case'') to the
    context for the current goal.  When subgoals are generated, this
    string is carried over into their contexts.  When the last of
    these subgoals is finally proved and the next top-level goal
    becomes active, this string will no longer appear in the context
    and we will be able to see that the case where we introduced it is
    complete.  Also, as a sanity check, if we try to execute a new
    \coqdocvar{Case} tactic while the string left by the previous one is still
    in the context, we get a nice clear error message.


    For nested case analyses (e.g., when we want to use a \coqdoctac{destruct}
    to solve a goal that has itself been generated by a \coqdoctac{destruct}),
    there is an \coqdocvar{SCase} (``subcase'') tactic. 

\paragraph{Exercise: 2 stars (andb\_true\_elim2)}

 Prove \coqdocvar{andb\_true\_elim2}, marking cases (and subcases) when
    you use \coqdoctac{destruct}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{andb\_true\_elim2} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c} : \coqdocvar{bool},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{andb} \coqdocvar{b} \coqdocvar{c} = \coqdocvar{true} \ensuremath{\rightarrow} \coqdocvar{c} = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 There are no hard and fast rules for how proofs should be
    formatted in Coq -- in particular, where lines should be broken
    and how sections of the proof should be indented to indicate their
    nested structure.  However, if the places where multiple subgoals
    are generated are marked with explicit \coqdocvar{Case} tactics placed at
    the beginning of lines, then the proof will be readable almost no
    matter what choices are made about other aspects of layout.


    This is a good place to mention one other piece of (possibly
    obvious) advice about line lengths.  Beginning Coq users sometimes
    tend to the extremes, either writing each tactic on its own line
    or entire proofs on one line.  Good style lies somewhere in the
    middle.  In particular, one reasonable convention is to limit
    yourself to 80-character lines.  Lines longer than this are hard
    to read and can be inconvenient to display and print.  Many
    editors have features that help enforce this. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Proof by Induction}



 We proved in the last chapter that 0 is a neutral element
    for + on the left using a simple argument.  The fact that it is
    also a neutral element on the \textit{right}... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_0\_r\_firsttry} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} + 0 = \coqdocvar{n}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
... cannot be proved in the same simple way.  Just applying
  \coqdoctac{reflexivity} doesn't work: the \coqdocvar{n} in \coqdocvar{n} + 0 is an arbitrary
  unknown number, so the \coqdockw{match} in the definition of + can't be
  simplified.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }



 And reasoning by cases using \coqdoctac{destruct} \coqdocvar{n} doesn't get us much
   further: the branch of the case analysis where we assume \coqdocvar{n} = 0
   goes through, but in the branch where \coqdocvar{n} = \coqdocvar{S} \coqdocvar{n'} for some \coqdocvar{n'} we
   get stuck in exactly the same way.  We could use \coqdoctac{destruct} \coqdocvar{n'} to
   get one step further, but since \coqdocvar{n} can be arbitrarily large, if we
   try to keep on like this we'll never be done. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_0\_r\_secondtry} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} + 0 = \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{destruct} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "n = 0".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}. \coqdocindent{1.00em}
\coqdocvar{Case} "n = S n'".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }



 To prove such facts -- indeed, to prove most interesting
    facts about numbers, lists, and other inductively defined sets --
    we need a more powerful reasoning principle: \textit{induction}.


    Recall (from high school) the principle of induction over natural
    numbers: If \coqdocvar{P}(\coqdocvar{n}) is some proposition involving a natural number
    \coqdocvar{n} and we want to show that P holds for \textit{all} numbers \coqdocvar{n}, we can
    reason like this:



\begin{itemize}
\item  show that \coqdocvar{P}(\coqdocvar{O}) holds;

\item  show that, for any \coqdocvar{n'}, if \coqdocvar{P}(\coqdocvar{n'}) holds, then so does
           \coqdocvar{P}(\coqdocvar{S} \coqdocvar{n'});

\item  conclude that \coqdocvar{P}(\coqdocvar{n}) holds for all \coqdocvar{n}.

\end{itemize}


    In Coq, the steps are the same but the order is backwards: we
    begin with the goal of proving \coqdocvar{P}(\coqdocvar{n}) for all \coqdocvar{n} and break it
    down (by applying the \coqdoctac{induction} tactic) into two separate
    subgoals: first showing \coqdocvar{P}(\coqdocvar{O}) and then showing \coqdocvar{P}(\coqdocvar{n'}) \ensuremath{\rightarrow} \coqdocvar{P}(\coqdocvar{S}
    \coqdocvar{n'}).  Here's how this works for the theorem we are trying to
    prove at the moment: 

\subsubsection{ }

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_0\_r} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat}, \coqdocvar{n} + 0 = \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "n = 0". \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "n = S n'". \coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHn'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Like \coqdoctac{destruct}, the \coqdoctac{induction} tactic takes an \coqdockw{as}...
    clause that specifies the names of the variables to be introduced
    in the subgoals.  In the first branch, \coqdocvar{n} is replaced by 0 and
    the goal becomes 0 + 0 = 0, which follows by simplification.  In
    the second, \coqdocvar{n} is replaced by \coqdocvar{S} \coqdocvar{n'} and the assumption \coqdocvar{n'} + 0 =
    \coqdocvar{n'} is added to the context (with the name \coqdocvar{IHn'}, i.e., the
    Induction Hypothesis for \coqdocvar{n'}).  The goal in this case becomes (\coqdocvar{S}
    \coqdocvar{n'}) + 0 = \coqdocvar{S} \coqdocvar{n'}, which simplifies to \coqdocvar{S} (\coqdocvar{n'} + 0) = \coqdocvar{S} \coqdocvar{n'}, which in
    turn follows from the induction hypothesis. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{minus\_diag} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{minus} \coqdocvar{n} \coqdocvar{n} = 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "n = 0".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "n = S n'".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHn'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars (basic\_induction)}



 Prove the following lemmas using induction. You might need
    previously proven results. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{mult\_0\_r} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} \ensuremath{\times} 0 = 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_n\_Sm} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{S} (\coqdocvar{n} + \coqdocvar{m}) = \coqdocvar{n} + (\coqdocvar{S} \coqdocvar{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_comm} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} + \coqdocvar{m} = \coqdocvar{m} + \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_assoc} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} + (\coqdocvar{m} + \coqdocvar{p}) = (\coqdocvar{n} + \coqdocvar{m}) + \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars (double\_plus)}



 Consider the following function, which doubles its argument: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{double} (\coqdocvar{n}:\coqdocvar{nat}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{n} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{O} \ensuremath{\Rightarrow} \coqdocvar{O}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqdocvar{S} (\coqdocvar{S} (\coqdocvar{double} \coqdocvar{n'}))\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Use induction to prove this simple fact about \coqdocvar{double}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{double\_plus} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{double} \coqdocvar{n} = \coqdocvar{n} + \coqdocvar{n} .\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 1 star (destruct\_induction)}

 Briefly explain the difference between the tactics
    \coqdoctac{destruct} and \coqdoctac{induction}.  




 \ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Proofs Within Proofs}



 In Coq, as in informal mathematics, large proofs are very
    often broken into a sequence of theorems, with later proofs
    referring to earlier theorems.  Occasionally, however, a proof
    will need some miscellaneous fact that is too trivial (and of too
    little general interest) to bother giving it its own top-level
    name.  In such cases, it is convenient to be able to simply state
    and prove the needed ``sub-theorem'' right at the point where it is
    used.  The \coqdoctac{assert} tactic allows us to do this.  For example, our
    earlier proof of the \coqdocvar{mult\_0\_plus} theorem referred to a previous
    theorem named \coqdocvar{plus\_O\_n}.  We can also use \coqdoctac{assert} to state and
    prove \coqdocvar{plus\_O\_n} in-line: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{mult\_0\_plus'} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
(0 + \coqdocvar{n}) \ensuremath{\times} \coqdocvar{m} = \coqdocvar{n} \ensuremath{\times} \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{H}: 0 + \coqdocvar{n} = \coqdocvar{n}).\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "Proof of assertion". \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqdoctac{assert} tactic introduces two sub-goals.  The first is
    the assertion itself; by prefixing it with \coqdocvar{H}: we name the
    assertion \coqdocvar{H}.  (Note that we could also name the assertion with
    \coqdockw{as} just as we did above with \coqdoctac{destruct} and \coqdoctac{induction}, i.e.,
    \coqdoctac{assert} (0 + \coqdocvar{n} = \coqdocvar{n}) \coqdockw{as} \coqdocvar{H}.  Also note that we mark the proof of
    this assertion with a \coqdocvar{Case}, both for readability and so that,
    when using Coq interactively, we can see when we're finished
    proving the assertion by observing when the "\coqdockw{Proof} \coqdocvar{of} \coqdocvar{assertion}"
    string disappears from the context.)  The second goal is the same
    as the one at the point where we invoke \coqdoctac{assert}, except that, in
    the context, we have the assumption \coqdocvar{H} that 0 + \coqdocvar{n} = \coqdocvar{n}.  That
    is, \coqdoctac{assert} generates one subgoal where we must prove the
    asserted fact and a second subgoal where we can use the asserted
    fact to make progress on whatever we were trying to prove in the
    first place. 

 Actually, \coqdoctac{assert} will turn out to be handy in many sorts of
    situations.  For example, suppose we want to prove that (\coqdocvar{n} + \coqdocvar{m})
    + (\coqdocvar{p} + \coqdocvar{q}) = (\coqdocvar{m} + \coqdocvar{n}) + (\coqdocvar{p} + \coqdocvar{q}). The only difference between the
    two sides of the = is that the arguments \coqdocvar{m} and \coqdocvar{n} to the
    first inner + are swapped, so it seems we should be able to
    use the commutativity of addition (\coqdocvar{plus\_comm}) to rewrite one
    into the other.  However, the \coqdoctac{rewrite} tactic is a little stupid
    about \textit{where} it applies the rewrite.  There are three uses of
    + here, and it turns out that doing \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{plus\_comm}
    will affect only the \textit{outer} one. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_rearrange\_firsttry} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} \coqdocvar{q} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{n} + \coqdocvar{m}) + (\coqdocvar{p} + \coqdocvar{q}) = (\coqdocvar{m} + \coqdocvar{n}) + (\coqdocvar{p} + \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{plus\_comm}.\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
To get \coqdocvar{plus\_comm} to apply at the point where we want it, we can
    introduce a local lemma stating that \coqdocvar{n} + \coqdocvar{m} = \coqdocvar{m} + \coqdocvar{n} (for
    the particular \coqdocvar{m} and \coqdocvar{n} that we are talking about here), prove
    this lemma using \coqdocvar{plus\_comm}, and then use this lemma to do the
    desired rewrite. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_rearrange} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} \coqdocvar{q} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{n} + \coqdocvar{m}) + (\coqdocvar{p} + \coqdocvar{q}) = (\coqdocvar{m} + \coqdocvar{n}) + (\coqdocvar{p} + \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{H}: \coqdocvar{n} + \coqdocvar{m} = \coqdocvar{m} + \coqdocvar{n}).\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "Proof of assertion".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{plus\_comm}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{H}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 4 stars (mult\_comm)}

 Use \coqdoctac{assert} to help prove this theorem.  You shouldn't need to
    use induction. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_swap} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqdocvar{nat}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} + (\coqdocvar{m} + \coqdocvar{p}) = \coqdocvar{m} + (\coqdocvar{n} + \coqdocvar{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now prove commutativity of multiplication.  (You will probably
    need to define and prove a separate subsidiary theorem to be used
    in the proof of this one.)  You may find that \coqdocvar{plus\_swap} comes in
    handy. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{mult\_comm} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n} : \coqdocvar{nat},\coqdoceol
\coqdocindent{0.50em}
\coqdocvar{m} \ensuremath{\times} \coqdocvar{n} = \coqdocvar{n} \ensuremath{\times} \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars, optional (evenb\_n\_\_oddb\_Sn)}



 Prove the following simple fact: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{evenb\_n\_\_oddb\_Sn} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{evenb} \coqdocvar{n} = \coqdocvar{negb} (\coqdocvar{evenb} (\coqdocvar{S} \coqdocvar{n})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{More Exercises}



\paragraph{Exercise: 3 stars, optional (more\_exercises)}

 Take a piece of paper.  For each of the following theorems, first
    \textit{think} about whether (a) it can be proved using only
    simplification and rewriting, (b) it also requires case
    analysis (\coqdoctac{destruct}), or (c) it also requires induction.  Write
    down your prediction.  Then fill in the proof.  (There is no need
    to turn in your piece of paper; this is just to encourage you to
    reflect before hacking!) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{ble\_nat\_refl} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{true} = \coqdocvar{ble\_nat} \coqdocvar{n} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{zero\_nbeq\_S} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beq\_nat} 0 (\coqdocvar{S} \coqdocvar{n}) = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{andb\_false\_r} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} : \coqdocvar{bool},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{andb} \coqdocvar{b} \coqdocvar{false} = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_ble\_compat\_l} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqdocvar{nat}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ble\_nat} \coqdocvar{n} \coqdocvar{m} = \coqdocvar{true} \ensuremath{\rightarrow} \coqdocvar{ble\_nat} (\coqdocvar{p} + \coqdocvar{n}) (\coqdocvar{p} + \coqdocvar{m}) = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{S\_nbeq\_0} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beq\_nat} (\coqdocvar{S} \coqdocvar{n}) 0 = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{mult\_1\_l} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat}, 1 \ensuremath{\times} \coqdocvar{n} = \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{all3\_spec} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c} : \coqdocvar{bool},\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{orb}\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{andb} \coqdocvar{b} \coqdocvar{c})\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{orb} (\coqdocvar{negb} \coqdocvar{b})\coqdoceol
\coqdocindent{7.50em}
(\coqdocvar{negb} \coqdocvar{c}))\coqdoceol
\coqdocindent{1.00em}
= \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{mult\_plus\_distr\_r} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{n} + \coqdocvar{m}) \ensuremath{\times} \coqdocvar{p} = (\coqdocvar{n} \ensuremath{\times} \coqdocvar{p}) + (\coqdocvar{m} \ensuremath{\times} \coqdocvar{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{mult\_assoc} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} \ensuremath{\times} (\coqdocvar{m} \ensuremath{\times} \coqdocvar{p}) = (\coqdocvar{n} \ensuremath{\times} \coqdocvar{m}) \ensuremath{\times} \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars, optional (beq\_nat\_refl)}

 Prove the following theorem.  Putting \coqdocvar{true} on the left-hand side
of the equality may seem odd, but this is how the theorem is stated in
the standard library, so we follow suit.  Since rewriting 
works equally well in either direction, we will have no 
problem using the theorem no matter which way we state it. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{beq\_nat\_refl} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqdocvar{nat}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{true} = \coqdocvar{beq\_nat} \coqdocvar{n} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars, optional (plus\_swap')}

 The \coqdoctac{replace} tactic allows you to specify a particular subterm to
   rewrite and what you want it rewritten to.  More precisely,
   \coqdoctac{replace} (\coqdocvar{t}) \coqdockw{with} (\coqdocvar{u}) replaces (all copies of) expression \coqdocvar{t} in
   the goal by expression \coqdocvar{u}, and generates \coqdocvar{t} = \coqdocvar{u} as an additional
   subgoal. This is often useful when a plain \coqdoctac{rewrite} acts on the wrong
   part of the goal.  


   Use the \coqdoctac{replace} tactic to do a proof of \coqdocvar{plus\_swap'}, just like
   \coqdocvar{plus\_swap} but without needing \coqdoctac{assert} (\coqdocvar{n} + \coqdocvar{m} = \coqdocvar{m} + \coqdocvar{n}). 
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_swap'} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqdocvar{nat}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} + (\coqdocvar{m} + \coqdocvar{p}) = \coqdocvar{m} + (\coqdocvar{n} + \coqdocvar{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars (binary\_commute)}

 Recall the \coqdocvar{increment} and \coqdocvar{binary}-\coqdocvar{to}-\coqdocvar{unary} functions that you
    wrote for the \coqdocvar{binary} exercise in the \coqdocvar{Basics} chapter.  Prove
    that these functions commute -- that is, incrementing a binary
    number and then converting it to unary yields the same result as
    first converting it to unary and then incrementing.
    Name your theorem \coqdocvar{bin\_to\_nat\_pres\_incr}.


    (Before you start working on this exercise, please copy the
    definitions from your solution to the \coqdocvar{binary} exercise here so
    that this file can be graded on its own.  If you find yourself
    wanting to change your original definitions to make the property
    easier to prove, feel free to do so.) \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 5 stars, advanced (binary\_inverse)}

 This exercise is a continuation of the previous exercise about
    binary numbers.  You will need your definitions and theorems from
    the previous exercise to complete this one.


    (a) First, write a function to convert natural numbers to binary
        numbers.  Then prove that starting with any natural number,
        converting to binary, then converting back yields the same
        natural number you started with.


    (b) You might naturally think that we should also prove the
        opposite direction: that starting with a binary number,
        converting to a natural, and then back to binary yields the
        same number we started with.  However, it is not true!
        Explain what the problem is.


    (c) Define a ``direct'' normalization function -- i.e., a function
        \coqdocvar{normalize} from binary numbers to binary numbers such that,
        for any binary number b, converting to a natural and then back
        to binary yields (\coqdocvar{normalize} \coqdocvar{b}).  Prove it.  (Warning: This
        part is tricky!)


    Again, feel free to change your earlier definitions if this helps
    here. 
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Formal vs. Informal Proof (Advanced)}



 ``Informal proofs are algorithms; formal proofs are code.'' 

 The question of what, exactly, constitutes a ``proof'' of a
    mathematical claim has challenged philosophers for millennia.  A
    rough and ready definition, though, could be this: a proof of a
    mathematical proposition \coqdocvar{P} is a written (or spoken) text that
    instills in the reader or hearer the certainty that \coqdocvar{P} is true.
    That is, a proof is an act of communication.


    Now, acts of communication may involve different sorts of readers.
    On one hand, the ``reader'' can be a program like Coq, in which case
    the ``belief'' that is instilled is a simple mechanical check that
    \coqdocvar{P} can be derived from a certain set of formal logical rules, and
    the proof is a recipe that guides the program in performing this
    check.  Such recipes are \textit{formal} proofs.


    Alternatively, the reader can be a human being, in which case the
    proof will be written in English or some other natural language,
    thus necessarily \textit{informal}.  Here, the criteria for success are
    less clearly specified.  A ``good'' proof is one that makes the
    reader believe \coqdocvar{P}.  But the same proof may be read by many
    different readers, some of whom may be convinced by a particular
    way of phrasing the argument, while others may not be.  One reader
    may be particularly pedantic, inexperienced, or just plain
    thick-headed; the only way to convince them will be to make the
    argument in painstaking detail.  But another reader, more familiar
    in the area, may find all this detail so overwhelming that they
    lose the overall thread.  All they want is to be told the main
    ideas, because it is easier to fill in the details for themselves.
    Ultimately, there is no universal standard, because there is no
    single way of writing an informal proof that is guaranteed to
    convince every conceivable reader.  In practice, however,
    mathematicians have developed a rich set of conventions and idioms
    for writing about complex mathematical objects that, within a
    certain community, make communication fairly reliable.  The
    conventions of this stylized form of communication give a fairly
    clear standard for judging proofs good or bad.


    Because we are using Coq in this course, we will be working
    heavily with formal proofs.  But this doesn't mean we can ignore
    the informal ones!  Formal proofs are useful in many ways, but
    they are \textit{not} very efficient ways of communicating ideas between
    human beings. 

 For example, here is a proof that addition is associative: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_assoc'} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} + (\coqdocvar{m} + \coqdocvar{p}) = (\coqdocvar{n} + \coqdocvar{m}) + \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}]. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHn'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Coq is perfectly happy with this as a proof.  For a human,
    however, it is difficult to make much sense of it.  If you're used
    to Coq you can probably step through the tactics one after the
    other in your mind and imagine the state of the context and goal
    stack at each point, but if the proof were even a little bit more
    complicated this would be next to impossible.  Instead, a
    mathematician might write it something like this: 


\begin{itemize}
\item  \textit{Theorem}: For any \coqdocvar{n}, \coqdocvar{m} and \coqdocvar{p},
      n + (m + p) = (n + m) + p.
    \textit{Proof}: By induction on \coqdocvar{n}.



\begin{itemize}
\item  First, suppose \coqdocvar{n} = 0.  We must show 
        0 + (m + p) = (0 + m) + p.  
      This follows directly from the definition of +.



\item  Next, suppose \coqdocvar{n} = \coqdocvar{S} \coqdocvar{n'}, where
        n' + (m + p) = (n' + m) + p.
      We must show
        (S n') + (m + p) = ((S n') + m) + p.
      By the definition of +, this follows from
        S (n' + (m + p)) = S ((n' + m) + p),
      which is immediate from the induction hypothesis. 
\end{itemize}

\end{itemize}
 \textit{Qed} 

 The overall form of the proof is basically similar.  This is
    no accident: Coq has been designed so that its \coqdoctac{induction} tactic
    generates the same sub-goals, in the same order, as the bullet
    points that a mathematician would write.  But there are
    significant differences of detail: the formal proof is much more
    explicit in some ways (e.g., the use of \coqdoctac{reflexivity}) but much
    less explicit in others (in particular, the ``proof state'' at any
    given point in the Coq proof is completely implicit, whereas the
    informal proof reminds the reader several times where things
    stand). 

 Here is a formal proof that shows the structure more
    clearly: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_assoc'{}'} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqdocvar{nat},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} + (\coqdocvar{m} + \coqdocvar{p}) = (\coqdocvar{n} + \coqdocvar{m}) + \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "n = 0".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "n = S n'".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHn'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars, advanced (plus\_comm\_informal)}

 Translate your solution for \coqdocvar{plus\_comm} into an informal proof. 

 Theorem: Addition is commutative.


    Proof:  \ensuremath{\Box} 

\paragraph{Exercise: 2 stars, optional (beq\_nat\_refl\_informal)}

 Write an informal proof of the following theorem, using the
    informal proof of \coqdocvar{plus\_assoc} as a model.  Don't just
    paraphrase the Coq tactics into English!


    Theorem: \coqdocvar{true} = \coqdocvar{beq\_nat} \coqdocvar{n} \coqdocvar{n} for any \coqdocvar{n}.


    Proof: \ensuremath{\Box} 

 $Date: 2014-12-31 15:31:47 -0500 (Wed, 31 Dec 2014) $ \begin{coqdoccode}
\end{coqdoccode}
\coqlibrary{Top.Lists}{Library }{Top.Lists}

\begin{coqdoccode}
\end{coqdoccode}
\section{Lists: Working with Structured Data}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqdockw{Induction}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdocvar{NatList}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Pairs of Numbers}



 In an \coqdockw{Inductive} type definition, each constructor can take
    any number of arguments -- none (as with \coqdocvar{true} and \coqdocvar{O}), one (as
    with \coqdocvar{S}), or more than one, as in this definition: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{natprod} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{pair} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{natprod}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This declaration can be read: ``There is just one way to
    construct a pair of numbers: by applying the constructor \coqdocvar{pair} to
    two arguments of type \coqdocvar{nat}.'' 

 We can construct an element of \coqdocvar{natprod} like this: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqdocvar{pair} 3 5).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }



 Here are two simple function definitions for extracting the
    first and second components of a pair.  (The definitions also
    illustrate how to do pattern matching on two-argument
    constructors.) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{fst} (\coqdocvar{p} : \coqdocvar{natprod}) : \coqdocvar{nat} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pair} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqdocvar{x}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{snd} (\coqdocvar{p} : \coqdocvar{natprod}) : \coqdocvar{nat} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pair} \coqdocvar{x} \coqdocvar{y} \ensuremath{\Rightarrow} \coqdocvar{y}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Eval} \coqdoctac{compute} \coqdoctac{in} (\coqdocvar{fst} (\coqdocvar{pair} 3 5)).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }



 Since pairs are used quite a bit, it is nice to be able to
    write them with the standard mathematical notation (\coqdocvar{x},\coqdocvar{y}) instead
    of \coqdocvar{pair} \coqdocvar{x} \coqdocvar{y}.  We can tell Coq to allow this with a \coqdockw{Notation}
    declaration. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "( x , y )" := (\coqdocvar{pair} \coqdocvar{x} \coqdocvar{y}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The new notation can be used both in expressions and in
    pattern matches (indeed, we've seen it already in the previous
    chapter -- this notation is provided as part of the standard
    library): \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Eval} \coqdoctac{compute} \coqdoctac{in} (\coqdocvar{fst} (3,5)).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{fst'} (\coqdocvar{p} : \coqdocvar{natprod}) : \coqdocvar{nat} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} (\coqdocvar{x},\coqdocvar{y}) \ensuremath{\Rightarrow} \coqdocvar{x}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{snd'} (\coqdocvar{p} : \coqdocvar{natprod}) : \coqdocvar{nat} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} (\coqdocvar{x},\coqdocvar{y}) \ensuremath{\Rightarrow} \coqdocvar{y}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{swap\_pair} (\coqdocvar{p} : \coqdocvar{natprod}) : \coqdocvar{natprod} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{p} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} (\coqdocvar{x},\coqdocvar{y}) \ensuremath{\Rightarrow} (\coqdocvar{y},\coqdocvar{x})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }



 Let's try and prove a few simple facts about pairs.  If we
    state the lemmas in a particular (and slightly peculiar) way, we
    can prove them with just reflexivity (and its built-in
    simplification): \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{surjective\_pairing'} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{n},\coqdocvar{m}) = (\coqdocvar{fst} (\coqdocvar{n},\coqdocvar{m}), \coqdocvar{snd} (\coqdocvar{n},\coqdocvar{m})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Note that \coqdoctac{reflexivity} is not enough if we state the lemma in a
    more natural way: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{surjective\_pairing\_stuck} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} : \coqdocvar{natprod}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{p} = (\coqdocvar{fst} \coqdocvar{p}, \coqdocvar{snd} \coqdocvar{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 We have to expose the structure of \coqdocvar{p} so that \coqdoctac{simpl} can
    perform the pattern match in \coqdocvar{fst} and \coqdocvar{snd}.  We can do this with
    \coqdoctac{destruct}.


    Notice that, unlike for \coqdocvar{nat}s, \coqdoctac{destruct} doesn't generate an
    extra subgoal here.  That's because \coqdocvar{natprod}s can only be
    constructed in one way.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{surjective\_pairing} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} : \coqdocvar{natprod}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{p} = (\coqdocvar{fst} \coqdocvar{p}, \coqdocvar{snd} \coqdocvar{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p}. \coqdoctac{destruct} \coqdocvar{p} \coqdockw{as} [\coqdocvar{n} \coqdocvar{m}]. \coqdoctac{simpl}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star (snd\_fst\_is\_swap)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{snd\_fst\_is\_swap} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} : \coqdocvar{natprod}),\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{snd} \coqdocvar{p}, \coqdocvar{fst} \coqdocvar{p}) = \coqdocvar{swap\_pair} \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 1 star, optional (fst\_swap\_is\_snd)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{fst\_swap\_is\_snd} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} : \coqdocvar{natprod}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{fst} (\coqdocvar{swap\_pair} \coqdocvar{p}) = \coqdocvar{snd} \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Lists of Numbers}



 Generalizing the definition of pairs a little, we can
    describe the type of \textit{lists} of numbers like this: ``A list is
    either the empty list or else a pair of a number and another
    list.'' \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{natlist} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil} : \coqdocvar{natlist}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{cons} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{natlist} \ensuremath{\rightarrow} \coqdocvar{natlist}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For example, here is a three-element list: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{mylist} := \coqdocvar{cons} 1 (\coqdocvar{cons} 2 (\coqdocvar{cons} 3 \coqdocvar{nil})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 As with pairs, it is more convenient to write lists in
    familiar programming notation.  The following two declarations
    allow us to use :: as an infix \coqdocvar{cons} operator and square
    brackets as an ``outfix'' notation for constructing lists. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "x :: l" := (\coqdocvar{cons} \coqdocvar{x} \coqdocvar{l}) (\coqdoctac{at} \coqdockw{level} 60, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} "[ ]" := \coqdocvar{nil}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} "[ x ; .. ; y ]" := (\coqdocvar{cons} \coqdocvar{x} .. (\coqdocvar{cons} \coqdocvar{y} \coqdocvar{nil}) ..).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
It is not necessary to fully understand these declarations,
    but in case you are interested, here is roughly what's going on.


    The \coqdoctac{right} \coqdockw{associativity} annotation tells Coq how to parenthesize
    expressions involving several uses of :: so that, for example,
    the next three declarations mean exactly the same thing: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{mylist1} := 1 :: (2 :: (3 :: \coqdocvar{nil})).\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{mylist2} := 1 :: 2 :: 3 :: \coqdocvar{nil}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{mylist3} := [1;2;3].\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqdoctac{at} \coqdockw{level} 60 part tells Coq how to parenthesize
    expressions that involve both :: and some other infix operator.
    For example, since we defined + as infix notation for the \coqdocvar{plus}
    function at level 50,
Notation ``x + y'' := (plus x y)  
                    (at level 50, left associativity).
   The + operator will bind tighter than ::, so 1 + 2 :: [3]
   will be parsed, as we'd expect, as (1 + 2) :: [3] rather than 1
   + (2 :: [3]).


   (By the way, it's worth noting in passing that expressions like ``1
   + 2 :: [3]'' can be a little confusing when you read them in a .v
   file.  The inner brackets, around 3, indicate a list, but the outer
   brackets, which are invisible in the HTML rendering, are there to
   instruct the ``coqdoc'' tool that the bracketed part should be
   displayed as Coq code rather than running text.)


   The second and third \coqdockw{Notation} declarations above introduce the
   standard square-bracket notation for lists; the right-hand side of
   the third one illustrates Coq's syntax for declaring n-ary
   notations and translating them to nested sequences of binary
   constructors. 

\subsubsection{Repeat}

 A number of functions are useful for manipulating lists.
    For example, the \coqdoctac{repeat} function takes a number \coqdocvar{n} and a
    \coqdocvar{count} and returns a list of length \coqdocvar{count} where every element
    is \coqdocvar{n}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdoctac{repeat} (\coqdocvar{n} \coqdocvar{count} : \coqdocvar{nat}) : \coqdocvar{natlist} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{count} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{O} \ensuremath{\Rightarrow} \coqdocvar{nil}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{count'} \ensuremath{\Rightarrow} \coqdocvar{n} :: (\coqdoctac{repeat} \coqdocvar{n} \coqdocvar{count'})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Length}

 The \coqdocvar{length} function calculates the length of a list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{length} (\coqdocvar{l}:\coqdocvar{natlist}) : \coqdocvar{nat} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil} \ensuremath{\Rightarrow} \coqdocvar{O}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} :: \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{S} (\coqdocvar{length} \coqdocvar{t})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Append}

 The \coqdocvar{app} (``append'') function concatenates two lists. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{app} (\coqdocvar{l1} \coqdocvar{l2} : \coqdocvar{natlist}) : \coqdocvar{natlist} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l1} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil}    \ensuremath{\Rightarrow} \coqdocvar{l2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} :: \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{h} :: (\coqdocvar{app} \coqdocvar{t} \coqdocvar{l2})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Actually, \coqdocvar{app} will be used a lot in some parts of what
    follows, so it is convenient to have an infix operator for it. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "x ++ y" := (\coqdocvar{app} \coqdocvar{x} \coqdocvar{y}) \coqdoceol
\coqdocindent{10.50em}
(\coqdoctac{right} \coqdockw{associativity}, \coqdoctac{at} \coqdockw{level} 60).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_app1}:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_app2}:             \coqdocvar{nil} ++ [4;5] = [4;5].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_app3}:             [1;2;3] ++ \coqdocvar{nil} = [1;2;3].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here are two smaller examples of programming with lists.
    The \coqdocvar{hd} function returns the first element (the ``head'') of the
    list, while \coqdocvar{tl} returns everything but the first
    element (the ``tail'').  
    Of course, the empty list has no first element, so we
    must pass a default value to be returned in that case.  

\subsubsection{Head (with default) and Tail}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{hd} (\coqdocvar{default}:\coqdocvar{nat}) (\coqdocvar{l}:\coqdocvar{natlist}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil} \ensuremath{\Rightarrow} \coqdocvar{default}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} :: \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{h}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{tl} (\coqdocvar{l}:\coqdocvar{natlist}) : \coqdocvar{natlist} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil} \ensuremath{\Rightarrow} \coqdocvar{nil}  \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} :: \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{t}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_hd1}:             \coqdocvar{hd} 0 [1;2;3] = 1.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_hd2}:             \coqdocvar{hd} 0 [] = 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_tl}:              \coqdocvar{tl} [1;2;3] = [2;3].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars (list\_funs)}

 Complete the definitions of \coqdocvar{nonzeros}, \coqdocvar{oddmembers} and
    \coqdocvar{countoddmembers} below. Have a look at the tests to understand
    what these functions should do. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{nonzeros} (\coqdocvar{l}:\coqdocvar{natlist}) : \coqdocvar{natlist} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_nonzeros}:            \coqdocvar{nonzeros} [0;1;0;2;3;0;0] = [1;2;3].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{oddmembers} (\coqdocvar{l}:\coqdocvar{natlist}) : \coqdocvar{natlist} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_oddmembers}:            \coqdocvar{oddmembers} [0;1;0;2;3;0;0] = [1;3].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{countoddmembers} (\coqdocvar{l}:\coqdocvar{natlist}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_countoddmembers1}:    \coqdocvar{countoddmembers} [1;0;3;1;4;5] = 4.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_countoddmembers2}:    \coqdocvar{countoddmembers} [0;2;4] = 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_countoddmembers3}:    \coqdocvar{countoddmembers} \coqdocvar{nil} = 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, advanced (alternate)}

 Complete the definition of \coqdocvar{alternate}, which ``zips up'' two lists
    into one, alternating between elements taken from the first list
    and elements from the second.  See the tests below for more
    specific examples.


    Note: one natural and elegant way of writing \coqdocvar{alternate} will fail
    to satisfy Coq's requirement that all \coqdockw{Fixpoint} definitions be
    ``obviously terminating.''  If you find yourself in this rut, look
    for a slightly more verbose solution that considers elements of
    both lists at the same time.  (One possible solution requires
    defining a new kind of pairs, but this is not the only way.)  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{alternate} (\coqdocvar{l1} \coqdocvar{l2} : \coqdocvar{natlist}) : \coqdocvar{natlist} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_alternate1}:        \coqdocvar{alternate} [1;2;3] [4;5;6] = [1;4;2;5;3;6].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_alternate2}:        \coqdocvar{alternate} [1] [4;5;6] = [1;4;5;6].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_alternate3}:        \coqdocvar{alternate} [1;2;3] [4] = [1;4;2;3].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_alternate4}:        \coqdocvar{alternate} [] [20;30] = [20;30].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Bags via Lists}



 A \coqdocvar{bag} (or \coqdocvar{multiset}) is like a set, but each element can appear
    multiple times instead of just once.  One reasonable
    implementation of bags is to represent a bag of numbers as a
    list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{bag} := \coqdocvar{natlist}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 3 stars (bag\_functions)}

 Complete the following definitions for the functions
    \coqdocvar{count}, \coqdocvar{sum}, \coqdocvar{add}, and \coqdocvar{member} for bags. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{count} (\coqdocvar{v}:\coqdocvar{nat}) (\coqdocvar{s}:\coqdocvar{bag}) : \coqdocvar{nat} := \coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
All these proofs can be done just by \coqdoctac{reflexivity}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_count1}:              \coqdocvar{count} 1 [1;2;3;1;4;1] = 3.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_count2}:              \coqdocvar{count} 6 [1;2;3;1;4;1] = 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Multiset \coqdocvar{sum} is similar to set \coqdocvar{union}: \coqdocvar{sum} \coqdocvar{a} \coqdocvar{b} contains
    all the elements of \coqdocvar{a} and of \coqdocvar{b}.  (Mathematicians usually
    define \coqdocvar{union} on multisets a little bit differently, which
    is why we don't use that name for this operation.)
    For \coqdocvar{sum} we're giving you a header that does not give explicit
    names to the arguments.  Moreover, it uses the keyword
    \coqdockw{Definition} instead of \coqdockw{Fixpoint}, so even if you had names for
    the arguments, you wouldn't be able to process them recursively.
    The point of stating the question this way is to encourage you to
    think about whether \coqdocvar{sum} can be implemented in another way --
    perhaps by using functions that have already been defined.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{sum} : \coqdocvar{bag} \ensuremath{\rightarrow} \coqdocvar{bag} \ensuremath{\rightarrow} \coqdocvar{bag} := \coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_sum1}:              \coqdocvar{count} 1 (\coqdocvar{sum} [1;2;3] [1;4;1]) = 3.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{add} (\coqdocvar{v}:\coqdocvar{nat}) (\coqdocvar{s}:\coqdocvar{bag}) : \coqdocvar{bag} := \coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_add1}:                \coqdocvar{count} 1 (\coqdocvar{add} 1 [1;4;1]) = 3.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_add2}:                \coqdocvar{count} 5 (\coqdocvar{add} 1 [1;4;1]) = 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{member} (\coqdocvar{v}:\coqdocvar{nat}) (\coqdocvar{s}:\coqdocvar{bag}) : \coqdocvar{bool} := \coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_member1}:             \coqdocvar{member} 1 [1;4;1] = \coqdocvar{true}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_member2}:             \coqdocvar{member} 2 [1;4;1] = \coqdocvar{false}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, optional (bag\_more\_functions)}

 Here are some more bag functions for you to practice with. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{remove\_one} (\coqdocvar{v}:\coqdocvar{nat}) (\coqdocvar{s}:\coqdocvar{bag}) : \coqdocvar{bag} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_remove\_one1}:         \coqdocvar{count} 5 (\coqdocvar{remove\_one} 5 [2;1;5;4;1]) = 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_remove\_one2}:         \coqdocvar{count} 5 (\coqdocvar{remove\_one} 5 [2;1;4;1]) = 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_remove\_one3}:         \coqdocvar{count} 4 (\coqdocvar{remove\_one} 5 [2;1;4;5;1;4]) = 2.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_remove\_one4}:         \coqdocvar{count} 5 (\coqdocvar{remove\_one} 5 [2;1;5;4;5;1;4]) = 1.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{remove\_all} (\coqdocvar{v}:\coqdocvar{nat}) (\coqdocvar{s}:\coqdocvar{bag}) : \coqdocvar{bag} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_remove\_all1}:          \coqdocvar{count} 5 (\coqdocvar{remove\_all} 5 [2;1;5;4;1]) = 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_remove\_all2}:          \coqdocvar{count} 5 (\coqdocvar{remove\_all} 5 [2;1;4;1]) = 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_remove\_all3}:          \coqdocvar{count} 4 (\coqdocvar{remove\_all} 5 [2;1;4;5;1;4]) = 2.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_remove\_all4}:          \coqdocvar{count} 5 (\coqdocvar{remove\_all} 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{subset} (\coqdocvar{s1}:\coqdocvar{bag}) (\coqdocvar{s2}:\coqdocvar{bag}) : \coqdocvar{bool} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_subset1}:              \coqdocvar{subset} [1;2] [2;1;4;1] = \coqdocvar{true}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_subset2}:              \coqdocvar{subset} [1;2;2] [2;1;4;1] = \coqdocvar{false}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars (bag\_theorem)}

 Write down an interesting theorem \coqdocvar{bag\_theorem} about bags involving
    the functions \coqdocvar{count} and \coqdocvar{add}, and prove it.  Note that, since this
    problem is somewhat open-ended, it's possible that you may come up
    with a theorem which is true, but whose proof requires techniques
    you haven't learned yet.  Feel free to ask for help if you get
    stuck! \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Reasoning About Lists}



 Just as with numbers, simple facts about list-processing
    functions can sometimes be proved entirely by simplification. For
    example, the simplification performed by \coqdoctac{reflexivity} is enough
    for this theorem... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{nil\_app} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l}:\coqdocvar{natlist},\coqdoceol
\coqdocindent{1.00em}
[] ++ \coqdocvar{l} = \coqdocvar{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
... because the [] is substituted into the match position
    in the definition of \coqdocvar{app}, allowing the match itself to be
    simplified. 

 Also, as with numbers, it is sometimes helpful to perform case
    analysis on the possible shapes (empty or non-empty) of an unknown
    list. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{tl\_length\_pred} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l}:\coqdocvar{natlist},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{pred} (\coqdocvar{length} \coqdocvar{l}) = \coqdocvar{length} (\coqdocvar{tl} \coqdocvar{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l}. \coqdoctac{destruct} \coqdocvar{l} \coqdockw{as} [| \coqdocvar{n} \coqdocvar{l'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "l = nil".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "l = cons n l'".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here, the \coqdocvar{nil} case works because we've chosen to define
    \coqdocvar{tl} \coqdocvar{nil} = \coqdocvar{nil}. Notice that the \coqdockw{as} annotation on the \coqdoctac{destruct}
    tactic here introduces two names, \coqdocvar{n} and \coqdocvar{l'}, corresponding to
    the fact that the \coqdocvar{cons} constructor for lists takes two
    arguments (the head and tail of the list it is constructing). 

 Usually, though, interesting theorems about lists require
    induction for their proofs. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Micro-Sermon}



 Simply reading example proof scripts will not get you very far!
    It is very important to work through the details of each one,
    using Coq and thinking about what each step achieves.  Otherwise
    it is more or less guaranteed that the exercises will make no
    sense... \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Induction on Lists}



 Proofs by induction over datatypes like \coqdocvar{natlist} are
    perhaps a little less familiar than standard natural number
    induction, but the basic idea is equally simple.  Each \coqdockw{Inductive}
    declaration defines a set of data values that can be built up from
    the declared constructors: a boolean can be either \coqdocvar{true} or
    \coqdocvar{false}; a number can be either \coqdocvar{O} or \coqdocvar{S} applied to a number; a
    list can be either \coqdocvar{nil} or \coqdocvar{cons} applied to a number and a list.


    Moreover, applications of the declared constructors to one another
    are the \textit{only} possible shapes that elements of an inductively
    defined set can have, and this fact directly gives rise to a way
    of reasoning about inductively defined sets: a number is either
    \coqdocvar{O} or else it is \coqdocvar{S} applied to some \textit{smaller} number; a list is
    either \coqdocvar{nil} or else it is \coqdocvar{cons} applied to some number and some
    \textit{smaller} list; etc. So, if we have in mind some proposition \coqdocvar{P}
    that mentions a list \coqdocvar{l} and we want to argue that \coqdocvar{P} holds for
    \textit{all} lists, we can reason as follows:



\begin{itemize}
\item  First, show that \coqdocvar{P} is true of \coqdocvar{l} when \coqdocvar{l} is \coqdocvar{nil}.



\item  Then show that \coqdocvar{P} is true of \coqdocvar{l} when \coqdocvar{l} is \coqdocvar{cons} \coqdocvar{n} \coqdocvar{l'} for
        some number \coqdocvar{n} and some smaller list \coqdocvar{l'}, assuming that \coqdocvar{P}
        is true for \coqdocvar{l'}.

\end{itemize}


    Since larger lists can only be built up from smaller ones,
    eventually reaching \coqdocvar{nil}, these two things together establish the
    truth of \coqdocvar{P} for all lists \coqdocvar{l}.  Here's a concrete example: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{app\_assoc} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2} \coqdocvar{l3} : \coqdocvar{natlist}, \coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{l1} ++ \coqdocvar{l2}) ++ \coqdocvar{l3} = \coqdocvar{l1} ++ (\coqdocvar{l2} ++ \coqdocvar{l3}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l1} \coqdocvar{l2} \coqdocvar{l3}. \coqdoctac{induction} \coqdocvar{l1} \coqdockw{as} [| \coqdocvar{n} \coqdocvar{l1'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "l1 = nil".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "l1 = cons n l1'".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHl1'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Again, this Coq proof is not especially illuminating as a
    static written document -- it is easy to see what's going on if
    you are reading the proof in an interactive Coq session and you
    can see the current goal and context at each point, but this state
    is not visible in the written-down parts of the Coq proof.  So a
    natural-language proof -- one written for human readers -- will
    need to include more explicit signposts; in particular, it will
    help the reader stay oriented if we remind them exactly what the
    induction hypothesis is in the second case.  

\subsubsection{Informal version}



 \textit{Theorem}: For all lists \coqdocvar{l1}, \coqdocvar{l2}, and \coqdocvar{l3}, 
   (\coqdocvar{l1} ++ \coqdocvar{l2}) ++ \coqdocvar{l3} = \coqdocvar{l1} ++ (\coqdocvar{l2} ++ \coqdocvar{l3}).


   \textit{Proof}: By induction on \coqdocvar{l1}.



\begin{itemize}
\item  First, suppose \coqdocvar{l1} = [].  We must show
       (\ensuremath{\Box} ++ l2) ++ l3 = \ensuremath{\Box} ++ (l2 ++ l3),
     which follows directly from the definition of ++.



\item  Next, suppose \coqdocvar{l1} = \coqdocvar{n}::\coqdocvar{l1'}, with
       (l1' ++ l2) ++ l3 = l1' ++ (l2 ++ l3)
     (the induction hypothesis). We must show
       ((n :: l1') ++ l2) ++ l3 = (n :: l1') ++ (l2 ++ l3).

\end{itemize}
]]  
     By the definition of ++, this follows from
       n :: ((l1' ++ l2) ++ l3) = n :: (l1' ++ (l2 ++ l3)),
     which is immediate from the induction hypothesis.  \ensuremath{\Box}


\subsubsection{Another example}



  Here is a similar example to be worked together in class: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{app\_length} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2} : \coqdocvar{natlist}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{length} (\coqdocvar{l1} ++ \coqdocvar{l2}) = (\coqdocvar{length} \coqdocvar{l1}) + (\coqdocvar{length} \coqdocvar{l2}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l1} \coqdocvar{l2}. \coqdoctac{induction} \coqdocvar{l1} \coqdockw{as} [| \coqdocvar{n} \coqdocvar{l1'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "l1 = nil".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "l1 = cons".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHl1'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Reversing a list}

 For a slightly more involved example of an inductive proof
    over lists, suppose we define a ``cons on the right'' function
    \coqdocvar{snoc} like this... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{snoc} (\coqdocvar{l}:\coqdocvar{natlist}) (\coqdocvar{v}:\coqdocvar{nat}) : \coqdocvar{natlist} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil}    \ensuremath{\Rightarrow} [\coqdocvar{v}]\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} :: \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{h} :: (\coqdocvar{snoc} \coqdocvar{t} \coqdocvar{v})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
... and use it to define a list-reversing function \coqdocvar{rev}
    like this: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{rev} (\coqdocvar{l}:\coqdocvar{natlist}) : \coqdocvar{natlist} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil}    \ensuremath{\Rightarrow} \coqdocvar{nil}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} :: \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{snoc} (\coqdocvar{rev} \coqdocvar{t}) \coqdocvar{h}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_rev1}:            \coqdocvar{rev} [1;2;3] = [3;2;1].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_rev2}:            \coqdocvar{rev} \coqdocvar{nil} = \coqdocvar{nil}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Proofs about reverse}

 Now let's prove some more list theorems using our newly
    defined \coqdocvar{snoc} and \coqdocvar{rev}.  For something a little more challenging
    than the inductive proofs we've seen so far, let's prove that
    reversing a list does not change its length.  Our first attempt at
    this proof gets stuck in the successor case... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{rev\_length\_firsttry} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqdocvar{natlist},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{length} (\coqdocvar{rev} \coqdocvar{l}) = \coqdocvar{length} \coqdocvar{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l} \coqdockw{as} [| \coqdocvar{n} \coqdocvar{l'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "l = []".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "l = n :: l'".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{IHl'}.\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
So let's take the equation about \coqdocvar{snoc} that would have
    enabled us to make progress and prove it as a separate lemma. 
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{length\_snoc} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqdocvar{nat}, \coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqdocvar{natlist},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{length} (\coqdocvar{snoc} \coqdocvar{l} \coqdocvar{n}) = \coqdocvar{S} (\coqdocvar{length} \coqdocvar{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l} \coqdockw{as} [| \coqdocvar{n'} \coqdocvar{l'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "l = nil".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "l = cons n' l'".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHl'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
    Note that we make the lemma as \textit{general} as possible: in particular,
    we quantify over \textit{all} \coqdocvar{natlist}s, not just those that result
    from an application of \coqdocvar{rev}. This should seem natural, 
    because the truth of the goal clearly doesn't depend on 
    the list having been reversed.  Moreover, it is much easier
    to prove the more general property. 


 Now we can complete the original proof. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{rev\_length} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqdocvar{natlist},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{length} (\coqdocvar{rev} \coqdocvar{l}) = \coqdocvar{length} \coqdocvar{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l} \coqdockw{as} [| \coqdocvar{n} \coqdocvar{l'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "l = nil".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "l = cons".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{length\_snoc}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHl'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For comparison, here are informal proofs of these two theorems: 


    \textit{Theorem}: For all numbers \coqdocvar{n} and lists \coqdocvar{l},
       \coqdocvar{length} (\coqdocvar{snoc} \coqdocvar{l} \coqdocvar{n}) = \coqdocvar{S} (\coqdocvar{length} \coqdocvar{l}).


    \textit{Proof}: By induction on \coqdocvar{l}.



\begin{itemize}
\item  First, suppose \coqdocvar{l} = [].  We must show
        length (snoc \ensuremath{\Box} n) = S (length \ensuremath{\Box}),
      which follows directly from the definitions of
      \coqdocvar{length} and \coqdocvar{snoc}.



\item  Next, suppose \coqdocvar{l} = \coqdocvar{n'}::\coqdocvar{l'}, with
        length (snoc l' n) = S (length l').
      We must show
        length (snoc (n' :: l') n) = S (length (n' :: l')).
      By the definitions of \coqdocvar{length} and \coqdocvar{snoc}, this
      follows from
        S (length (snoc l' n)) = S (S (length l')),

\end{itemize}
]] 
      which is immediate from the induction hypothesis. \ensuremath{\Box} 

 \textit{Theorem}: For all lists \coqdocvar{l}, \coqdocvar{length} (\coqdocvar{rev} \coqdocvar{l}) = \coqdocvar{length} \coqdocvar{l}.


    \textit{Proof}: By induction on \coqdocvar{l}.  



\begin{itemize}
\item  First, suppose \coqdocvar{l} = [].  We must show
          length (rev \ensuremath{\Box}) = length \ensuremath{\Box},
        which follows directly from the definitions of \coqdocvar{length} 
        and \coqdocvar{rev}.



\item  Next, suppose \coqdocvar{l} = \coqdocvar{n}::\coqdocvar{l'}, with
          length (rev l') = length l'.
        We must show
          length (rev (n :: l')) = length (n :: l').
        By the definition of \coqdocvar{rev}, this follows from
          length (snoc (rev l') n) = S (length l')
        which, by the previous lemma, is the same as
          S (length (rev l')) = S (length l').
        This is immediate from the induction hypothesis. \ensuremath{\Box} 
\end{itemize}


 Obviously, the style of these proofs is rather longwinded
    and pedantic.  After the first few, we might find it easier to
    follow proofs that give fewer details (since we can easily work
    them out in our own minds or on scratch paper if necessary) and
    just highlight the non-obvious steps.  In this more compressed
    style, the above proof might look more like this: 

 \textit{Theorem}:
     For all lists \coqdocvar{l}, \coqdocvar{length} (\coqdocvar{rev} \coqdocvar{l}) = \coqdocvar{length} \coqdocvar{l}.


    \textit{Proof}: First, observe that
       length (snoc l n) = S (length l)
     for any \coqdocvar{l}.  This follows by a straightforward induction on \coqdocvar{l}.
     The main property now follows by another straightforward
     induction on \coqdocvar{l}, using the observation together with the
     induction hypothesis in the case where \coqdocvar{l} = \coqdocvar{n'}::\coqdocvar{l'}. \ensuremath{\Box} 

 Which style is preferable in a given situation depends on
    the sophistication of the expected audience and on how similar the
    proof at hand is to ones that the audience will already be
    familiar with.  The more pedantic style is a good default for
    present purposes. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{\texorpdfstring{\protect\coqdockw{SearchAbout}}{SearchAbout}}



 We've seen that proofs can make use of other theorems we've
    already proved, using \coqdoctac{rewrite}, and later we will see other ways
    of reusing previous theorems.  But in order to refer to a theorem,
    we need to know its name, and remembering the names of all the
    theorems we might ever want to use can become quite difficult!  It
    is often hard even to remember what theorems have been proven,
    much less what they are named.


    Coq's \coqdockw{SearchAbout} command is quite helpful with this.  Typing
    \coqdockw{SearchAbout} \coqdocvar{foo} will cause Coq to display a list of all theorems
    involving \coqdocvar{foo}.  For example, try uncommenting the following to
    see a list of theorems that we have proved about \coqdocvar{rev}: \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Keep \coqdockw{SearchAbout} in mind as you do the following exercises and
    throughout the rest of the course; it can save you a lot of time! 

 Also, if you are using ProofGeneral, you can run \coqdockw{SearchAbout}
    with \coqdocvar{C}-\coqdocvar{c} \coqdocvar{C}-\coqdocvar{a} \coqdocvar{C}-\coqdocvar{a}. Pasting its response into your buffer can be
    accomplished with \coqdocvar{C}-\coqdocvar{c} \coqdocvar{C}-;. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{List Exercises, Part 1}



\paragraph{Exercise: 3 stars (list\_exercises)}

 More practice with lists. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{app\_nil\_end} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqdocvar{natlist}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{l} ++ [] = \coqdocvar{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{rev\_involutive} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqdocvar{natlist},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{rev} (\coqdocvar{rev} \coqdocvar{l}) = \coqdocvar{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
There is a short solution to the next exercise.  If you find
    yourself getting tangled up, step back and try to look for a
    simpler way. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{app\_assoc4} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2} \coqdocvar{l3} \coqdocvar{l4} : \coqdocvar{natlist},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{l1} ++ (\coqdocvar{l2} ++ (\coqdocvar{l3} ++ \coqdocvar{l4})) = ((\coqdocvar{l1} ++ \coqdocvar{l2}) ++ \coqdocvar{l3}) ++ \coqdocvar{l4}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{snoc\_append} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{l}:\coqdocvar{natlist}) (\coqdocvar{n}:\coqdocvar{nat}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{snoc} \coqdocvar{l} \coqdocvar{n} = \coqdocvar{l} ++ [\coqdocvar{n}].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{distr\_rev} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2} : \coqdocvar{natlist},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{rev} (\coqdocvar{l1} ++ \coqdocvar{l2}) = (\coqdocvar{rev} \coqdocvar{l2}) ++ (\coqdocvar{rev} \coqdocvar{l1}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
An exercise about your implementation of \coqdocvar{nonzeros}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{nonzeros\_app} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2} : \coqdocvar{natlist},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{nonzeros} (\coqdocvar{l1} ++ \coqdocvar{l2}) = (\coqdocvar{nonzeros} \coqdocvar{l1}) ++ (\coqdocvar{nonzeros} \coqdocvar{l2}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars (beq\_natlist)}

 Fill in the definition of \coqdocvar{beq\_natlist}, which compares
    lists of numbers for equality.  Prove that \coqdocvar{beq\_natlist} \coqdocvar{l} \coqdocvar{l}
    yields \coqdocvar{true} for every list \coqdocvar{l}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{beq\_natlist} (\coqdocvar{l1} \coqdocvar{l2} : \coqdocvar{natlist}) : \coqdocvar{bool} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_beq\_natlist1} :   (\coqdocvar{beq\_natlist} \coqdocvar{nil} \coqdocvar{nil} = \coqdocvar{true}).\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_beq\_natlist2} :   \coqdocvar{beq\_natlist} [1;2;3] [1;2;3] = \coqdocvar{true}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_beq\_natlist3} :   \coqdocvar{beq\_natlist} [1;2;3] [1;2;4] = \coqdocvar{false}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{beq\_natlist\_refl} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l}:\coqdocvar{natlist},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{true} = \coqdocvar{beq\_natlist} \coqdocvar{l} \coqdocvar{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{List Exercises, Part 2}



\paragraph{Exercise: 2 stars (list\_design)}

 Design exercise: 



\begin{itemize}
\item  Write down a non-trivial theorem \coqdocvar{cons\_snoc\_app}
       involving \coqdocvar{cons} (::), \coqdocvar{snoc}, and \coqdocvar{app} (++).  

\item  Prove it. 
\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, advanced (bag\_proofs)}

 Here are a couple of little theorems to prove about your
    definitions about bags earlier in the file. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{count\_member\_nonzero} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{s} : \coqdocvar{bag}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ble\_nat} 1 (\coqdocvar{count} 1 (1 :: \coqdocvar{s})) = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The following lemma about \coqdocvar{ble\_nat} might help you in the next proof. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{ble\_n\_Sn} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ble\_nat} \coqdocvar{n} (\coqdocvar{S} \coqdocvar{n}) = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "0".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "S n'".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{rewrite} \coqdocvar{IHn'}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{remove\_decreases\_count}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{s} : \coqdocvar{bag}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ble\_nat} (\coqdocvar{count} 0 (\coqdocvar{remove\_one} 0 \coqdocvar{s})) (\coqdocvar{count} 0 \coqdocvar{s}) = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, optional (bag\_count\_sum)}

 Write down an interesting theorem \coqdocvar{bag\_count\_sum} about bags 
    involving the functions \coqdocvar{count} and \coqdocvar{sum}, and prove it.\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 4 stars, advanced (rev\_injective)}

 Prove that the \coqdocvar{rev} function is injective, that is,


    forall (l1 l2 : natlist), rev l1 = rev l2 -> l1 = l2.


There is a hard way and an easy way to solve this exercise.
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Options}



 One use of \coqdocvar{natoption} is as a way of returning ``error
    codes'' from functions.  For example, suppose we want to write a
    function that returns the \coqdocvar{n}th element of some list.  If we give
    it type \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{natlist} \ensuremath{\rightarrow} \coqdocvar{nat}, then we'll have to return some
    number when the list is too short! \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{index\_bad} (\coqdocvar{n}:\coqdocvar{nat}) (\coqdocvar{l}:\coqdocvar{natlist}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil} \ensuremath{\Rightarrow} 42  \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{a} :: \coqdocvar{l'} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvar{beq\_nat} \coqdocvar{n} \coqdocvar{O} \coqdockw{with} \coqdoceol
\coqdocindent{7.50em}
\ensuremath{|} \coqdocvar{true} \ensuremath{\Rightarrow} \coqdocvar{a} \coqdoceol
\coqdocindent{7.50em}
\ensuremath{|} \coqdocvar{false} \ensuremath{\Rightarrow} \coqdocvar{index\_bad} (\coqdocvar{pred} \coqdocvar{n}) \coqdocvar{l'} \coqdoceol
\coqdocindent{7.50em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 On the other hand, if we give it type \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{natlist} \ensuremath{\rightarrow}
    \coqdocvar{natoption}, then we can return \coqdocvar{None} when the list is too short
    and \coqdocvar{Some} \coqdocvar{a} when the list has enough members and \coqdocvar{a} appears at
    position \coqdocvar{n}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{natoption} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{Some} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{natoption}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{None} : \coqdocvar{natoption}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{index} (\coqdocvar{n}:\coqdocvar{nat}) (\coqdocvar{l}:\coqdocvar{natlist}) : \coqdocvar{natoption} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil} \ensuremath{\Rightarrow} \coqdocvar{None} \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{a} :: \coqdocvar{l'} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvar{beq\_nat} \coqdocvar{n} \coqdocvar{O} \coqdockw{with} \coqdoceol
\coqdocindent{7.50em}
\ensuremath{|} \coqdocvar{true} \ensuremath{\Rightarrow} \coqdocvar{Some} \coqdocvar{a}\coqdoceol
\coqdocindent{7.50em}
\ensuremath{|} \coqdocvar{false} \ensuremath{\Rightarrow} \coqdocvar{index} (\coqdocvar{pred} \coqdocvar{n}) \coqdocvar{l'} \coqdoceol
\coqdocindent{7.50em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_index1} :    \coqdocvar{index} 0 [4;5;6;7]  = \coqdocvar{Some} 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_index2} :    \coqdocvar{index} 3 [4;5;6;7]  = \coqdocvar{Some} 7.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_index3} :    \coqdocvar{index} 10 [4;5;6;7] = \coqdocvar{None}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This example is also an opportunity to introduce one more
    small feature of Coq's programming language: conditional
    expressions... 

\subsubsection{ }

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{index'} (\coqdocvar{n}:\coqdocvar{nat}) (\coqdocvar{l}:\coqdocvar{natlist}) : \coqdocvar{natoption} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil} \ensuremath{\Rightarrow} \coqdocvar{None} \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{a} :: \coqdocvar{l'} \ensuremath{\Rightarrow} \coqdockw{if} \coqdocvar{beq\_nat} \coqdocvar{n} \coqdocvar{O} \coqdockw{then} \coqdocvar{Some} \coqdocvar{a} \coqdockw{else} \coqdocvar{index'} (\coqdocvar{pred} \coqdocvar{n}) \coqdocvar{l'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Coq's conditionals are exactly like those found in any other
    language, with one small generalization.  Since the boolean type
    is not built in, Coq actually allows conditional expressions over
    \textit{any} inductively defined type with exactly two constructors.  The
    guard is considered true if it evaluates to the first constructor
    in the \coqdockw{Inductive} definition and false if it evaluates to the
    second. 

 The function below pulls the \coqdocvar{nat} out of a \coqdocvar{natoption}, returning
    a supplied default in the \coqdocvar{None} case. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{option\_elim} (\coqdocvar{d} : \coqdocvar{nat}) (\coqdocvar{o} : \coqdocvar{natoption}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{o} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{Some} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqdocvar{n'}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{None} \ensuremath{\Rightarrow} \coqdocvar{d}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars (hd\_opt)}

 Using the same idea, fix the \coqdocvar{hd} function from earlier so we don't
   have to pass a default element for the \coqdocvar{nil} case.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{hd\_opt} (\coqdocvar{l} : \coqdocvar{natlist}) : \coqdocvar{natoption} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_hd\_opt1} : \coqdocvar{hd\_opt} [] = \coqdocvar{None}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_hd\_opt2} : \coqdocvar{hd\_opt} [1] = \coqdocvar{Some} 1.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_hd\_opt3} : \coqdocvar{hd\_opt} [5;6] = \coqdocvar{Some} 5.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 1 star, optional (option\_elim\_hd)}

 This exercise relates your new \coqdocvar{hd\_opt} to the old \coqdocvar{hd}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{option\_elim\_hd} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{l}:\coqdocvar{natlist}) (\coqdocvar{default}:\coqdocvar{nat}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{hd} \coqdocvar{default} \coqdocvar{l} = \coqdocvar{option\_elim} \coqdocvar{default} (\coqdocvar{hd\_opt} \coqdocvar{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Dictionaries}



 As a final illustration of how fundamental data structures
    can be defined in Coq, here is the declaration of a simple
    \coqdocvar{dictionary} data type, using numbers for both the keys and the
    values stored under these keys.  (That is, a dictionary represents
    a finite map from numbers to numbers.) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdocvar{Dictionary}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{dictionary} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{empty}  : \coqdocvar{dictionary} \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{record} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{dictionary} \ensuremath{\rightarrow} \coqdocvar{dictionary}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This declaration can be read: ``There are two ways to construct a
    \coqdocvar{dictionary}: either using the constructor \coqdocvar{empty} to represent an
    empty dictionary, or by applying the constructor \coqdocvar{record} to
    a key, a value, and an existing \coqdocvar{dictionary} to construct a
    \coqdocvar{dictionary} with an additional key to value mapping.'' \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{insert} (\coqdocvar{key} \coqdocvar{value} : \coqdocvar{nat}) (\coqdocvar{d} : \coqdocvar{dictionary}) : \coqdocvar{dictionary} :=\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{record} \coqdocvar{key} \coqdocvar{value} \coqdocvar{d}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is a function \coqdocvar{find} that searches a \coqdocvar{dictionary} for a
    given key.  It evaluates evaluates to \coqdocvar{None} if the key was not
    found and \coqdocvar{Some} \coqdocvar{val} if the key was mapped to \coqdocvar{val} in the
    dictionary. If the same key is mapped to multiple values, \coqdocvar{find}
    will return the first one it finds. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{find} (\coqdocvar{key} : \coqdocvar{nat}) (\coqdocvar{d} : \coqdocvar{dictionary}) : \coqdocvar{natoption} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{d} \coqdockw{with} \coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{empty}         \ensuremath{\Rightarrow} \coqdocvar{None}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{record} \coqdocvar{k} \coqdocvar{v} \coqdocvar{d'} \ensuremath{\Rightarrow} \coqdockw{if} (\coqdocvar{beq\_nat} \coqdocvar{key} \coqdocvar{k}) \coqdoceol
\coqdocindent{11.50em}
\coqdockw{then} (\coqdocvar{Some} \coqdocvar{v}) \coqdoceol
\coqdocindent{11.50em}
\coqdockw{else} (\coqdocvar{find} \coqdocvar{key} \coqdocvar{d'})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star (dictionary\_invariant1)}

 Complete the following proof. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{dictionary\_invariant1'} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{d} : \coqdocvar{dictionary}) (\coqdocvar{k} \coqdocvar{v}: \coqdocvar{nat}),\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{find} \coqdocvar{k} (\coqdocvar{insert} \coqdocvar{k} \coqdocvar{v} \coqdocvar{d})) = \coqdocvar{Some} \coqdocvar{v}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 1 star (dictionary\_invariant2)}

 Complete the following proof. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{dictionary\_invariant2'} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{d} : \coqdocvar{dictionary}) (\coqdocvar{m} \coqdocvar{n} \coqdocvar{o}: \coqdocvar{nat}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beq\_nat} \coqdocvar{m} \coqdocvar{n} = \coqdocvar{false} \ensuremath{\rightarrow} \coqdocvar{find} \coqdocvar{m} \coqdocvar{d} = \coqdocvar{find} \coqdocvar{m} (\coqdocvar{insert} \coqdocvar{n} \coqdocvar{o} \coqdocvar{d}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqdocvar{Dictionary}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqdocvar{NatList}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
$Date: 2014-12-31 11:17:56 -0500 (Wed, 31 Dec 2014) $ \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{Top.Poly}{Library }{Top.Poly}

\begin{coqdoccode}
\end{coqdoccode}
\section{Poly: Polymorphism and Higher-Order Functions}



 In this chapter we continue our development of basic 
    concepts of functional programming.  The critical new ideas are
    \textit{polymorphism} (abstracting functions over the types of the data
    they manipulate) and \textit{higher-order functions} (treating functions
    as data).
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqdocvar{Lists}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Polymorphism}

\begin{coqdoccode}
\end{coqdoccode}
\subsection{Polymorphic Lists}



 For the last couple of chapters, we've been working just
    with lists of numbers.  Obviously, interesting programs also need
    to be able to manipulate lists with elements from other types --
    lists of strings, lists of booleans, lists of lists, etc.  We
    \textit{could} just define a new inductive datatype for each of these,
    for example... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{boollist} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{bool\_nil} : \coqdocvar{boollist}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{bool\_cons} : \coqdocvar{bool} \ensuremath{\rightarrow} \coqdocvar{boollist} \ensuremath{\rightarrow} \coqdocvar{boollist}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
... but this would quickly become tedious, partly because we
    have to make up different constructor names for each datatype, but
    mostly because we would also need to define new versions of all
    our list manipulating functions (\coqdocvar{length}, \coqdocvar{rev}, etc.)  for each
    new datatype definition. 

\subsubsection{ }



 To avoid all this repetition, Coq supports \textit{polymorphic}
    inductive type definitions.  For example, here is a \textit{polymorphic
    list} datatype. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{list} (\coqdocvar{X}:\coqdockw{Type}) : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil} : \coqdocvar{list} \coqdocvar{X}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{cons} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{list} \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{list} \coqdocvar{X}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is exactly like the definition of \coqdocvar{natlist} from the
    previous chapter, except that the \coqdocvar{nat} argument to the \coqdocvar{cons}
    constructor has been replaced by an arbitrary type \coqdocvar{X}, a binding
    for \coqdocvar{X} has been added to the header, and the occurrences of
    \coqdocvar{natlist} in the types of the constructors have been replaced by
    \coqdocvar{list} \coqdocvar{X}.  (We can re-use the constructor names \coqdocvar{nil} and \coqdocvar{cons}
    because the earlier definition of \coqdocvar{natlist} was inside of a
    \coqdockw{Module} definition that is now out of scope.) 

 What sort of thing is \coqdocvar{list} itself?  One good way to think
    about it is that \coqdocvar{list} is a \textit{function} from \coqdockw{Type}s to
    \coqdockw{Inductive} definitions; or, to put it another way, \coqdocvar{list} is a
    function from \coqdockw{Type}s to \coqdockw{Type}s.  For any particular type \coqdocvar{X},
    the type \coqdocvar{list} \coqdocvar{X} is an \coqdockw{Inductive}ly defined set of lists whose
    elements are things of type \coqdocvar{X}. 

 With this definition, when we use the constructors \coqdocvar{nil} and
    \coqdocvar{cons} to build lists, we need to tell Coq the type of the
    elements in the lists we are building -- that is, \coqdocvar{nil} and \coqdocvar{cons}
    are now \textit{polymorphic constructors}.  Observe the types of these
    constructors: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{nil}.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqdocvar{cons}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The ``\coqdockw{\ensuremath{\forall}} \coqdocvar{X}'' in these types can be read as an additional
    argument to the constructors that determines the expected types of
    the arguments that follow.  When \coqdocvar{nil} and \coqdocvar{cons} are used, these
    arguments are supplied in the same way as the others.  For
    example, the list containing 2 and 1 is written like this: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqdocvar{cons} \coqdocvar{nat} 2 (\coqdocvar{cons} \coqdocvar{nat} 1 (\coqdocvar{nil} \coqdocvar{nat}))).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
(We've gone back to writing \coqdocvar{nil} and \coqdocvar{cons} explicitly here
    because we haven't yet defined the  []  and :: notations for
    the new version of lists.  We'll do that in a bit.) 

 We can now go back and make polymorphic (or ``generic'')
    versions of all the list-processing functions that we wrote
    before.  Here is \coqdocvar{length}, for example: 

\subsubsection{ }

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{length} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{l}:\coqdocvar{list} \coqdocvar{X}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil}      \ensuremath{\Rightarrow} 0\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{cons} \coqdocvar{h} \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{S} (\coqdocvar{length} \coqdocvar{X} \coqdocvar{t})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Note that the uses of \coqdocvar{nil} and \coqdocvar{cons} in \coqdockw{match} patterns
    do not require any type annotations: Coq already knows that the list
    \coqdocvar{l} contains elements of type \coqdocvar{X}, so there's no reason to include
    \coqdocvar{X} in the pattern.  (More precisely, the type \coqdocvar{X} is a parameter
    of the whole definition of \coqdocvar{list}, not of the individual
    constructors.  We'll come back to this point later.)


    As with \coqdocvar{nil} and \coqdocvar{cons}, we can use \coqdocvar{length} by applying it first
    to a type and then to its list argument: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_length1} :\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{length} \coqdocvar{nat} (\coqdocvar{cons} \coqdocvar{nat} 1 (\coqdocvar{cons} \coqdocvar{nat} 2 (\coqdocvar{nil} \coqdocvar{nat}))) = 2.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
To use our length with other kinds of lists, we simply
    instantiate it with an appropriate type parameter: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_length2} :\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{length} \coqdocvar{bool} (\coqdocvar{cons} \coqdocvar{bool} \coqdocvar{true} (\coqdocvar{nil} \coqdocvar{bool})) = 1.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 Let's close this subsection by re-implementing a few other
    standard list functions on our new polymorphic lists: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{app} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{l1} \coqdocvar{l2} : \coqdocvar{list} \coqdocvar{X})\coqdoceol
\coqdocindent{8.00em}
: (\coqdocvar{list} \coqdocvar{X}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l1} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil}      \ensuremath{\Rightarrow} \coqdocvar{l2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{cons} \coqdocvar{h} \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{cons} \coqdocvar{X} \coqdocvar{h} (\coqdocvar{app} \coqdocvar{X} \coqdocvar{t} \coqdocvar{l2})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{snoc} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{l}:\coqdocvar{list} \coqdocvar{X}) (\coqdocvar{v}:\coqdocvar{X}) : (\coqdocvar{list} \coqdocvar{X}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil}      \ensuremath{\Rightarrow} \coqdocvar{cons} \coqdocvar{X} \coqdocvar{v} (\coqdocvar{nil} \coqdocvar{X})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{cons} \coqdocvar{h} \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{cons} \coqdocvar{X} \coqdocvar{h} (\coqdocvar{snoc} \coqdocvar{X} \coqdocvar{t} \coqdocvar{v})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{rev} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{l}:\coqdocvar{list} \coqdocvar{X}) : \coqdocvar{list} \coqdocvar{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil}      \ensuremath{\Rightarrow} \coqdocvar{nil} \coqdocvar{X}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{cons} \coqdocvar{h} \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{snoc} \coqdocvar{X} (\coqdocvar{rev} \coqdocvar{X} \coqdocvar{t}) \coqdocvar{h}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_rev1} :\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{rev} \coqdocvar{nat} (\coqdocvar{cons} \coqdocvar{nat} 1 (\coqdocvar{cons} \coqdocvar{nat} 2 (\coqdocvar{nil} \coqdocvar{nat})))\coqdoceol
\coqdocindent{1.00em}
= (\coqdocvar{cons} \coqdocvar{nat} 2 (\coqdocvar{cons} \coqdocvar{nat} 1 (\coqdocvar{nil} \coqdocvar{nat}))).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_rev2}:\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{rev} \coqdocvar{bool} (\coqdocvar{nil} \coqdocvar{bool}) = \coqdocvar{nil} \coqdocvar{bool}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdocvar{MumbleBaz}.\coqdoceol
\end{coqdoccode}
\paragraph{Exercise: 2 stars (mumble\_grumble)}

 Consider the following two inductively defined types. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{mumble} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{a} : \coqdocvar{mumble}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{b} : \coqdocvar{mumble} \ensuremath{\rightarrow} \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{mumble}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{c} : \coqdocvar{mumble}.\coqdoceol
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{grumble} (\coqdocvar{X}:\coqdockw{Type}) : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{d} : \coqdocvar{mumble} \ensuremath{\rightarrow} \coqdocvar{grumble} \coqdocvar{X}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{e} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{grumble} \coqdocvar{X}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Which of the following are well-typed elements of \coqdocvar{grumble} \coqdocvar{X} for
    some type \coqdocvar{X}?



\begin{itemize}
\item  \coqdocvar{d} (\coqdocvar{b} \coqdocvar{a} 5)

\item  \coqdocvar{d} \coqdocvar{mumble} (\coqdocvar{b} \coqdocvar{a} 5)

\item  \coqdocvar{d} \coqdocvar{bool} (\coqdocvar{b} \coqdocvar{a} 5)

\item  \coqdocvar{e} \coqdocvar{bool} \coqdocvar{true}

\item  \coqdocvar{e} \coqdocvar{mumble} (\coqdocvar{b} \coqdocvar{c} 0)

\item  \coqdocvar{e} \coqdocvar{bool} (\coqdocvar{b} \coqdocvar{c} 0)

\item  \coqdocvar{c} 

\end{itemize}
 \ensuremath{\Box} 

\paragraph{Exercise: 2 stars (baz\_num\_elts)}

 Consider the following inductive definition: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{baz} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.50em}
\ensuremath{|} \coqdocvar{x} : \coqdocvar{baz} \ensuremath{\rightarrow} \coqdocvar{baz}\coqdoceol
\coqdocindent{1.50em}
\ensuremath{|} \coqdocvar{y} : \coqdocvar{baz} \ensuremath{\rightarrow} \coqdocvar{bool} \ensuremath{\rightarrow} \coqdocvar{baz}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
How \textit{many} elements does the type \coqdocvar{baz} have? 
 \ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqdocvar{MumbleBaz}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Type Annotation Inference}



 Let's write the definition of \coqdocvar{app} again, but this time we won't
    specify the types of any of the arguments. Will Coq still accept
    it? \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{app'} \coqdocvar{X} \coqdocvar{l1} \coqdocvar{l2} : \coqdocvar{list} \coqdocvar{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l1} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil}      \ensuremath{\Rightarrow} \coqdocvar{l2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{cons} \coqdocvar{h} \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{cons} \coqdocvar{X} \coqdocvar{h} (\coqdocvar{app'} \coqdocvar{X} \coqdocvar{t} \coqdocvar{l2})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Indeed it will.  Let's see what type Coq has assigned to \coqdocvar{app'}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{app'}.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqdocvar{app}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
It has exactly the same type type as \coqdocvar{app}.  Coq was able to
    use a process called \textit{type inference} to deduce what the types of
    \coqdocvar{X}, \coqdocvar{l1}, and \coqdocvar{l2} must be, based on how they are used.  For
    example, since \coqdocvar{X} is used as an argument to \coqdocvar{cons}, it must be a
    \coqdockw{Type}, since \coqdocvar{cons} expects a \coqdockw{Type} as its first argument;
    matching \coqdocvar{l1} with \coqdocvar{nil} and \coqdocvar{cons} means it must be a \coqdocvar{list}; and
    so on.


    This powerful facility means we don't always have to write
    explicit type annotations everywhere, although explicit type
    annotations are still quite useful as documentation and sanity
    checks.  You should try to find a balance in your own code between
    too many type annotations (so many that they clutter and distract)
    and too few (which forces readers to perform type inference in
    their heads in order to understand your code). \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Type Argument Synthesis}



 Whenever we use a polymorphic function, we need to pass it
    one or more types in addition to its other arguments.  For
    example, the recursive call in the body of the \coqdocvar{length} function
    above must pass along the type \coqdocvar{X}.  But just like providing
    explicit type annotations everywhere, this is heavy and verbose.
    Since the second argument to \coqdocvar{length} is a list of \coqdocvar{X}s, it seems
    entirely obvious that the first argument can only be \coqdocvar{X} -- why
    should we have to write it explicitly?


    Fortunately, Coq permits us to avoid this kind of redundancy.  In
    place of any type argument we can write the ``implicit argument''
    \coqdocvar{\_}, which can be read as ``Please figure out for yourself what
    type belongs here.''  More precisely, when Coq encounters a \coqdocvar{\_}, it
    will attempt to \textit{unify} all locally available information -- the
    type of the function being applied, the types of the other
    arguments, and the type expected by the context in which the
    application appears -- to determine what concrete type should
    replace the \coqdocvar{\_}.


    This may sound similar to type annotation inference -- and,
    indeed, the two procedures rely on the same underlying mechanisms.
    Instead of simply omitting the types of some arguments to a
    function, like
      app' X l1 l2 : list X :=
    we can also replace the types with \coqdocvar{\_}, like
      app' (X : \_) (l1 l2 : \_) : list X :=
    which tells Coq to attempt to infer the missing information, just
    as with argument synthesis.


    Using implicit arguments, the \coqdocvar{length} function can be written
    like this: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{length'} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{l}:\coqdocvar{list} \coqdocvar{X}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil}      \ensuremath{\Rightarrow} 0\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{cons} \coqdocvar{h} \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{S} (\coqdocvar{length'} \coqdocvar{\_} \coqdocvar{t})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In this instance, we don't save much by writing \coqdocvar{\_} instead of
    \coqdocvar{X}.  But in many cases the difference can be significant.  For
    example, suppose we want to write down a list containing the
    numbers 1, 2, and 3.  Instead of writing this... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{list123} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{cons} \coqdocvar{nat} 1 (\coqdocvar{cons} \coqdocvar{nat} 2 (\coqdocvar{cons} \coqdocvar{nat} 3 (\coqdocvar{nil} \coqdocvar{nat}))).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
...we can use argument synthesis to write this: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{list123'} := \coqdocvar{cons} \coqdocvar{\_} 1 (\coqdocvar{cons} \coqdocvar{\_} 2 (\coqdocvar{cons} \coqdocvar{\_} 3 (\coqdocvar{nil} \coqdocvar{\_}))).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Implicit Arguments}



 In fact, we can go further.  To avoid having to sprinkle \coqdocvar{\_}'s
    throughout our programs, we can tell Coq \textit{always} to infer the
    type argument(s) of a given function. The \coqdocvar{Arguments} directive
    specifies the name of the function or constructor, and then lists
    its argument names, with curly braces around any arguments to be
    treated as implicit. 
    \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Arguments} \coqdocvar{nil} \{\coqdocvar{X}\}.\coqdoceol
\coqdocnoindent
\coqdocvar{Arguments} \coqdocvar{cons} \{\coqdocvar{X}\} \coqdocvar{\_} \coqdocvar{\_}. \coqdocnoindent
\coqdocvar{Arguments} \coqdocvar{length} \{\coqdocvar{X}\} \coqdocvar{l}.\coqdoceol
\coqdocnoindent
\coqdocvar{Arguments} \coqdocvar{app} \{\coqdocvar{X}\} \coqdocvar{l1} \coqdocvar{l2}.\coqdoceol
\coqdocnoindent
\coqdocvar{Arguments} \coqdocvar{rev} \{\coqdocvar{X}\} \coqdocvar{l}.\coqdoceol
\coqdocnoindent
\coqdocvar{Arguments} \coqdocvar{snoc} \{\coqdocvar{X}\} \coqdocvar{l} \coqdocvar{v}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{list123'{}'} := \coqdocvar{cons} 1 (\coqdocvar{cons} 2 (\coqdocvar{cons} 3 \coqdocvar{nil})).\coqdoceol
\coqdocnoindent
\coqdockw{Check} (\coqdocvar{length} \coqdocvar{list123'{}'}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }



 Alternatively, we can declare an argument to be implicit while
    defining the function itself, by surrounding the argument in curly
    braces.  For example: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{length'{}'} \{\coqdocvar{X}:\coqdockw{Type}\} (\coqdocvar{l}:\coqdocvar{list} \coqdocvar{X}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil}      \ensuremath{\Rightarrow} 0\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{cons} \coqdocvar{h} \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{S} (\coqdocvar{length'{}'} \coqdocvar{t})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
(Note that we didn't even have to provide a type argument to
    the recursive call to \coqdocvar{length'{}'}; indeed, it is invalid to provide
    one.)  We will use this style whenever possible, although we will
    continue to use use explicit \coqdocvar{Argument} declarations for
    \coqdockw{Inductive} constructors. 

\subsubsection{ }



 One small problem with declaring arguments \coqdockw{Implicit} is
    that, occasionally, Coq does not have enough local information to
    determine a type argument; in such cases, we need to tell Coq that
    we want to give the argument explicitly this time, even though
    we've globally declared it to be \coqdockw{Implicit}.  For example, suppose we
    write this: \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
If we uncomment this definition, Coq will give us an error,
    because it doesn't know what type argument to supply to \coqdocvar{nil}.  We
    can help it by providing an explicit type declaration (so that Coq
    has more information available when it gets to the ``application''
    of \coqdocvar{nil}): \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{mynil} : \coqdocvar{list} \coqdocvar{nat} := \coqdocvar{nil}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Alternatively, we can force the implicit arguments to be explicit by
   prefixing the function name with @. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} @\coqdocvar{nil}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{mynil'} := @\coqdocvar{nil} \coqdocvar{nat}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 Using argument synthesis and implicit arguments, we can
    define convenient notation for lists, as before.  Since we have
    made the constructor type arguments implicit, Coq will know to
    automatically infer these when we use the notations. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "x :: y" := (\coqdocvar{cons} \coqdocvar{x} \coqdocvar{y})\coqdoceol
\coqdocindent{10.50em}
(\coqdoctac{at} \coqdockw{level} 60, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} "[ ]" := \coqdocvar{nil}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} "[ x ; .. ; y ]" := (\coqdocvar{cons} \coqdocvar{x} .. (\coqdocvar{cons} \coqdocvar{y} []) ..).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} "x ++ y" := (\coqdocvar{app} \coqdocvar{x} \coqdocvar{y})\coqdoceol
\coqdocindent{10.50em}
(\coqdoctac{at} \coqdockw{level} 60, \coqdoctac{right} \coqdockw{associativity}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now lists can be written just the way we'd hope: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{list123'{}'{}'} := [1; 2; 3].\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Exercises: Polymorphic Lists}



\paragraph{Exercise: 2 stars, optional (poly\_exercises)}

 Here are a few simple exercises, just like ones in the \coqdocvar{Lists}
    chapter, for practice with polymorphism.  Fill in the definitions
    and complete the proofs below. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdoctac{repeat} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{n} : \coqdocvar{X}) (\coqdocvar{count} : \coqdocvar{nat}) : \coqdocvar{list} \coqdocvar{X} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_repeat1}:\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdocvar{true} 2 = \coqdocvar{cons} \coqdocvar{true} (\coqdocvar{cons} \coqdocvar{true} \coqdocvar{nil}).\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{nil\_app} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X}:\coqdockw{Type}, \coqdockw{\ensuremath{\forall}} \coqdocvar{l}:\coqdocvar{list} \coqdocvar{X},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{app} [] \coqdocvar{l} = \coqdocvar{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{rev\_snoc} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type},\coqdoceol
\coqdocindent{10.50em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{v} : \coqdocvar{X},\coqdoceol
\coqdocindent{10.50em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{s} : \coqdocvar{list} \coqdocvar{X},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{rev} (\coqdocvar{snoc} \coqdocvar{s} \coqdocvar{v}) = \coqdocvar{v} :: (\coqdocvar{rev} \coqdocvar{s}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{rev\_involutive} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type}, \coqdockw{\ensuremath{\forall}} \coqdocvar{l} : \coqdocvar{list} \coqdocvar{X},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{rev} (\coqdocvar{rev} \coqdocvar{l}) = \coqdocvar{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{snoc\_with\_append} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type},\coqdoceol
\coqdocindent{12.50em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{l1} \coqdocvar{l2} : \coqdocvar{list} \coqdocvar{X},\coqdoceol
\coqdocindent{12.50em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{v} : \coqdocvar{X},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{snoc} (\coqdocvar{l1} ++ \coqdocvar{l2}) \coqdocvar{v} = \coqdocvar{l1} ++ (\coqdocvar{snoc} \coqdocvar{l2} \coqdocvar{v}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Polymorphic Pairs}



 Following the same pattern, the type definition we gave in
    the last chapter for pairs of numbers can be generalized to
    \textit{polymorphic pairs} (or \textit{products}): \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{prod} (\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}) : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{pair} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{Y} \ensuremath{\rightarrow} \coqdocvar{prod} \coqdocvar{X} \coqdocvar{Y}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Arguments} \coqdocvar{pair} \{\coqdocvar{X}\} \{\coqdocvar{Y}\} \coqdocvar{\_} \coqdocvar{\_}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
As with lists, we make the type arguments implicit and define the
    familiar concrete notation. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "( x , y )" := (\coqdocvar{pair} \coqdocvar{x} \coqdocvar{y}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can also use the \coqdockw{Notation} mechanism to define the standard
    notation for pair \textit{types}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "X * Y" := (\coqdocvar{prod} \coqdocvar{X} \coqdocvar{Y}) : \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
(The annotation : \coqdocvar{type\_scope} tells Coq that this abbreviation
    should be used when parsing types.  This avoids a clash with the
    multiplication symbol.) 

\subsubsection{ }

 A note of caution: it is easy at first to get (\coqdocvar{x},\coqdocvar{y}) and
    \coqdocvar{X}\ensuremath{\times}\coqdocvar{Y} confused.  Remember that (\coqdocvar{x},\coqdocvar{y}) is a \textit{value} built from two
    other values; \coqdocvar{X}\ensuremath{\times}\coqdocvar{Y} is a \textit{type} built from two other types.  If
    \coqdocvar{x} has type \coqdocvar{X} and \coqdocvar{y} has type \coqdocvar{Y}, then (\coqdocvar{x},\coqdocvar{y}) has type
    \coqdocvar{X}\ensuremath{\times}\coqdocvar{Y}. 

 The first and second projection functions now look pretty
    much as they would in any functional programming language. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{fst} \{\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}\} (\coqdocvar{p} : \coqdocvar{X} \ensuremath{\times} \coqdocvar{Y}) : \coqdocvar{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{p} \coqdockw{with} (\coqdocvar{x},\coqdocvar{y}) \ensuremath{\Rightarrow} \coqdocvar{x} \coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{snd} \{\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}\} (\coqdocvar{p} : \coqdocvar{X} \ensuremath{\times} \coqdocvar{Y}) : \coqdocvar{Y} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{p} \coqdockw{with} (\coqdocvar{x},\coqdocvar{y}) \ensuremath{\Rightarrow} \coqdocvar{y} \coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The following function takes two lists and combines them
    into a list of pairs.  In many functional programming languages,
    it is called \coqdocvar{zip}.  We call it \coqdocvar{combine} for consistency with
    Coq's standard library.  Note that the pair notation can be used both in expressions and in
    patterns... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{combine} \{\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}\} (\coqdocvar{lx} : \coqdocvar{list} \coqdocvar{X}) (\coqdocvar{ly} : \coqdocvar{list} \coqdocvar{Y})\coqdoceol
\coqdocindent{5.50em}
: \coqdocvar{list} (\coqdocvar{X}\ensuremath{\times}\coqdocvar{Y}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} (\coqdocvar{lx},\coqdocvar{ly}) \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} ([],\coqdocvar{\_}) \ensuremath{\Rightarrow} []\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} (\coqdocvar{\_},[]) \ensuremath{\Rightarrow} []\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} (\coqdocvar{x}::\coqdocvar{tx}, \coqdocvar{y}::\coqdocvar{ty}) \ensuremath{\Rightarrow} (\coqdocvar{x},\coqdocvar{y}) :: (\coqdocvar{combine} \coqdocvar{tx} \coqdocvar{ty})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star, optional (combine\_checks)}

 Try answering the following questions on paper and
    checking your answers in coq:



\begin{itemize}
\item  What is the type of \coqdocvar{combine} (i.e., what does \coqdockw{Check}
      @\coqdocvar{combine} print?)

\item  What does
        Eval compute in (combine 1;2 \coqdocvar{false};\coqdocvar{false};\coqdocvar{true};\coqdocvar{true}).
      print?   \ensuremath{\Box}

\end{itemize}


\paragraph{Exercise: 2 stars (split)}

 The function \coqdoctac{split} is the right inverse of combine: it takes a
    list of pairs and returns a pair of lists.  In many functional
    programing languages, this function is called \coqdocvar{unzip}.


    Uncomment the material below and fill in the definition of
    \coqdoctac{split}.  Make sure it passes the given unit tests. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdoctac{split}\coqdoceol
\coqdocindent{5.50em}
\{\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}\} (\coqdocvar{l} : \coqdocvar{list} (\coqdocvar{X}\ensuremath{\times}\coqdocvar{Y}))\coqdoceol
\coqdocindent{5.50em}
: (\coqdocvar{list} \coqdocvar{X}) \ensuremath{\times} (\coqdocvar{list} \coqdocvar{Y}) :=\coqdoceol
\coqdocnoindent
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_split}:\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split} [(1,\coqdocvar{false});(2,\coqdocvar{false})] = ([1;2],[\coqdocvar{false};\coqdocvar{false}]).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Polymorphic Options}



 One last polymorphic type for now: \textit{polymorphic options}.
    The type declaration generalizes the one for \coqdocvar{natoption} in the
    previous chapter: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{option} (\coqdocvar{X}:\coqdockw{Type}) : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{Some} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{option} \coqdocvar{X}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{None} : \coqdocvar{option} \coqdocvar{X}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Arguments} \coqdocvar{Some} \{\coqdocvar{X}\} \coqdocvar{\_}.\coqdoceol
\coqdocnoindent
\coqdocvar{Arguments} \coqdocvar{None} \{\coqdocvar{X}\}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 We can now rewrite the \coqdocvar{index} function so that it works
    with any type of lists. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{index} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{n} : \coqdocvar{nat})\coqdoceol
\coqdocindent{7.50em}
(\coqdocvar{l} : \coqdocvar{list} \coqdocvar{X}) : \coqdocvar{option} \coqdocvar{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} [] \ensuremath{\Rightarrow} \coqdocvar{None}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{a} :: \coqdocvar{l'} \ensuremath{\Rightarrow} \coqdockw{if} \coqdocvar{beq\_nat} \coqdocvar{n} \coqdocvar{O} \coqdockw{then} \coqdocvar{Some} \coqdocvar{a} \coqdockw{else} \coqdocvar{index} (\coqdocvar{pred} \coqdocvar{n}) \coqdocvar{l'}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_index1} :    \coqdocvar{index} 0 [4;5;6;7]  = \coqdocvar{Some} 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_index2} :    \coqdocvar{index}  1 [[1];[2]]  = \coqdocvar{Some} [2].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_index3} :    \coqdocvar{index}  2 [\coqdocvar{true}]  = \coqdocvar{None}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star, optional (hd\_opt\_poly)}

 Complete the definition of a polymorphic version of the
    \coqdocvar{hd\_opt} function from the last chapter. Be sure that it
    passes the unit tests below. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{hd\_opt} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{l} : \coqdocvar{list} \coqdocvar{X})  : \coqdocvar{option} \coqdocvar{X} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Once again, to force the implicit arguments to be explicit,
    we can use @ before the name of the function. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} @\coqdocvar{hd\_opt}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_hd\_opt1} :  \coqdocvar{hd\_opt} [1;2] = \coqdocvar{Some} 1.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_hd\_opt2} :   \coqdocvar{hd\_opt}  [[1];[2]]  = \coqdocvar{Some} [1].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Functions as Data}

\begin{coqdoccode}
\end{coqdoccode}
\subsection{Higher-Order Functions}



 Like many other modern programming languages -- including
    all \textit{functional languages} (ML, Haskell, Scheme, etc.) -- Coq
    treats functions as first-class citizens, allowing functions to be
    passed as arguments to other functions, returned as results,
    stored in data structures, etc.


    Functions that manipulate other functions are often called
    \textit{higher-order} functions.  Here's a simple one: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{doit3times} \{\coqdocvar{X}:\coqdockw{Type}\} (\coqdocvar{f}:\coqdocvar{X}\ensuremath{\rightarrow}\coqdocvar{X}) (\coqdocvar{n}:\coqdocvar{X}) : \coqdocvar{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{f} (\coqdocvar{f} (\coqdocvar{f} \coqdocvar{n})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The argument \coqdocvar{f} here is itself a function (from \coqdocvar{X} to
    \coqdocvar{X}); the body of \coqdocvar{doit3times} applies \coqdocvar{f} three times to some
    value \coqdocvar{n}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} @\coqdocvar{doit3times}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_doit3times}: \coqdocvar{doit3times} \coqdocvar{minustwo} 9 = 3.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_doit3times'}: \coqdocvar{doit3times} \coqdocvar{negb} \coqdocvar{true} = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Partial Application}



 In fact, the multiple-argument functions we have already
    seen are also examples of passing functions as data.  To see why,
    recall the type of \coqdocvar{plus}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{plus}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Each \ensuremath{\rightarrow} in this expression is actually a \textit{binary} operator
    on types.  (This is the same as saying that Coq primitively
    supports only one-argument functions -- do you see why?)  This
    operator is \textit{right-associative}, so the type of \coqdocvar{plus} is really a
    shorthand for \coqdocvar{nat} \ensuremath{\rightarrow} (\coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat}) -- i.e., it can be read as
    saying that ``\coqdocvar{plus} is a one-argument function that takes a \coqdocvar{nat}
    and returns a one-argument function that takes another \coqdocvar{nat} and
    returns a \coqdocvar{nat}.''  In the examples above, we have always applied
    \coqdocvar{plus} to both of its arguments at once, but if we like we can
    supply just the first.  This is called \textit{partial application}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{plus3} := \coqdocvar{plus} 3.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqdocvar{plus3}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_plus3} :    \coqdocvar{plus3} 4 = 7.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_plus3'} :   \coqdocvar{doit3times} \coqdocvar{plus3} 0 = 9.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_plus3'{}'} :  \coqdocvar{doit3times} (\coqdocvar{plus} 3) 0 = 9.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Digression: Currying}



\paragraph{Exercise: 2 stars, advanced (currying)}

 In Coq, a function \coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B} \ensuremath{\rightarrow} \coqdocvar{C} really has the type \coqdocvar{A}
    \ensuremath{\rightarrow} (\coqdocvar{B} \ensuremath{\rightarrow} \coqdocvar{C}).  That is, if you give \coqdocvar{f} a value of type \coqdocvar{A}, it
    will give you function \coqdocvar{f'} : \coqdocvar{B} \ensuremath{\rightarrow} \coqdocvar{C}.  If you then give \coqdocvar{f'} a
    value of type \coqdocvar{B}, it will return a value of type \coqdocvar{C}.  This
    allows for partial application, as in \coqdocvar{plus3}.  Processing a list
    of arguments with functions that return functions is called
    \textit{currying}, in honor of the logician Haskell Curry.


    Conversely, we can reinterpret the type \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B} \ensuremath{\rightarrow} \coqdocvar{C} as (\coqdocvar{A} \ensuremath{\times}
    \coqdocvar{B}) \ensuremath{\rightarrow} \coqdocvar{C}.  This is called \textit{uncurrying}.  With an uncurried binary
    function, both arguments must be given at once as a pair; there is
    no partial application. 

 We can define currying as follows: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{prod\_curry} \{\coqdocvar{X} \coqdocvar{Y} \coqdocvar{Z} : \coqdockw{Type}\}\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{f} : \coqdocvar{X} \ensuremath{\times} \coqdocvar{Y} \ensuremath{\rightarrow} \coqdocvar{Z}) (\coqdocvar{x} : \coqdocvar{X}) (\coqdocvar{y} : \coqdocvar{Y}) : \coqdocvar{Z} := \coqdocvar{f} (\coqdocvar{x}, \coqdocvar{y}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
As an exercise, define its inverse, \coqdocvar{prod\_uncurry}.  Then prove
    the theorems below to show that the two are inverses. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{prod\_uncurry} \{\coqdocvar{X} \coqdocvar{Y} \coqdocvar{Z} : \coqdockw{Type}\}\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{f} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{Y} \ensuremath{\rightarrow} \coqdocvar{Z}) (\coqdocvar{p} : \coqdocvar{X} \ensuremath{\times} \coqdocvar{Y}) : \coqdocvar{Z} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
(Thought exercise: before running these commands, can you
    calculate the types of \coqdocvar{prod\_curry} and \coqdocvar{prod\_uncurry}?) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} @\coqdocvar{prod\_curry}.\coqdoceol
\coqdocnoindent
\coqdockw{Check} @\coqdocvar{prod\_uncurry}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{uncurry\_curry} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} \coqdocvar{Y} \coqdocvar{Z} : \coqdockw{Type}) (\coqdocvar{f} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{Y} \ensuremath{\rightarrow} \coqdocvar{Z}) \coqdocvar{x} \coqdocvar{y},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{prod\_curry} (\coqdocvar{prod\_uncurry} \coqdocvar{f}) \coqdocvar{x} \coqdocvar{y} = \coqdocvar{f} \coqdocvar{x} \coqdocvar{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{curry\_uncurry} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} \coqdocvar{Y} \coqdocvar{Z} : \coqdockw{Type})\coqdoceol
\coqdocindent{15.50em}
(\coqdocvar{f} : (\coqdocvar{X} \ensuremath{\times} \coqdocvar{Y}) \ensuremath{\rightarrow} \coqdocvar{Z}) (\coqdocvar{p} : \coqdocvar{X} \ensuremath{\times} \coqdocvar{Y}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{prod\_uncurry} (\coqdocvar{prod\_curry} \coqdocvar{f}) \coqdocvar{p} = \coqdocvar{f} \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Filter}



 Here is a useful higher-order function, which takes a list
    of \coqdocvar{X}s and a \textit{predicate} on \coqdocvar{X} (a function from \coqdocvar{X} to \coqdocvar{bool})
    and ``filters'' the list, returning a new list containing just those
    elements for which the predicate returns \coqdocvar{true}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{filter} \{\coqdocvar{X}:\coqdockw{Type}\} (\coqdocvar{test}: \coqdocvar{X}\ensuremath{\rightarrow}\coqdocvar{bool}) (\coqdocvar{l}:\coqdocvar{list} \coqdocvar{X})\coqdoceol
\coqdocindent{8.00em}
: (\coqdocvar{list} \coqdocvar{X}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} []     \ensuremath{\Rightarrow} []\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} :: \coqdocvar{t} \ensuremath{\Rightarrow} \coqdockw{if} \coqdocvar{test} \coqdocvar{h} \coqdockw{then} \coqdocvar{h} :: (\coqdocvar{filter} \coqdocvar{test} \coqdocvar{t})\coqdoceol
\coqdocindent{12.00em}
\coqdockw{else}       \coqdocvar{filter} \coqdocvar{test} \coqdocvar{t}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For example, if we apply \coqdocvar{filter} to the predicate \coqdocvar{evenb}
    and a list of numbers \coqdocvar{l}, it returns a list containing just the
    even members of \coqdocvar{l}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_filter1}: \coqdocvar{filter} \coqdocvar{evenb} [1;2;3;4] = [2;4].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{length\_is\_1} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{l} : \coqdocvar{list} \coqdocvar{X}) : \coqdocvar{bool} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beq\_nat} (\coqdocvar{length} \coqdocvar{l}) 1.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_filter2}:\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{filter} \coqdocvar{length\_is\_1}\coqdoceol
\coqdocindent{5.50em}
[ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\coqdoceol
\coqdocindent{1.00em}
= [ [3]; [4]; [8] ].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }



 We can use \coqdocvar{filter} to give a concise version of the
    \coqdocvar{countoddmembers} function from the \coqdocvar{Lists} chapter. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{countoddmembers'} (\coqdocvar{l}:\coqdocvar{list} \coqdocvar{nat}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{length} (\coqdocvar{filter} \coqdocvar{oddb} \coqdocvar{l}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_countoddmembers'1}:   \coqdocvar{countoddmembers'} [1;0;3;1;4;5] = 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_countoddmembers'2}:   \coqdocvar{countoddmembers'} [0;2;4] = 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_countoddmembers'3}:   \coqdocvar{countoddmembers'} \coqdocvar{nil} = 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Anonymous Functions}



 It is a little annoying to be forced to define the function
    \coqdocvar{length\_is\_1} and give it a name just to be able to pass it as an
    argument to \coqdocvar{filter}, since we will probably never use it again.
    Moreover, this is not an isolated example.  When using
    higher-order functions, we often want to pass as arguments
    ``one-off'' functions that we will never use again; having to give
    each of these functions a name would be tedious.


    Fortunately, there is a better way. It is also possible to
    construct a function ``on the fly'' without declaring it at the top
    level or giving it a name; this is analogous to the notation we've
    been using for writing down constant lists, natural numbers, and
    so on. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_anon\_fun'}:\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{doit3times} (\coqdockw{fun} \coqdocvar{n} \ensuremath{\Rightarrow} \coqdocvar{n} \ensuremath{\times} \coqdocvar{n}) 2 = 256.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is the motivating example from before, rewritten to use
    an anonymous function. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_filter2'}:\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{filter} (\coqdockw{fun} \coqdocvar{l} \ensuremath{\Rightarrow} \coqdocvar{beq\_nat} (\coqdocvar{length} \coqdocvar{l}) 1)\coqdoceol
\coqdocindent{5.50em}
[ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\coqdoceol
\coqdocindent{1.00em}
= [ [3]; [4]; [8] ].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars (filter\_even\_gt7)}



 Use \coqdocvar{filter} (instead of \coqdockw{Fixpoint}) to write a Coq function
    \coqdocvar{filter\_even\_gt7} that takes a list of natural numbers as input
    and returns a list of just those that are even and greater than
    7. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{filter\_even\_gt7} (\coqdocvar{l} : \coqdocvar{list} \coqdocvar{nat}) : \coqdocvar{list} \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_filter\_even\_gt7\_1} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{filter\_even\_gt7} [1;2;6;9;10;3;12;8] = [10;12;8].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_filter\_even\_gt7\_2} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{filter\_even\_gt7} [5;2;6;19;129] = [].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars (partition)}

 Use \coqdocvar{filter} to write a Coq function \coqdocvar{partition}:
  partition : forall X : Type,
              (X -> bool) -> list X -> list X * list X
   Given a set \coqdocvar{X}, a test function of type \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{bool} and a \coqdocvar{list}
   \coqdocvar{X}, \coqdocvar{partition} should return a pair of lists.  The first member of
   the pair is the sublist of the original list containing the
   elements that satisfy the test, and the second is the sublist
   containing those that fail the test.  The order of elements in the
   two sublists should be the same as their order in the original
   list.
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{partition} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{test} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{bool}) (\coqdocvar{l} : \coqdocvar{list} \coqdocvar{X})\coqdoceol
\coqdocindent{10.50em}
: \coqdocvar{list} \coqdocvar{X} \ensuremath{\times} \coqdocvar{list} \coqdocvar{X} :=\coqdoceol
\coqdocnoindent
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_partition1}: \coqdocvar{partition} \coqdocvar{oddb} [1;2;3;4;5] = ([1;3;5], [2;4]).\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_partition2}: \coqdocvar{partition} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{false}) [5;9;0] = ([], [5;9;0]).\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Map}



 Another handy higher-order function is called \coqdocvar{map}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{map} \{\coqdocvar{X} \coqdocvar{Y}:\coqdockw{Type}\} (\coqdocvar{f}:\coqdocvar{X}\ensuremath{\rightarrow}\coqdocvar{Y}) (\coqdocvar{l}:\coqdocvar{list} \coqdocvar{X})\coqdoceol
\coqdocindent{6.50em}
: (\coqdocvar{list} \coqdocvar{Y}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} []     \ensuremath{\Rightarrow} []\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} :: \coqdocvar{t} \ensuremath{\Rightarrow} (\coqdocvar{f} \coqdocvar{h}) :: (\coqdocvar{map} \coqdocvar{f} \coqdocvar{t})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 It takes a function \coqdocvar{f} and a list  \coqdocvar{l} = [\coqdocvar{n1}, \coqdocvar{n2}, \coqdocvar{n3}, ...] 
    and returns the list  [\coqdocvar{f} \coqdocvar{n1}, \coqdocvar{f} \coqdocvar{n2}, \coqdocvar{f} \coqdocvar{n3},...] , where \coqdocvar{f} has
    been applied to each element of \coqdocvar{l} in turn.  For example: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_map1}: \coqdocvar{map} (\coqdocvar{plus} 3) [2;0;2] = [5;3;5].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The element types of the input and output lists need not be
    the same (\coqdocvar{map} takes \textit{two} type arguments, \coqdocvar{X} and \coqdocvar{Y}).  This
    version of \coqdocvar{map} can thus be applied to a list of numbers and a
    function from numbers to booleans to yield a list of booleans: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_map2}: \coqdocvar{map} \coqdocvar{oddb} [2;1;2;5] = [\coqdocvar{false};\coqdocvar{true};\coqdocvar{false};\coqdocvar{true}].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
It can even be applied to a list of numbers and
    a function from numbers to \textit{lists} of booleans to
    yield a list of lists of booleans: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_map3}:\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{map} (\coqdockw{fun} \coqdocvar{n} \ensuremath{\Rightarrow} [\coqdocvar{evenb} \coqdocvar{n};\coqdocvar{oddb} \coqdocvar{n}]) [2;1;2;5]\coqdoceol
\coqdocindent{1.00em}
= [[\coqdocvar{true};\coqdocvar{false}];[\coqdocvar{false};\coqdocvar{true}];[\coqdocvar{true};\coqdocvar{false}];[\coqdocvar{false};\coqdocvar{true}]].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Map for options}

\paragraph{Exercise: 3 stars (map\_rev)}

 Show that \coqdocvar{map} and \coqdocvar{rev} commute.  You may need to define an
    auxiliary lemma. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{map\_rev} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}) (\coqdocvar{f} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{Y}) (\coqdocvar{l} : \coqdocvar{list} \coqdocvar{X}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{map} \coqdocvar{f} (\coqdocvar{rev} \coqdocvar{l}) = \coqdocvar{rev} (\coqdocvar{map} \coqdocvar{f} \coqdocvar{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars (flat\_map)}

 The function \coqdocvar{map} maps a \coqdocvar{list} \coqdocvar{X} to a \coqdocvar{list} \coqdocvar{Y} using a function
    of type \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{Y}.  We can define a similar function, \coqdocvar{flat\_map},
    which maps a \coqdocvar{list} \coqdocvar{X} to a \coqdocvar{list} \coqdocvar{Y} using a function \coqdocvar{f} of type
    \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{list} \coqdocvar{Y}.  Your definition should work by 'flattening' the
    results of \coqdocvar{f}, like so:
        flat\_map (fun n => \coqdocvar{n};\coqdocvar{n}+1;\coqdocvar{n}+2) 1;5;10
      = 1; 2; 3; 5; 6; 7; 10; 11; 12.
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{flat\_map} \{\coqdocvar{X} \coqdocvar{Y}:\coqdockw{Type}\} (\coqdocvar{f}:\coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{list} \coqdocvar{Y}) (\coqdocvar{l}:\coqdocvar{list} \coqdocvar{X})\coqdoceol
\coqdocindent{9.50em}
: (\coqdocvar{list} \coqdocvar{Y}) :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_flat\_map1}:\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{flat\_map} (\coqdockw{fun} \coqdocvar{n} \ensuremath{\Rightarrow} [\coqdocvar{n};\coqdocvar{n};\coqdocvar{n}]) [1;5;4]\coqdoceol
\coqdocindent{1.00em}
= [1; 1; 1; 5; 5; 5; 4; 4; 4].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 Lists are not the only inductive type that we can write a
    \coqdocvar{map} function for.  Here is the definition of \coqdocvar{map} for the
    \coqdocvar{option} type: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{option\_map} \{\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}\} (\coqdocvar{f} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{Y}) (\coqdocvar{xo} : \coqdocvar{option} \coqdocvar{X})\coqdoceol
\coqdocindent{11.00em}
: \coqdocvar{option} \coqdocvar{Y} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{xo} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{None} \ensuremath{\Rightarrow} \coqdocvar{None}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{Some} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{Some} (\coqdocvar{f} \coqdocvar{x})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars, optional (implicit\_args)}

 The definitions and uses of \coqdocvar{filter} and \coqdocvar{map} use implicit
    arguments in many places.  Replace the curly braces around the
    implicit arguments with parentheses, and then fill in explicit
    type parameters where necessary and use Coq to check that you've
    done so correctly.  (This exercise is not to be turned in; it is
    probably easiest to do it on a \textit{copy} of this file that you can
    throw away afterwards.)  \ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Fold}



 An even more powerful higher-order function is called
    \coqdoctac{fold}.  This function is the inspiration for the ``\coqdocvar{reduce}''
    operation that lies at the heart of Google's map/reduce
    distributed programming framework. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdoctac{fold} \{\coqdocvar{X} \coqdocvar{Y}:\coqdockw{Type}\} (\coqdocvar{f}: \coqdocvar{X}\ensuremath{\rightarrow}\coqdocvar{Y}\ensuremath{\rightarrow}\coqdocvar{Y}) (\coqdocvar{l}:\coqdocvar{list} \coqdocvar{X}) (\coqdocvar{b}:\coqdocvar{Y}) : \coqdocvar{Y} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nil} \ensuremath{\Rightarrow} \coqdocvar{b}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{h} :: \coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{f} \coqdocvar{h} (\coqdoctac{fold} \coqdocvar{f} \coqdocvar{t} \coqdocvar{b})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }



 Intuitively, the behavior of the \coqdoctac{fold} operation is to
    insert a given binary operator \coqdocvar{f} between every pair of elements
    in a given list.  For example,  \coqdoctac{fold} \coqdocvar{plus} [1;2;3;4]  intuitively
    means 1+2+3+4.  To make this precise, we also need a ``starting
    element'' that serves as the initial second input to \coqdocvar{f}.  So, for
    example,
   fold plus 1;2;3;4 0
    yields
   1 + (2 + (3 + (4 + 0))).
    Here are some more examples:
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqdoctac{fold} \coqdocvar{andb}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{fold\_example1} : \coqdoctac{fold} \coqdocvar{mult} [1;2;3;4] 1 = 24.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{fold\_example2} : \coqdoctac{fold} \coqdocvar{andb} [\coqdocvar{true};\coqdocvar{true};\coqdocvar{false};\coqdocvar{true}] \coqdocvar{true} = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{fold\_example3} : \coqdoctac{fold} \coqdocvar{app}  [[1];[];[2;3];[4]] [] = [1;2;3;4].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star, advanced (fold\_types\_different)}

 Observe that the type of \coqdoctac{fold} is parameterized by \textit{two} type
    variables, \coqdocvar{X} and \coqdocvar{Y}, and the parameter \coqdocvar{f} is a binary operator
    that takes an \coqdocvar{X} and a \coqdocvar{Y} and returns a \coqdocvar{Y}.  Can you think of a
    situation where it would be useful for \coqdocvar{X} and \coqdocvar{Y} to be
    different? \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Functions For Constructing Functions}



 Most of the higher-order functions we have talked about so
    far take functions as \textit{arguments}.  Now let's look at some
    examples involving \textit{returning} functions as the results of other
    functions.


    To begin, here is a function that takes a value \coqdocvar{x} (drawn from
    some type \coqdocvar{X}) and returns a function from \coqdocvar{nat} to \coqdocvar{X} that
    yields \coqdocvar{x} whenever it is called, ignoring its \coqdocvar{nat} argument. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{constfun} \{\coqdocvar{X}: \coqdockw{Type}\} (\coqdocvar{x}: \coqdocvar{X}) : \coqdocvar{nat}\ensuremath{\rightarrow}\coqdocvar{X} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} (\coqdocvar{k}:\coqdocvar{nat}) \ensuremath{\Rightarrow} \coqdocvar{x}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{ftrue} := \coqdocvar{constfun} \coqdocvar{true}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{constfun\_example1} : \coqdocvar{ftrue} 0 = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{constfun\_example2} : (\coqdocvar{constfun} 5) 99 = 5.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 Similarly, but a bit more interestingly, here is a function
    that takes a function \coqdocvar{f} from numbers to some type \coqdocvar{X}, a number
    \coqdocvar{k}, and a value \coqdocvar{x}, and constructs a function that behaves
    exactly like \coqdocvar{f} except that, when called with the argument \coqdocvar{k},
    it returns \coqdocvar{x}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{override} \{\coqdocvar{X}: \coqdockw{Type}\} (\coqdocvar{f}: \coqdocvar{nat}\ensuremath{\rightarrow}\coqdocvar{X}) (\coqdocvar{k}:\coqdocvar{nat}) (\coqdocvar{x}:\coqdocvar{X}) : \coqdocvar{nat}\ensuremath{\rightarrow}\coqdocvar{X}:=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} (\coqdocvar{k'}:\coqdocvar{nat}) \ensuremath{\Rightarrow} \coqdockw{if} \coqdocvar{beq\_nat} \coqdocvar{k} \coqdocvar{k'} \coqdockw{then} \coqdocvar{x} \coqdockw{else} \coqdocvar{f} \coqdocvar{k'}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For example, we can apply \coqdocvar{override} twice to obtain a
    function from numbers to booleans that returns \coqdocvar{false} on 1 and
    3 and returns \coqdocvar{true} on all other arguments. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{fmostlytrue} := \coqdocvar{override} (\coqdocvar{override} \coqdocvar{ftrue} 1 \coqdocvar{false}) 3 \coqdocvar{false}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{override\_example1} : \coqdocvar{fmostlytrue} 0 = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{override\_example2} : \coqdocvar{fmostlytrue} 1 = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{override\_example3} : \coqdocvar{fmostlytrue} 2 = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{override\_example4} : \coqdocvar{fmostlytrue} 3 = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }



\paragraph{Exercise: 1 star (override\_example)}

 Before starting to work on the following proof, make sure you
    understand exactly what the theorem is saying and can paraphrase
    it in your own words.  The proof itself is straightforward. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{override\_example} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{b}:\coqdocvar{bool}),\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{override} (\coqdocvar{constfun} \coqdocvar{b}) 3 \coqdocvar{true}) 2 = \coqdocvar{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 We'll use function overriding heavily in parts of the rest of the
    course, and we will end up needing to know quite a bit about its
    properties.  To prove these properties, though, we need to know
    about a few more of Coq's tactics; developing these is the main
    topic of the next chapter.  For now, though, let's introduce just
    one very useful tactic that will also help us with proving
    properties of some of the other functions we have introduced in
    this chapter. \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\section{The \texorpdfstring{\protect\coqdoctac{unfold}}{unfold} Tactic}



 Sometimes, a proof will get stuck because Coq doesn't
    automatically expand a function call into its definition.  (This
    is a feature, not a bug: if Coq automatically expanded everything
    possible, our proof goals would quickly become enormous -- hard to
    read and slow for Coq to manipulate!) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{unfold\_example\_bad} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
3 + \coqdocvar{n} = \coqdocvar{m} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{plus3} \coqdocvar{n} + 1 = \coqdocvar{m} + 1.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{n} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqdoctac{unfold} tactic can be used to explicitly replace a
    defined name by the right-hand side of its definition.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{unfold\_example} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
3 + \coqdocvar{n} = \coqdocvar{m} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{plus3} \coqdocvar{n} + 1 = \coqdocvar{m} + 1.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{n} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{plus3}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now we can prove a first property of \coqdocvar{override}: If we
    override a function at some argument \coqdocvar{k} and then look up \coqdocvar{k}, we
    get back the overridden value. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{override\_eq} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{X}:\coqdockw{Type}\} \coqdocvar{x} \coqdocvar{k} (\coqdocvar{f}:\coqdocvar{nat}\ensuremath{\rightarrow}\coqdocvar{X}),\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{override} \coqdocvar{f} \coqdocvar{k} \coqdocvar{x}) \coqdocvar{k} = \coqdocvar{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{x} \coqdocvar{k} \coqdocvar{f}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{override}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{beq\_nat\_refl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This proof was straightforward, but note that it requires
    \coqdoctac{unfold} to expand the definition of \coqdocvar{override}. 

\paragraph{Exercise: 2 stars (override\_neq)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{override\_neq} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) \coqdocvar{x1} \coqdocvar{x2} \coqdocvar{k1} \coqdocvar{k2} (\coqdocvar{f} : \coqdocvar{nat}\ensuremath{\rightarrow}\coqdocvar{X}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{f} \coqdocvar{k1} = \coqdocvar{x1} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beq\_nat} \coqdocvar{k2} \coqdocvar{k1} = \coqdocvar{false} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{override} \coqdocvar{f} \coqdocvar{k2} \coqdocvar{x2}) \coqdocvar{k1} = \coqdocvar{x1}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 As the inverse of \coqdoctac{unfold}, Coq also provides a tactic
    \coqdoctac{fold}, which can be used to ``unexpand'' a definition.  It is used
    much less often. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Additional Exercises}



\paragraph{Exercise: 2 stars (fold\_length)}

 Many common functions on lists can be implemented in terms of
   \coqdoctac{fold}.  For example, here is an alternative definition of \coqdocvar{length}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{fold\_length} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{l} : \coqdocvar{list} \coqdocvar{X}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{fold} (\coqdockw{fun} \coqdocvar{\_} \coqdocvar{n} \ensuremath{\Rightarrow} \coqdocvar{S} \coqdocvar{n}) \coqdocvar{l} 0.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_fold\_length1} : \coqdocvar{fold\_length} [4;7;0] = 3.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Prove the correctness of \coqdocvar{fold\_length}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{fold\_length\_correct} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} (\coqdocvar{l} : \coqdocvar{list} \coqdocvar{X}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{fold\_length} \coqdocvar{l} = \coqdocvar{length} \coqdocvar{l}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars (fold\_map)}

 We can also define \coqdocvar{map} in terms of \coqdoctac{fold}.  Finish \coqdocvar{fold\_map}
    below. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{fold\_map} \{\coqdocvar{X} \coqdocvar{Y}:\coqdockw{Type}\} (\coqdocvar{f} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{Y}) (\coqdocvar{l} : \coqdocvar{list} \coqdocvar{X}) : \coqdocvar{list} \coqdocvar{Y} :=\coqdoceol
\coqdocnoindent
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Write down a theorem \coqdocvar{fold\_map\_correct} in Coq stating that
   \coqdocvar{fold\_map} is correct, and prove it. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars, advanced (index\_informal)}

 Recall the definition of the \coqdocvar{index} function:
   Fixpoint index \{X : Type\} (n : nat) (l : list X) : option X :=
     match l with
     | \ensuremath{\Box} => None 
     | a :: l' => if beq\_nat n O then Some a else index (pred n) l'
     end.
   Write an informal proof of the following theorem:
   forall X n l, length l = n -> @index X n l = None.
 \ensuremath{\Box} 

\paragraph{Exercise: 4 stars, advanced (church\_numerals)}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdocvar{Church}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In this exercise, we will explore an alternative way of defining
    natural numbers, using the so-called \textit{Church numerals}, named
    after mathematician Alonzo Church. We can represent a natural
    number \coqdocvar{n} as a function that takes a function \coqdocvar{f} as a parameter
    and returns \coqdocvar{f} iterated \coqdocvar{n} times. More formally, \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{nat} := \coqdockw{\ensuremath{\forall}} \coqdocvar{X} : \coqdockw{Type}, (\coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{X}) \ensuremath{\rightarrow} \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{X}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Let's see how to write some numbers with this notation. Any
    function \coqdocvar{f} iterated once shouldn't change. Thus, \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{one} : \coqdocvar{nat} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{f} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{X}) (\coqdocvar{x} : \coqdocvar{X}) \ensuremath{\Rightarrow} \coqdocvar{f} \coqdocvar{x}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdocvar{two} should apply \coqdocvar{f} twice to its argument: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{two} : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{f} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{X}) (\coqdocvar{x} : \coqdocvar{X}) \ensuremath{\Rightarrow} \coqdocvar{f} (\coqdocvar{f} \coqdocvar{x}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqdocvar{zero} is somewhat trickier: how can we apply a function zero
    times? The answer is simple: just leave the argument untouched. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{zero} : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{f} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{X}) (\coqdocvar{x} : \coqdocvar{X}) \ensuremath{\Rightarrow} \coqdocvar{x}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
More generally, a number \coqdocvar{n} will be written as \coqdockw{fun} \coqdocvar{X} \coqdocvar{f} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{f} (\coqdocvar{f}
    ... (\coqdocvar{f} \coqdocvar{x}) ...), with \coqdocvar{n} occurrences of \coqdocvar{f}. Notice in particular
    how the \coqdocvar{doit3times} function we've defined previously is actually
    just the representation of 3. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{three} : \coqdocvar{nat} := @\coqdocvar{doit3times}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Complete the definitions of the following functions. Make sure
    that the corresponding unit tests pass by proving them with
    \coqdoctac{reflexivity}. 

 Successor of a natural number \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{succ} (\coqdocvar{n} : \coqdocvar{nat}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{succ\_1} : \coqdocvar{succ} \coqdocvar{zero} = \coqdocvar{one}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{succ\_2} : \coqdocvar{succ} \coqdocvar{one} = \coqdocvar{two}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{succ\_3} : \coqdocvar{succ} \coqdocvar{two} = \coqdocvar{three}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Addition of two natural numbers \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{plus} (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{plus\_1} : \coqdocvar{plus} \coqdocvar{zero} \coqdocvar{one} = \coqdocvar{one}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{plus\_2} : \coqdocvar{plus} \coqdocvar{two} \coqdocvar{three} = \coqdocvar{plus} \coqdocvar{three} \coqdocvar{two}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{plus\_3} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{plus} (\coqdocvar{plus} \coqdocvar{two} \coqdocvar{two}) \coqdocvar{three} = \coqdocvar{plus} \coqdocvar{one} (\coqdocvar{plus} \coqdocvar{three} \coqdocvar{three}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Multiplication \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{mult} (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}) : \coqdocvar{nat} := \coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{mult\_1} : \coqdocvar{mult} \coqdocvar{one} \coqdocvar{one} = \coqdocvar{one}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{mult\_2} : \coqdocvar{mult} \coqdocvar{zero} (\coqdocvar{plus} \coqdocvar{three} \coqdocvar{three}) = \coqdocvar{zero}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{mult\_3} : \coqdocvar{mult} \coqdocvar{two} \coqdocvar{three} = \coqdocvar{plus} \coqdocvar{three} \coqdocvar{three}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Exponentiation 

 Hint: Polymorphism plays a crucial role here. However, choosing
    the right type to iterate over can be tricky. If you hit a
    ``Universe inconsistency'' error, try iterating over a different
    type: \coqdocvar{nat} itself is usually problematic. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{exp} (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}) : \coqdocvar{nat} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{exp\_1} : \coqdocvar{exp} \coqdocvar{two} \coqdocvar{two} = \coqdocvar{plus} \coqdocvar{two} \coqdocvar{two}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{exp\_2} : \coqdocvar{exp} \coqdocvar{three} \coqdocvar{two} = \coqdocvar{plus} (\coqdocvar{mult} \coqdocvar{two} (\coqdocvar{mult} \coqdocvar{two} \coqdocvar{two})) \coqdocvar{one}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{exp\_3} : \coqdocvar{exp} \coqdocvar{three} \coqdocvar{zero} = \coqdocvar{one}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.  \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqdocvar{Church}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

 $Date: 2014-12-31 11:17:56 -0500 (Wed, 31 Dec 2014) $ \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{Top.MoreCoq}{Library }{Top.MoreCoq}

\begin{coqdoccode}
\end{coqdoccode}
\section{MoreCoq: More About Coq's Tactics}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqdocvar{Poly}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This chapter introduces several more proof strategies and
    tactics that, together, allow us to prove theorems about the
    functional programs we have been writing. In particular, we'll
    reason about functions that work with natural numbers and lists.


    In particular, we will see:



\begin{itemize}
\item  how to use auxiliary lemmas, in both forwards and backwards reasoning;

\item  how to reason about data constructors, which are injective and disjoint;

\item  how to create a strong induction hypotheses (and when
      strengthening is required); and

\item  how to reason by case analysis.

\end{itemize}
 \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{The \texorpdfstring{\protect\coqdoctac{apply}}{apply} Tactic}



 We often encounter situations where the goal to be proved is
    exactly the same as some hypothesis in the context or some
    previously proved lemma. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{silly1} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{p} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{n} = \coqdocvar{m}  \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{n};\coqdocvar{o}] = [\coqdocvar{n};\coqdocvar{p}] \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{n};\coqdocvar{o}] = [\coqdocvar{m};\coqdocvar{p}].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{p} \coqdocvar{eq1} \coqdocvar{eq2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{eq1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{eq2}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqdoctac{apply} tactic also works with \textit{conditional} hypotheses
    and lemmas: if the statement being applied is an implication, then
    the premises of this implication will be added to the list of
    subgoals needing to be proved. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{silly2} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{p} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{n} = \coqdocvar{m}  \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{q} \coqdocvar{r} : \coqdocvar{nat}), \coqdocvar{q} = \coqdocvar{r} \ensuremath{\rightarrow} [\coqdocvar{q};\coqdocvar{o}] = [\coqdocvar{r};\coqdocvar{p}]) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{n};\coqdocvar{o}] = [\coqdocvar{m};\coqdocvar{p}].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{p} \coqdocvar{eq1} \coqdocvar{eq2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{eq2}. \coqdoctac{apply} \coqdocvar{eq1}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
You may find it instructive to experiment with this proof
    and see if there is a way to complete it using just \coqdoctac{rewrite}
    instead of \coqdoctac{apply}. 

 Typically, when we use \coqdoctac{apply} \coqdocvar{H}, the statement \coqdocvar{H} will
    begin with a \coqdockw{\ensuremath{\forall}} binding some \textit{universal variables}.  When
    Coq matches the current goal against the conclusion of \coqdocvar{H}, it
    will try to find appropriate values for these variables.  For
    example, when we do \coqdoctac{apply} \coqdocvar{eq2} in the following proof, the
    universal variable \coqdocvar{q} in \coqdocvar{eq2} gets instantiated with \coqdocvar{n} and \coqdocvar{r}
    gets instantiated with \coqdocvar{m}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{silly2a} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
(\coqdocvar{n},\coqdocvar{n}) = (\coqdocvar{m},\coqdocvar{m})  \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
(\coqdockw{\ensuremath{\forall}} (\coqdocvar{q} \coqdocvar{r} : \coqdocvar{nat}), (\coqdocvar{q},\coqdocvar{q}) = (\coqdocvar{r},\coqdocvar{r}) \ensuremath{\rightarrow} [\coqdocvar{q}] = [\coqdocvar{r}]) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{n}] = [\coqdocvar{m}].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{eq1} \coqdocvar{eq2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{eq2}. \coqdoctac{apply} \coqdocvar{eq1}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars, optional (silly\_ex)}

 Complete the following proof without using \coqdoctac{simpl}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{silly\_ex} : \coqdoceol
\coqdocindent{2.50em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{evenb} \coqdocvar{n} = \coqdocvar{true} \ensuremath{\rightarrow} \coqdocvar{oddb} (\coqdocvar{S} \coqdocvar{n}) = \coqdocvar{true}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{evenb} 3 = \coqdocvar{true} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{oddb} 4 = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 To use the \coqdoctac{apply} tactic, the (conclusion of the) fact
    being applied must match the goal \textit{exactly} -- for example, \coqdoctac{apply}
    will not work if the left and right sides of the equality are
    swapped. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{silly3\_firsttry} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{true} = \coqdocvar{beq\_nat} \coqdocvar{n} 5  \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{beq\_nat} (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{n})) 7 = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In this case we can use the \coqdoctac{symmetry} tactic, which switches the
    left and right sides of an equality in the goal. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{silly3} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{true} = \coqdocvar{beq\_nat} \coqdocvar{n} 5  \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{beq\_nat} (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{n})) 7 = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{symmetry}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}. \coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 3 stars (apply\_exercise1)}

 Hint: you can use \coqdoctac{apply} with previously defined lemmas, not
    just hypotheses in the context.  Remember that \coqdockw{SearchAbout} is
    your friend. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{rev\_exercise1} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{l} \coqdocvar{l'} : \coqdocvar{list} \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{l} = \coqdocvar{rev} \coqdocvar{l'} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{l'} = \coqdocvar{rev} \coqdocvar{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 1 star, optional (apply\_rewrite)}

 Briefly explain the difference between the tactics \coqdoctac{apply} and
    \coqdoctac{rewrite}.  Are there situations where both can usefully be
    applied?
   \ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{The \texorpdfstring{\protect\coqdoctac{apply}}{apply} ... \texorpdfstring{\protect\coqdockw{with}}{with} ... Tactic}



 The following silly example uses two rewrites in a row to
    get from [\coqdocvar{a},\coqdocvar{b}] to [\coqdocvar{e},\coqdocvar{f}]. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{trans\_eq\_example} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d} \coqdocvar{e} \coqdocvar{f} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{a};\coqdocvar{b}] = [\coqdocvar{c};\coqdocvar{d}] \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{c};\coqdocvar{d}] = [\coqdocvar{e};\coqdocvar{f}] \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{a};\coqdocvar{b}] = [\coqdocvar{e};\coqdocvar{f}].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d} \coqdocvar{e} \coqdocvar{f} \coqdocvar{eq1} \coqdocvar{eq2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{eq1}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{eq2}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Since this is a common pattern, we might
    abstract it out as a lemma recording once and for all
    the fact that equality is transitive. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{trans\_eq} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{n} \coqdocvar{m} \coqdocvar{o} : \coqdocvar{X}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} = \coqdocvar{m} \ensuremath{\rightarrow} \coqdocvar{m} = \coqdocvar{o} \ensuremath{\rightarrow} \coqdocvar{n} = \coqdocvar{o}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{eq1} \coqdocvar{eq2}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{eq1}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{eq2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now, we should be able to use \coqdocvar{trans\_eq} to
    prove the above example.  However, to do this we need
    a slight refinement of the \coqdoctac{apply} tactic. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{trans\_eq\_example'} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d} \coqdocvar{e} \coqdocvar{f} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{a};\coqdocvar{b}] = [\coqdocvar{c};\coqdocvar{d}] \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{c};\coqdocvar{d}] = [\coqdocvar{e};\coqdocvar{f}] \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{a};\coqdocvar{b}] = [\coqdocvar{e};\coqdocvar{f}].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d} \coqdocvar{e} \coqdocvar{f} \coqdocvar{eq1} \coqdocvar{eq2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{trans\_eq} \coqdockw{with} (\coqdocvar{m}:=[\coqdocvar{c};\coqdocvar{d}]). \coqdoctac{apply} \coqdocvar{eq1}. \coqdoctac{apply} \coqdocvar{eq2}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
 Actually, we usually don't have to include the name \coqdocvar{m}
    in the \coqdockw{with} clause; Coq is often smart enough to
    figure out which instantiation we're giving. We could
    instead write: \coqdoctac{apply} \coqdocvar{trans\_eq} \coqdockw{with} [\coqdocvar{c},\coqdocvar{d}]. 

\paragraph{Exercise: 3 stars, optional (apply\_with\_exercise)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdocvar{trans\_eq\_exercise} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{p} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{m} = (\coqdocvar{minustwo} \coqdocvar{o}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
(\coqdocvar{n} + \coqdocvar{p}) = \coqdocvar{m} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
(\coqdocvar{n} + \coqdocvar{p}) = (\coqdocvar{minustwo} \coqdocvar{o}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{The \texorpdfstring{\protect\coqdoctac{inversion}}{inversion} tactic}



 Recall the definition of natural numbers:
     Inductive nat : Type :=
       | O : nat
       | S : nat -> nat.
    It is clear from this definition that every number has one of two
    forms: either it is the constructor \coqdocvar{O} or it is built by applying
    the constructor \coqdocvar{S} to another number.  But there is more here than
    meets the eye: implicit in the definition (and in our informal
    understanding of how datatype declarations work in other
    programming languages) are two other facts:



\begin{itemize}
\item  The constructor \coqdocvar{S} is \textit{injective}.  That is, the only way we can
      have \coqdocvar{S} \coqdocvar{n} = \coqdocvar{S} \coqdocvar{m} is if \coqdocvar{n} = \coqdocvar{m}.



\item  The constructors \coqdocvar{O} and \coqdocvar{S} are \textit{disjoint}.  That is, \coqdocvar{O} is not
      equal to \coqdocvar{S} \coqdocvar{n} for any \coqdocvar{n}. 
\end{itemize}


 Similar principles apply to all inductively defined types: all
    constructors are injective, and the values built from distinct
    constructors are never equal.  For lists, the \coqdocvar{cons} constructor is
    injective and \coqdocvar{nil} is different from every non-empty list.  For
    booleans, \coqdocvar{true} and \coqdocvar{false} are unequal.  (Since neither \coqdocvar{true}
    nor \coqdocvar{false} take any arguments, their injectivity is not an issue.) 

 Coq provides a tactic called \coqdoctac{inversion} that allows us to exploit
    these principles in proofs.


    The \coqdoctac{inversion} tactic is used like this.  Suppose \coqdocvar{H} is a
    hypothesis in the context (or a previously proven lemma) of the
    form
      c a1 a2 ... an = d b1 b2 ... bm
    for some constructors \coqdocvar{c} and \coqdocvar{d} and arguments \coqdocvar{a1} ... \coqdocvar{an} and
    \coqdocvar{b1} ... \coqdocvar{bm}.  Then \coqdoctac{inversion} \coqdocvar{H} instructs Coq to ``invert'' this
    equality to extract the information it contains about these terms:



\begin{itemize}
\item  If \coqdocvar{c} and \coqdocvar{d} are the same constructor, then we know, by the
      injectivity of this constructor, that \coqdocvar{a1} = \coqdocvar{b1}, \coqdocvar{a2} = \coqdocvar{b2},
      etc.; \coqdoctac{inversion} \coqdocvar{H} adds these facts to the context, and tries
      to use them to rewrite the goal.



\item  If \coqdocvar{c} and \coqdocvar{d} are different constructors, then the hypothesis
      \coqdocvar{H} is contradictory.  That is, a false assumption has crept
      into the context, and this means that any goal whatsoever is
      provable!  In this case, \coqdoctac{inversion} \coqdocvar{H} marks the current goal as
      completed and pops it off the goal stack. 
\end{itemize}


 The \coqdoctac{inversion} tactic is probably easier to understand by
    seeing it in action than from general descriptions like the above.
    Below you will find example theorems that demonstrate the use of
    \coqdoctac{inversion} and exercises to test your understanding. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{eq\_add\_S} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{S} \coqdocvar{n} = \coqdocvar{S} \coqdocvar{m} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{n} = \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{eq}. \coqdoctac{inversion} \coqdocvar{eq}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{silly4} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{n}] = [\coqdocvar{m}] \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{n} = \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{o} \coqdocvar{eq}. \coqdoctac{inversion} \coqdocvar{eq}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
As a convenience, the \coqdoctac{inversion} tactic can also
    destruct equalities between complex values, binding
    multiple variables as it goes. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{silly5} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} \coqdocvar{o} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{n};\coqdocvar{m}] = [\coqdocvar{o};\coqdocvar{o}] \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{n}] = [\coqdocvar{m}].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o} \coqdocvar{eq}. \coqdoctac{inversion} \coqdocvar{eq}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star (sillyex1)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdocvar{sillyex1} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{X}) (\coqdocvar{l} \coqdocvar{j} : \coqdocvar{list} \coqdocvar{X}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{x} :: \coqdocvar{y} :: \coqdocvar{l} = \coqdocvar{z} :: \coqdocvar{j} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{y} :: \coqdocvar{l} = \coqdocvar{x} :: \coqdocvar{j} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{x} = \coqdocvar{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{silly6} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{S} \coqdocvar{n} = \coqdocvar{O} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
2 + 2 = 5.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{contra}. \coqdoctac{inversion} \coqdocvar{contra}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{silly7} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{false} = \coqdocvar{true} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{n}] = [\coqdocvar{m}].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{contra}. \coqdoctac{inversion} \coqdocvar{contra}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star (sillyex2)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Example} \coqdocvar{sillyex2} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{X}) (\coqdocvar{l} \coqdocvar{j} : \coqdocvar{list} \coqdocvar{X}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{x} :: \coqdocvar{y} :: \coqdocvar{l} = [] \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{y} :: \coqdocvar{l} = \coqdocvar{z} :: \coqdocvar{j} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{x} = \coqdocvar{z}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 While the injectivity of constructors allows us to reason
    \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}), \coqdocvar{S} \coqdocvar{n} = \coqdocvar{S} \coqdocvar{m} \ensuremath{\rightarrow} \coqdocvar{n} = \coqdocvar{m}, the reverse direction of
    the implication is an instance of a more general fact about
    constructors and functions, which we will often find useful: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdoctac{f\_equal} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{A} \coqdocvar{B} : \coqdockw{Type}) (\coqdocvar{f}: \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{x} \coqdocvar{y}: \coqdocvar{A}), \coqdoceol
\coqdocindent{2.00em}
\coqdocvar{x} = \coqdocvar{y} \ensuremath{\rightarrow} \coqdocvar{f} \coqdocvar{x} = \coqdocvar{f} \coqdocvar{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f} \coqdocvar{x} \coqdocvar{y} \coqdocvar{eq}. \coqdoctac{rewrite} \coqdocvar{eq}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars, optional (practice)}

 A couple more nontrivial but not-too-complicated proofs to work
    together in class, or for you to work as exercises. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{beq\_nat\_0\_l} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.50em}
\coqdocvar{beq\_nat} 0 \coqdocvar{n} = \coqdocvar{true} \ensuremath{\rightarrow} \coqdocvar{n} = 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{beq\_nat\_0\_r} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.50em}
\coqdocvar{beq\_nat} \coqdocvar{n} 0 = \coqdocvar{true} \ensuremath{\rightarrow} \coqdocvar{n} = 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Using Tactics on Hypotheses}



 By default, most tactics work on the goal formula and leave
    the context unchanged.  However, most tactics also have a variant
    that performs a similar operation on a statement in the context.


    For example, the tactic \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H} performs simplification in
    the hypothesis named \coqdocvar{H} in the context. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{S\_inj} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}) (\coqdocvar{b} : \coqdocvar{bool}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{beq\_nat} (\coqdocvar{S} \coqdocvar{n}) (\coqdocvar{S} \coqdocvar{m}) = \coqdocvar{b}  \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{beq\_nat} \coqdocvar{n} \coqdocvar{m} = \coqdocvar{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m} \coqdocvar{b} \coqdocvar{H}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Similarly, the tactic \coqdoctac{apply} \coqdocvar{L} \coqdoctac{in} \coqdocvar{H} matches some
    conditional statement \coqdocvar{L} (of the form \coqdocvar{L1} \ensuremath{\rightarrow} \coqdocvar{L2}, say) against a
    hypothesis \coqdocvar{H} in the context.  However, unlike ordinary
    \coqdoctac{apply} (which rewrites a goal matching \coqdocvar{L2} into a subgoal \coqdocvar{L1}),
    \coqdoctac{apply} \coqdocvar{L} \coqdoctac{in} \coqdocvar{H} matches \coqdocvar{H} against \coqdocvar{L1} and, if successful,
    replaces it with \coqdocvar{L2}.


    In other words, \coqdoctac{apply} \coqdocvar{L} \coqdoctac{in} \coqdocvar{H} gives us a form of ``forward
    reasoning'' -- from \coqdocvar{L1} \ensuremath{\rightarrow} \coqdocvar{L2} and a hypothesis matching \coqdocvar{L1}, it
    gives us a hypothesis matching \coqdocvar{L2}.  By contrast, \coqdoctac{apply} \coqdocvar{L} is
    ``backward reasoning'' -- it says that if we know \coqdocvar{L1}\ensuremath{\rightarrow}\coqdocvar{L2} and we
    are trying to prove \coqdocvar{L2}, it suffices to prove \coqdocvar{L1}.  


    Here is a variant of a proof from above, using forward reasoning
    throughout instead of backward reasoning. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{silly3'} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{beq\_nat} \coqdocvar{n} 5 = \coqdocvar{true} \ensuremath{\rightarrow} \coqdocvar{beq\_nat} (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{n})) 7 = \coqdocvar{true}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{true} = \coqdocvar{beq\_nat} \coqdocvar{n} 5  \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{true} = \coqdocvar{beq\_nat} (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{n})) 7.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{eq} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{apply} \coqdocvar{eq} \coqdoctac{in} \coqdocvar{H}. \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Forward reasoning starts from what is \textit{given} (premises,
    previously proven theorems) and iteratively draws conclusions from
    them until the goal is reached.  Backward reasoning starts from
    the \textit{goal}, and iteratively reasons about what would imply the
    goal, until premises or previously proven theorems are reached.
    If you've seen informal proofs before (for example, in a math or
    computer science class), they probably used forward reasoning.  In
    general, Coq tends to favor backward reasoning, but in some
    situations the forward style can be easier to use or to think
    about.  

\paragraph{Exercise: 3 stars (plus\_n\_n\_injective)}

 Practice using ``in'' variants in this exercise. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_n\_n\_injective} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{n} + \coqdocvar{n} = \coqdocvar{m} + \coqdocvar{m} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{n} = \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Varying the Induction Hypothesis}



 Sometimes it is important to control the exact form of the
    induction hypothesis when carrying out inductive proofs in Coq.
    In particular, we need to be careful about which of the
    assumptions we move (using \coqdoctac{intros}) from the goal to the context
    before invoking the \coqdoctac{induction} tactic.  For example, suppose 
    we want to show that the \coqdocvar{double} function is injective -- i.e., 
    that it always maps different arguments to different results:  
    Theorem double\_injective: forall n m, double n = double m -> n = m. 
    The way we \textit{start} this proof is a little bit delicate: if we 
    begin it with
      intros n. induction n.
]] 
    all is well.  But if we begin it with
      intros n m. induction n.
    we get stuck in the middle of the inductive case... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{double\_injective\_FAILED} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{double} \coqdocvar{n} = \coqdocvar{double} \coqdocvar{m} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{n} = \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "n = O". \coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{eq}. \coqdoctac{destruct} \coqdocvar{m} \coqdockw{as} [| \coqdocvar{m'}].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "m = O". \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "m = S m'". \coqdoctac{inversion} \coqdocvar{eq}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "n = S n'". \coqdoctac{intros} \coqdocvar{eq}. \coqdoctac{destruct} \coqdocvar{m} \coqdockw{as} [| \coqdocvar{m'}].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "m = O". \coqdoctac{inversion} \coqdocvar{eq}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "m = S m'". \coqdoctac{apply} \coqdoctac{f\_equal}.\coqdoceol
\coqdocindent{3.00em}
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
What went wrong? 

 The problem is that, at the point we invoke the induction
    hypothesis, we have already introduced \coqdocvar{m} into the context -- 
    intuitively, we have told Coq, ``Let's consider some particular
    \coqdocvar{n} and \coqdocvar{m}...'' and we now have to prove that, if \coqdocvar{double} \coqdocvar{n} =
    \coqdocvar{double} \coqdocvar{m} for \textit{this particular} \coqdocvar{n} and \coqdocvar{m}, then \coqdocvar{n} = \coqdocvar{m}.


    The next tactic, \coqdoctac{induction} \coqdocvar{n} says to Coq: We are going to show
    the goal by induction on \coqdocvar{n}.  That is, we are going to prove that
    the proposition



\begin{itemize}
\item  \coqdocvar{P} \coqdocvar{n}  =  ``if \coqdocvar{double} \coqdocvar{n} = \coqdocvar{double} \coqdocvar{m}, then \coqdocvar{n} = \coqdocvar{m}''

\end{itemize}


    holds for all \coqdocvar{n} by showing



\begin{itemize}
\item  \coqdocvar{P} \coqdocvar{O}              


         (i.e., ``if \coqdocvar{double} \coqdocvar{O} = \coqdocvar{double} \coqdocvar{m} then \coqdocvar{O} = \coqdocvar{m}'')



\item  \coqdocvar{P} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{P} (\coqdocvar{S} \coqdocvar{n})  


        (i.e., ``if \coqdocvar{double} \coqdocvar{n} = \coqdocvar{double} \coqdocvar{m} then \coqdocvar{n} = \coqdocvar{m}'' implies ``if
        \coqdocvar{double} (\coqdocvar{S} \coqdocvar{n}) = \coqdocvar{double} \coqdocvar{m} then \coqdocvar{S} \coqdocvar{n} = \coqdocvar{m}'').

\end{itemize}


    If we look closely at the second statement, it is saying something
    rather strange: it says that, for a \textit{particular} \coqdocvar{m}, if we know



\begin{itemize}
\item  ``if \coqdocvar{double} \coqdocvar{n} = \coqdocvar{double} \coqdocvar{m} then \coqdocvar{n} = \coqdocvar{m}''

\end{itemize}


    then we can prove



\begin{itemize}
\item  ``if \coqdocvar{double} (\coqdocvar{S} \coqdocvar{n}) = \coqdocvar{double} \coqdocvar{m} then \coqdocvar{S} \coqdocvar{n} = \coqdocvar{m}''.

\end{itemize}


    To see why this is strange, let's think of a particular \coqdocvar{m} --
    say, 5.  The statement is then saying that, if we know



\begin{itemize}
\item  \coqdocvar{Q} = ``if \coqdocvar{double} \coqdocvar{n} = 10 then \coqdocvar{n} = 5''

\end{itemize}


    then we can prove



\begin{itemize}
\item  \coqdocvar{R} = ``if \coqdocvar{double} (\coqdocvar{S} \coqdocvar{n}) = 10 then \coqdocvar{S} \coqdocvar{n} = 5''.

\end{itemize}


    But knowing \coqdocvar{Q} doesn't give us any help with proving \coqdocvar{R}!  (If we
    tried to prove \coqdocvar{R} from \coqdocvar{Q}, we would say something like ``Suppose
    \coqdocvar{double} (\coqdocvar{S} \coqdocvar{n}) = 10...'' but then we'd be stuck: knowing that
    \coqdocvar{double} (\coqdocvar{S} \coqdocvar{n}) is 10 tells us nothing about whether \coqdocvar{double} \coqdocvar{n}
    is 10, so \coqdocvar{Q} is useless at this point.) 

 To summarize: Trying to carry out this proof by induction on \coqdocvar{n}
    when \coqdocvar{m} is already in the context doesn't work because we are
    trying to prove a relation involving \textit{every} \coqdocvar{n} but just a
    \textit{single} \coqdocvar{m}. 

 The good proof of \coqdocvar{double\_injective} leaves \coqdocvar{m} in the goal
    statement at the point where the \coqdoctac{induction} tactic is invoked on
    \coqdocvar{n}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{double\_injective} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{double} \coqdocvar{n} = \coqdocvar{double} \coqdocvar{m} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{n} = \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "n = O". \coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{m} \coqdocvar{eq}. \coqdoctac{destruct} \coqdocvar{m} \coqdockw{as} [| \coqdocvar{m'}].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "m = O". \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "m = S m'". \coqdoctac{inversion} \coqdocvar{eq}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "n = S n'".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{m} \coqdocvar{eq}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{m} \coqdockw{as} [| \coqdocvar{m'}].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "m = O".\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{inversion} \coqdocvar{eq}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "m = S m'".\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdoctac{f\_equal}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHn'}. \coqdoctac{inversion} \coqdocvar{eq}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
What this teaches us is that we need to be careful about using
    induction to try to prove something too specific: If we're proving
    a property of \coqdocvar{n} and \coqdocvar{m} by induction on \coqdocvar{n}, we may need to
    leave \coqdocvar{m} generic. 

 The proof of this theorem (left as an exercise) has to be treated similarly: 

\paragraph{Exercise: 2 stars (beq\_nat\_true)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{beq\_nat\_true} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{beq\_nat} \coqdocvar{n} \coqdocvar{m} = \coqdocvar{true} \ensuremath{\rightarrow} \coqdocvar{n} = \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars, advanced (beq\_nat\_true\_informal)}

 Give a careful informal proof of \coqdocvar{beq\_nat\_true}, being as explicit
    as possible about quantifiers. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

 The strategy of doing fewer \coqdoctac{intros} before an \coqdoctac{induction} doesn't
    always work directly; sometimes a little \textit{rearrangement} of
    quantified variables is needed.  Suppose, for example, that we
    wanted to prove \coqdocvar{double\_injective} by induction on \coqdocvar{m} instead of
    \coqdocvar{n}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{double\_injective\_take2\_FAILED} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{double} \coqdocvar{n} = \coqdocvar{double} \coqdocvar{m} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{n} = \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}. \coqdoctac{induction} \coqdocvar{m} \coqdockw{as} [| \coqdocvar{m'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "m = O". \coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{eq}. \coqdoctac{destruct} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "n = O". \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "n = S n'". \coqdoctac{inversion} \coqdocvar{eq}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "m = S m'". \coqdoctac{intros} \coqdocvar{eq}. \coqdoctac{destruct} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "n = O". \coqdoctac{inversion} \coqdocvar{eq}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "n = S n'". \coqdoctac{apply} \coqdoctac{f\_equal}.\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The problem is that, to do induction on \coqdocvar{m}, we must first
    introduce \coqdocvar{n}.  (If we simply say \coqdoctac{induction} \coqdocvar{m} without
    introducing anything first, Coq will automatically introduce
    \coqdocvar{n} for us!)   

 What can we do about this?  One possibility is to rewrite the
    statement of the lemma so that \coqdocvar{m} is quantified before \coqdocvar{n}.  This
    will work, but it's not nice: We don't want to have to mangle the
    statements of lemmas to fit the needs of a particular strategy for
    proving them -- we want to state them in the most clear and
    natural way. 

  What we can do instead is to first introduce all the
    quantified variables and then \textit{re-generalize} one or more of
    them, taking them out of the context and putting them back at
    the beginning of the goal.  The \coqdoctac{generalize} \coqdoctac{dependent} tactic
    does this. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{double\_injective\_take2} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{double} \coqdocvar{n} = \coqdocvar{double} \coqdocvar{m} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{n} = \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{m}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{m} \coqdockw{as} [| \coqdocvar{m'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "m = O". \coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{n} \coqdocvar{eq}. \coqdoctac{destruct} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "n = O". \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "n = S n'". \coqdoctac{inversion} \coqdocvar{eq}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "m = S m'". \coqdoctac{intros} \coqdocvar{n} \coqdocvar{eq}. \coqdoctac{destruct} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "n = O". \coqdoctac{inversion} \coqdocvar{eq}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "n = S n'". \coqdoctac{apply} \coqdoctac{f\_equal}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{IHm'}. \coqdoctac{inversion} \coqdocvar{eq}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Let's look at an informal proof of this theorem.  Note that
    the proposition we prove by induction leaves \coqdocvar{n} quantified,
    corresponding to the use of generalize dependent in our formal
    proof.


\textit{Theorem}: For any nats \coqdocvar{n} and \coqdocvar{m}, if \coqdocvar{double} \coqdocvar{n} = \coqdocvar{double} \coqdocvar{m}, then
  \coqdocvar{n} = \coqdocvar{m}.


\textit{Proof}: Let \coqdocvar{m} be a \coqdocvar{nat}. We prove by induction on \coqdocvar{m} that, for
  any \coqdocvar{n}, if \coqdocvar{double} \coqdocvar{n} = \coqdocvar{double} \coqdocvar{m} then \coqdocvar{n} = \coqdocvar{m}.



\begin{itemize}
\item  First, suppose \coqdocvar{m} = 0, and suppose \coqdocvar{n} is a number such
    that \coqdocvar{double} \coqdocvar{n} = \coqdocvar{double} \coqdocvar{m}.  We must show that \coqdocvar{n} = 0.


    Since \coqdocvar{m} = 0, by the definition of \coqdocvar{double} we have \coqdocvar{double} \coqdocvar{n} =
    0.  There are two cases to consider for \coqdocvar{n}.  If \coqdocvar{n} = 0 we are
    done, since this is what we wanted to show.  Otherwise, if \coqdocvar{n} = \coqdocvar{S}
    \coqdocvar{n'} for some \coqdocvar{n'}, we derive a contradiction: by the definition of
    \coqdocvar{double} we would have \coqdocvar{double} \coqdocvar{n} = \coqdocvar{S} (\coqdocvar{S} (\coqdocvar{double} \coqdocvar{n'})), but this
    contradicts the assumption that \coqdocvar{double} \coqdocvar{n} = 0.



\item  Otherwise, suppose \coqdocvar{m} = \coqdocvar{S} \coqdocvar{m'} and that \coqdocvar{n} is again a number such
    that \coqdocvar{double} \coqdocvar{n} = \coqdocvar{double} \coqdocvar{m}.  We must show that \coqdocvar{n} = \coqdocvar{S} \coqdocvar{m'}, with
    the induction hypothesis that for every number \coqdocvar{s}, if \coqdocvar{double} \coqdocvar{s} =
    \coqdocvar{double} \coqdocvar{m'} then \coqdocvar{s} = \coqdocvar{m'}.


    By the fact that \coqdocvar{m} = \coqdocvar{S} \coqdocvar{m'} and the definition of \coqdocvar{double}, we
    have \coqdocvar{double} \coqdocvar{n} = \coqdocvar{S} (\coqdocvar{S} (\coqdocvar{double} \coqdocvar{m'})).  There are two cases to
    consider for \coqdocvar{n}.


    If \coqdocvar{n} = 0, then by definition \coqdocvar{double} \coqdocvar{n} = 0, a contradiction.
    Thus, we may assume that \coqdocvar{n} = \coqdocvar{S} \coqdocvar{n'} for some \coqdocvar{n'}, and again by
    the definition of \coqdocvar{double} we have \coqdocvar{S} (\coqdocvar{S} (\coqdocvar{double} \coqdocvar{n'})) = \coqdocvar{S} (\coqdocvar{S}
    (\coqdocvar{double} \coqdocvar{m'})), which implies by inversion that \coqdocvar{double} \coqdocvar{n'} = \coqdocvar{double}
    \coqdocvar{m'}.


    Instantiating the induction hypothesis with \coqdocvar{n'} thus allows us to
    conclude that \coqdocvar{n'} = \coqdocvar{m'}, and it follows immediately that \coqdocvar{S} \coqdocvar{n'} = \coqdocvar{S}
    \coqdocvar{m'}.  Since \coqdocvar{S} \coqdocvar{n'} = \coqdocvar{n} and \coqdocvar{S} \coqdocvar{m'} = \coqdocvar{m}, this is just what we wanted
    to show. \ensuremath{\Box} 
\end{itemize}


 Here's another illustration of \coqdoctac{inversion} and using an
    appropriately general induction hypothesis.  This is a slightly
    roundabout way of stating a fact that we have already proved
    above.  The extra equalities force us to do a little more
    equational reasoning and exercise some of the tactics we've seen
    recently. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{length\_snoc'} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{v} : \coqdocvar{X})\coqdoceol
\coqdocindent{15.00em}
(\coqdocvar{l} : \coqdocvar{list} \coqdocvar{X}) (\coqdocvar{n} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{length} \coqdocvar{l} = \coqdocvar{n} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{length} (\coqdocvar{snoc} \coqdocvar{l} \coqdocvar{v}) = \coqdocvar{S} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{v} \coqdocvar{l}. \coqdoctac{induction} \coqdocvar{l} \coqdockw{as} [| \coqdocvar{v'} \coqdocvar{l'}].\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvar{Case} "l = []".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{eq}. \coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{eq}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvar{Case} "l = v' :: l'".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{eq}. \coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "n = 0". \coqdoctac{inversion} \coqdocvar{eq}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "n = S n'".\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdoctac{f\_equal}. \coqdoctac{apply} \coqdocvar{IHl'}. \coqdoctac{inversion} \coqdocvar{eq}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
It might be tempting to start proving the above theorem
    by introducing \coqdocvar{n} and \coqdocvar{eq} at the outset.  However, this leads
    to an induction hypothesis that is not strong enough.  Compare
    the above to the following (aborted) attempt: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{length\_snoc\_bad} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{v} : \coqdocvar{X})\coqdoceol
\coqdocindent{15.00em}
(\coqdocvar{l} : \coqdocvar{list} \coqdocvar{X}) (\coqdocvar{n} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{length} \coqdocvar{l} = \coqdocvar{n} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{length} (\coqdocvar{snoc} \coqdocvar{l} \coqdocvar{v}) = \coqdocvar{S} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{v} \coqdocvar{l} \coqdocvar{n} \coqdocvar{eq}. \coqdoctac{induction} \coqdocvar{l} \coqdockw{as} [| \coqdocvar{v'} \coqdocvar{l'}].\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvar{Case} "l = []".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{eq}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdocvar{Case} "l = v' :: l'".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}. \coqdoctac{destruct} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "n = 0". \coqdoctac{inversion} \coqdocvar{eq}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "n = S n'".\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdoctac{f\_equal}. \coqdockw{Abort}.  \coqdocemptyline
\end{coqdoccode}
As in the double examples, the problem is that by
    introducing \coqdocvar{n} before doing induction on \coqdocvar{l}, the induction
    hypothesis is specialized to one particular natural number, namely
    \coqdocvar{n}.  In the induction case, however, we need to be able to use
    the induction hypothesis on some other natural number \coqdocvar{n'}.
    Retaining the more general form of the induction hypothesis thus
    gives us more flexibility.


    In general, a good rule of thumb is to make the induction hypothesis
    as general as possible. 

\paragraph{Exercise: 3 stars (gen\_dep\_practice)}

 Prove this by induction on \coqdocvar{l}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{index\_after\_last}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqdocvar{nat}) (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{l} : \coqdocvar{list} \coqdocvar{X}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{length} \coqdocvar{l} = \coqdocvar{n} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{index} \coqdocvar{n} \coqdocvar{l} = \coqdocvar{None}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, advanced, optional (index\_after\_last\_informal)}

 Write an informal proof corresponding to your Coq proof
    of \coqdocvar{index\_after\_last}:


     \textit{Theorem}: For all sets \coqdocvar{X}, lists \coqdocvar{l} : \coqdocvar{list} \coqdocvar{X}, and numbers
      \coqdocvar{n}, if \coqdocvar{length} \coqdocvar{l} = \coqdocvar{n} then \coqdocvar{index} \coqdocvar{n} \coqdocvar{l} = \coqdocvar{None}.


     \textit{Proof}:
     \ensuremath{\Box}


\paragraph{Exercise: 3 stars, optional (gen\_dep\_practice\_more)}

 Prove this by induction on \coqdocvar{l}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{length\_snoc'{}'{}'} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqdocvar{nat}) (\coqdocvar{X} : \coqdockw{Type}) \coqdoceol
\coqdocindent{15.00em}
(\coqdocvar{v} : \coqdocvar{X}) (\coqdocvar{l} : \coqdocvar{list} \coqdocvar{X}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{length} \coqdocvar{l} = \coqdocvar{n} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{length} (\coqdocvar{snoc} \coqdocvar{l} \coqdocvar{v}) = \coqdocvar{S} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, optional (app\_length\_cons)}

 Prove this by induction on \coqdocvar{l1}, without using \coqdocvar{app\_length}
    from \coqdocvar{Lists}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{app\_length\_cons} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{l1} \coqdocvar{l2} : \coqdocvar{list} \coqdocvar{X}) \coqdoceol
\coqdocindent{17.00em}
(\coqdocvar{x} : \coqdocvar{X}) (\coqdocvar{n} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{length} (\coqdocvar{l1} ++ (\coqdocvar{x} :: \coqdocvar{l2})) = \coqdocvar{n} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{S} (\coqdocvar{length} (\coqdocvar{l1} ++ \coqdocvar{l2})) = \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 4 stars, optional (app\_length\_twice)}

 Prove this by induction on \coqdocvar{l}, without using app\_length. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{app\_length\_twice} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{n}:\coqdocvar{nat}) (\coqdocvar{l}:\coqdocvar{list} \coqdocvar{X}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{length} \coqdocvar{l} = \coqdocvar{n} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{length} (\coqdocvar{l} ++ \coqdocvar{l}) = \coqdocvar{n} + \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, optional (double\_induction)}

 Prove the following principle of induction over two naturals. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{double\_induction}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{P} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop}), \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{P} 0 0 \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{m}, \coqdocvar{P} \coqdocvar{m} 0 \ensuremath{\rightarrow} \coqdocvar{P} (\coqdocvar{S} \coqdocvar{m}) 0) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{P} 0 \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{P} 0 (\coqdocvar{S} \coqdocvar{n})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n}, \coqdocvar{P} \coqdocvar{m} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{P} (\coqdocvar{S} \coqdocvar{m}) (\coqdocvar{S} \coqdocvar{n})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n}, \coqdocvar{P} \coqdocvar{m} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Using \texorpdfstring{\protect\coqdoctac{destruct}}{destruct} on Compound Expressions}



 We have seen many examples where the \coqdoctac{destruct} tactic is
    used to perform case analysis of the value of some variable.  But
    sometimes we need to reason by cases on the result of some
    \textit{expression}.  We can also do this with \coqdoctac{destruct}.


    Here are some examples: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{sillyfun} (\coqdocvar{n} : \coqdocvar{nat}) : \coqdocvar{bool} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{if} \coqdocvar{beq\_nat} \coqdocvar{n} 3 \coqdockw{then} \coqdocvar{false}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{else} \coqdockw{if} \coqdocvar{beq\_nat} \coqdocvar{n} 5 \coqdockw{then} \coqdocvar{false}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{else} \coqdocvar{false}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{sillyfun\_false} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{sillyfun} \coqdocvar{n} = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}. \coqdoctac{unfold} \coqdocvar{sillyfun}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{beq\_nat} \coqdocvar{n} 3).\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "beq\_nat n 3 = true". \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "beq\_nat n 3 = false". \coqdoctac{destruct} (\coqdocvar{beq\_nat} \coqdocvar{n} 5).\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{SCase} "beq\_nat n 5 = true". \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{SCase} "beq\_nat n 5 = false". \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
After unfolding \coqdocvar{sillyfun} in the above proof, we find that
    we are stuck on \coqdockw{if} (\coqdocvar{beq\_nat} \coqdocvar{n} 3) \coqdockw{then} ... \coqdockw{else} ....  Well,
    either \coqdocvar{n} is equal to 3 or it isn't, so we use \coqdoctac{destruct}
    (\coqdocvar{beq\_nat} \coqdocvar{n} 3) to let us reason about the two cases. 


    In general, the \coqdoctac{destruct} tactic can be used to perform case
    analysis of the results of arbitrary computations.  If \coqdocvar{e} is an
    expression whose type is some inductively defined type \coqdocvar{T}, then,
    for each constructor \coqdocvar{c} of \coqdocvar{T}, \coqdoctac{destruct} \coqdocvar{e} generates a subgoal
    in which all occurrences of \coqdocvar{e} (in the goal and in the context)
    are replaced by \coqdocvar{c}.




\paragraph{Exercise: 1 star (override\_shadow)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{override\_shadow} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) \coqdocvar{x1} \coqdocvar{x2} \coqdocvar{k1} \coqdocvar{k2} (\coqdocvar{f} : \coqdocvar{nat}\ensuremath{\rightarrow}\coqdocvar{X}),\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{override} (\coqdocvar{override} \coqdocvar{f} \coqdocvar{k1} \coqdocvar{x2}) \coqdocvar{k1} \coqdocvar{x1}) \coqdocvar{k2} = (\coqdocvar{override} \coqdocvar{f} \coqdocvar{k1} \coqdocvar{x1}) \coqdocvar{k2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, optional (combine\_split)}

 Complete the proof below \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{combine\_split} : \coqdockw{\ensuremath{\forall}} \coqdocvar{X} \coqdocvar{Y} (\coqdocvar{l} : \coqdocvar{list} (\coqdocvar{X} \ensuremath{\times} \coqdocvar{Y})) \coqdocvar{l1} \coqdocvar{l2},\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split} \coqdocvar{l} = (\coqdocvar{l1}, \coqdocvar{l2}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{combine} \coqdocvar{l1} \coqdocvar{l2} = \coqdocvar{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 Sometimes, doing a \coqdoctac{destruct} on a compound expression (a
    non-variable) will erase information we need to complete a proof.  For example, suppose
    we define a function \coqdocvar{sillyfun1} like this: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{sillyfun1} (\coqdocvar{n} : \coqdocvar{nat}) : \coqdocvar{bool} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{if} \coqdocvar{beq\_nat} \coqdocvar{n} 3 \coqdockw{then} \coqdocvar{true}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{else} \coqdockw{if} \coqdocvar{beq\_nat} \coqdocvar{n} 5 \coqdockw{then} \coqdocvar{true}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{else} \coqdocvar{false}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
And suppose that we want to convince Coq of the rather
    obvious observation that \coqdocvar{sillyfun1} \coqdocvar{n} yields \coqdocvar{true} only when \coqdocvar{n}
    is odd.  By analogy with the proofs we did with \coqdocvar{sillyfun} above,
    it is natural to start the proof like this: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{sillyfun1\_odd\_FAILED} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{sillyfun1} \coqdocvar{n} = \coqdocvar{true} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{oddb} \coqdocvar{n} = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{eq}. \coqdoctac{unfold} \coqdocvar{sillyfun1} \coqdoctac{in} \coqdocvar{eq}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{beq\_nat} \coqdocvar{n} 3).\coqdoceol
\coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We get stuck at this point because the context does not
    contain enough information to prove the goal!  The problem is that
    the substitution peformed by \coqdoctac{destruct} is too brutal -- it threw
    away every occurrence of \coqdocvar{beq\_nat} \coqdocvar{n} 3, but we need to keep some
    memory of this expression and how it was destructed, because we
    need to be able to reason that since, in this branch of the case
    analysis, \coqdocvar{beq\_nat} \coqdocvar{n} 3 = \coqdocvar{true}, it must be that \coqdocvar{n} = 3, from
    which it follows that \coqdocvar{n} is odd.


    What we would really like is to substitute away all existing
    occurences of \coqdocvar{beq\_nat} \coqdocvar{n} 3, but at the same time add an equation
    to the context that records which case we are in.  The \coqdocvar{eqn}:
    qualifier allows us to introduce such an equation (with whatever
    name we choose). \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{sillyfun1\_odd} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{sillyfun1} \coqdocvar{n} = \coqdocvar{true} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{oddb} \coqdocvar{n} = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{eq}. \coqdoctac{unfold} \coqdocvar{sillyfun1} \coqdoctac{in} \coqdocvar{eq}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{beq\_nat} \coqdocvar{n} 3) \coqdocvar{eqn}:\coqdocvar{Heqe3}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "e3 = true". \coqdoctac{apply} \coqdocvar{beq\_nat\_true} \coqdoctac{in} \coqdocvar{Heqe3}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{Heqe3}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "e3 = false".\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} (\coqdocvar{beq\_nat} \coqdocvar{n} 5) \coqdocvar{eqn}:\coqdocvar{Heqe5}.\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{SCase} "e5 = true".\coqdoceol
\coqdocindent{5.00em}
\coqdoctac{apply} \coqdocvar{beq\_nat\_true} \coqdoctac{in} \coqdocvar{Heqe5}.\coqdoceol
\coqdocindent{5.00em}
\coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{Heqe5}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{SCase} "e5 = false". \coqdoctac{inversion} \coqdocvar{eq}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars (destruct\_eqn\_practice)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{bool\_fn\_applied\_thrice} : \coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{f} : \coqdocvar{bool} \ensuremath{\rightarrow} \coqdocvar{bool}) (\coqdocvar{b} : \coqdocvar{bool}), \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{f} (\coqdocvar{f} (\coqdocvar{f} \coqdocvar{b})) = \coqdocvar{f} \coqdocvar{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars (override\_same)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{override\_same} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) \coqdocvar{x1} \coqdocvar{k1} \coqdocvar{k2} (\coqdocvar{f} : \coqdocvar{nat}\ensuremath{\rightarrow}\coqdocvar{X}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{f} \coqdocvar{k1} = \coqdocvar{x1} \ensuremath{\rightarrow} \coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{override} \coqdocvar{f} \coqdocvar{k1} \coqdocvar{x1}) \coqdocvar{k2} = \coqdocvar{f} \coqdocvar{k2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Review}



 We've now seen a bunch of Coq's fundamental tactics.  We'll
    introduce a few more as we go along through the coming lectures,
    and later in the course we'll introduce some more powerful
    \textit{automation} tactics that make Coq do more of the low-level work
    in many cases.  But basically we've got what we need to get work
    done.


    Here are the ones we've seen:



\begin{itemize}
\item  \coqdoctac{intros}: 
        move hypotheses/variables from goal to context 



\item  \coqdoctac{reflexivity}:
        finish the proof (when the goal looks like \coqdocvar{e} = \coqdocvar{e})



\item  \coqdoctac{apply}:
        prove goal using a hypothesis, lemma, or constructor



\item  \coqdoctac{apply}... \coqdoctac{in} \coqdocvar{H}: 
        apply a hypothesis, lemma, or constructor to a hypothesis in
        the context (forward reasoning)



\item  \coqdoctac{apply}... \coqdockw{with}...:
        explicitly specify values for variables that cannot be
        determined by pattern matching



\item  \coqdoctac{simpl}:
        simplify computations in the goal 



\item  \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{H}:
        ... or a hypothesis 



\item  \coqdoctac{rewrite}:
        use an equality hypothesis (or lemma) to rewrite the goal 



\item  \coqdoctac{rewrite} ... \coqdoctac{in} \coqdocvar{H}:
        ... or a hypothesis 



\item  \coqdoctac{symmetry}:
        changes a goal of the form \coqdocvar{t}=\coqdocvar{u} into \coqdocvar{u}=\coqdocvar{t}



\item  \coqdoctac{symmetry} \coqdoctac{in} \coqdocvar{H}:
        changes a hypothesis of the form \coqdocvar{t}=\coqdocvar{u} into \coqdocvar{u}=\coqdocvar{t}



\item  \coqdoctac{unfold}:
        replace a defined constant by its right-hand side in the goal 



\item  \coqdoctac{unfold}... \coqdoctac{in} \coqdocvar{H}:
        ... or a hypothesis  



\item  \coqdoctac{destruct}... \coqdockw{as}...:
        case analysis on values of inductively defined types 



\item  \coqdoctac{destruct}... \coqdocvar{eqn}:...:
        specify the name of an equation to be added to the context,
        recording the result of the case analysis



\item  \coqdoctac{induction}... \coqdockw{as}...:
        induction on values of inductively defined types 



\item  \coqdoctac{inversion}:
        reason by injectivity and distinctness of constructors



\item  \coqdoctac{assert} (\coqdocvar{e}) \coqdockw{as} \coqdocvar{H}:
        introduce a ``local lemma'' \coqdocvar{e} and call it \coqdocvar{H} 



\item  \coqdoctac{generalize} \coqdoctac{dependent} \coqdocvar{x}:
        move the variable \coqdocvar{x} (and anything else that depends on it)
        from the context back to an explicit hypothesis in the goal
        formula 

\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Additional Exercises}



\paragraph{Exercise: 3 stars (beq\_nat\_sym)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{beq\_nat\_sym} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beq\_nat} \coqdocvar{n} \coqdocvar{m} = \coqdocvar{beq\_nat} \coqdocvar{m} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, advanced, optional (beq\_nat\_sym\_informal)}

 Give an informal proof of this lemma that corresponds to your
    formal proof above:


   Theorem: For any \coqdocvar{nat}s \coqdocvar{n} \coqdocvar{m}, \coqdocvar{beq\_nat} \coqdocvar{n} \coqdocvar{m} = \coqdocvar{beq\_nat} \coqdocvar{m} \coqdocvar{n}.


   Proof:
   \ensuremath{\Box}
 

\paragraph{Exercise: 3 stars, optional (beq\_nat\_trans)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{beq\_nat\_trans} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beq\_nat} \coqdocvar{n} \coqdocvar{m} = \coqdocvar{true} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beq\_nat} \coqdocvar{m} \coqdocvar{p} = \coqdocvar{true} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beq\_nat} \coqdocvar{n} \coqdocvar{p} = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, advanced (split\_combine)}

 We have just proven that for all lists of pairs, \coqdocvar{combine} is the
    inverse of \coqdoctac{split}.  How would you formalize the statement that
    \coqdoctac{split} is the inverse of \coqdocvar{combine}? When is this property true?


    Complete the definition of \coqdocvar{split\_combine\_statement} below with a
    property that states that \coqdoctac{split} is the inverse of
    \coqdocvar{combine}. Then, prove that the property holds. (Be sure to leave
    your induction hypothesis general by not doing \coqdoctac{intros} on more
    things than necessary.  Hint: what property do you need of \coqdocvar{l1}
    and \coqdocvar{l2} for \coqdoctac{split} \coqdocvar{combine} \coqdocvar{l1} \coqdocvar{l2} = (\coqdocvar{l1},\coqdocvar{l2}) to be true?)  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{split\_combine\_statement} : \coqdockw{Prop} :=\coqdoceol
\coqdocnoindent
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{split\_combine} : \coqdocvar{split\_combine\_statement}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars (override\_permute)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{override\_permute} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) \coqdocvar{x1} \coqdocvar{x2} \coqdocvar{k1} \coqdocvar{k2} \coqdocvar{k3} (\coqdocvar{f} : \coqdocvar{nat}\ensuremath{\rightarrow}\coqdocvar{X}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beq\_nat} \coqdocvar{k2} \coqdocvar{k1} = \coqdocvar{false} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{override} (\coqdocvar{override} \coqdocvar{f} \coqdocvar{k2} \coqdocvar{x2}) \coqdocvar{k1} \coqdocvar{x1}) \coqdocvar{k3} = (\coqdocvar{override} (\coqdocvar{override} \coqdocvar{f} \coqdocvar{k1} \coqdocvar{x1}) \coqdocvar{k2} \coqdocvar{x2}) \coqdocvar{k3}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, advanced (filter\_exercise)}

 This one is a bit challenging.  Pay attention to the form of your IH. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{filter\_exercise} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{test} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{bool})\coqdoceol
\coqdocindent{14.50em}
(\coqdocvar{x} : \coqdocvar{X}) (\coqdocvar{l} \coqdocvar{lf} : \coqdocvar{list} \coqdocvar{X}),\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{filter} \coqdocvar{test} \coqdocvar{l} = \coqdocvar{x} :: \coqdocvar{lf} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{test} \coqdocvar{x} = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 4 stars, advanced (forall\_exists\_challenge)}

 Define two recursive \coqdocvar{Fixpoints}, \coqdocvar{forallb} and \coqdocvar{existsb}.  The
    first checks whether every element in a list satisfies a given
    predicate:
      forallb oddb 1;3;5;7;9 = true


      forallb negb \coqdocvar{false};\coqdocvar{false} = true


      forallb evenb 0;2;4;5 = false


      forallb (beq\_nat 5) \ensuremath{\Box} = true
    The second checks whether there exists an element in the list that
    satisfies a given predicate:
      existsb (beq\_nat 5) 0;2;3;6 = false


      existsb (andb true) \coqdocvar{true};\coqdocvar{true};\coqdocvar{false} = true


      existsb oddb 1;0;0;0;0;3 = true


      existsb evenb \ensuremath{\Box} = false
    Next, define a \textit{nonrecursive} version of \coqdocvar{existsb} -- call it
    \coqdocvar{existsb'} -- using \coqdocvar{forallb} and \coqdocvar{negb}.


    Prove theorem \coqdocvar{existsb\_existsb'} that \coqdocvar{existsb'} and \coqdocvar{existsb} have
    the same behavior.
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

 $Date: 2014-12-31 16:01:37 -0500 (Wed, 31 Dec 2014) $ \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{Top.Logic}{Library }{Top.Logic}

\begin{coqdoccode}
\end{coqdoccode}
\section{Logic: Logic in Coq}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqdocvar{MoreCoq}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Coq's built-in logic is very small: the only primitives are
    \coqdockw{Inductive} definitions, universal quantification (\coqdockw{\ensuremath{\forall}}), and
    implication (\ensuremath{\rightarrow}), while all the other familiar logical
    connectives -- conjunction, disjunction, negation, existential
    quantification, even equality -- can be encoded using just these.


    This chapter explains the encodings and shows how the tactics
    we've seen can be used to carry out standard forms of logical
    reasoning involving these connectives.


\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Propositions}



 In previous chapters, we have seen many examples of factual
    claims (\textit{propositions}) and ways of presenting evidence of their
    truth (\textit{proofs}).  In particular, we have worked extensively with
    \textit{equality propositions} of the form \coqdocvar{e1} = \coqdocvar{e2}, with
    implications (\coqdocvar{P} \ensuremath{\rightarrow} \coqdocvar{Q}), and with quantified propositions 
    (\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{P}).  


 In Coq, the type of things that can (potentially) 
    be proven is \coqdockw{Prop}. 

 Here is an example of a provable proposition: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (3 = 3).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is an example of an unprovable proposition: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqdockw{\ensuremath{\forall}} (\coqdocvar{n}:\coqdocvar{nat}), \coqdocvar{n} = 2).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Recall that \coqdockw{Check} asks Coq to tell us the type of the indicated 
  expression. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Proofs and Evidence}



 In Coq, propositions have the same status as other types, such as
    \coqdocvar{nat}.  Just as the natural numbers 0, 1, 2, etc. inhabit
    the type \coqdocvar{nat}, a Coq proposition \coqdocvar{P} is inhabited by its
    \textit{proofs}.  We will refer to such inhabitants as \textit{proof term} or
    \textit{proof object} or \textit{evidence} for the truth of \coqdocvar{P}. 


    In Coq, when we state and then prove a lemma such as:


Lemma silly : 0 * 3 = 0.  
Proof. reflexivity. Qed.


    the tactics we use within the \coqdockw{Proof}...\coqdockw{Qed} keywords tell Coq
    how to construct a proof term that inhabits the proposition.  In
    this case, the proposition 0 \ensuremath{\times} 3 = 0 is justified by a
    combination of the \textit{definition} of \coqdocvar{mult}, which says that 0 \ensuremath{\times} 3
    \textit{simplifies} to just 0, and the \textit{reflexive} principle of
    equality, which says that 0 = 0.




\subsubsection{ }

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{silly} : 0 \ensuremath{\times} 3 = 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can see which proof term Coq constructs for a given Lemma by
using the \coqdockw{Print} directive: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqdocvar{silly}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here, the \coqdocvar{eq\_refl} proof term witnesses the equality. (More on
equality later!)

\subsection{Implications \textit{are} functions}



 Just as we can implement natural number multiplication as a
function:



\coqdocvar{mult} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat} 



The \textit{proof term} for an implication \coqdocvar{P} \ensuremath{\rightarrow} \coqdocvar{Q} is a \textit{function} that
takes evidence for \coqdocvar{P} as input and produces evidence for \coqdocvar{Q} as its
output.
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{silly\_implication} : (1 + 1) = 2  \ensuremath{\rightarrow}  0 \ensuremath{\times} 3 = 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{intros} \coqdocvar{H}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can see that the proof term for the above lemma is indeed a
function: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqdocvar{silly\_implication}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Defining propositions}



 Just as we can create user-defined inductive types (like the
    lists, binary representations of natural numbers, etc., that we
    seen before), we can also create \textit{user-defined} propositions.


    Question: How do you define the meaning of a proposition?  


\subsubsection{ }



 The meaning of a proposition is given by \textit{rules} and \textit{definitions}
    that say how to construct \textit{evidence} for the truth of the
    proposition from other evidence.



\begin{itemize}
\item  Typically, rules are defined \textit{inductively}, just like any other
      datatype.



\item  Sometimes a proposition is declared to be true without
      substantiating evidence.  Such propositions are called \textit{axioms}.

\end{itemize}
    In this, and subsequence chapters, we'll see more about how these
    proof terms work in more detail.
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Conjunction (Logical ``and'')}



 The logical conjunction of propositions \coqdocvar{P} and \coqdocvar{Q} can be
    represented using an \coqdockw{Inductive} definition with one
    constructor. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{and} (\coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{conj} : \coqdocvar{P} \ensuremath{\rightarrow} \coqdocvar{Q} \ensuremath{\rightarrow} (\coqdocvar{and} \coqdocvar{P} \coqdocvar{Q}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The intuition behind this definition is simple: to
    construct evidence for \coqdocvar{and} \coqdocvar{P} \coqdocvar{Q}, we must provide evidence
    for \coqdocvar{P} and evidence for \coqdocvar{Q}.  More precisely:



\begin{itemize}
\item  \coqdocvar{conj} \coqdocvar{p} \coqdocvar{q} can be taken as evidence for \coqdocvar{and} \coqdocvar{P} \coqdocvar{Q} if \coqdocvar{p}
      is evidence for \coqdocvar{P} and \coqdocvar{q} is evidence for \coqdocvar{Q}; and



\item  this is the \textit{only} way to give evidence for \coqdocvar{and} \coqdocvar{P} \coqdocvar{Q} --
      that is, if someone gives us evidence for \coqdocvar{and} \coqdocvar{P} \coqdocvar{Q}, we
      know it must have the form \coqdocvar{conj} \coqdocvar{p} \coqdocvar{q}, where \coqdocvar{p} is
      evidence for \coqdocvar{P} and \coqdocvar{q} is evidence for \coqdocvar{Q}. 

\end{itemize}


   Since we'll be using conjunction a lot, let's introduce a more
   familiar-looking infix notation for it. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "P /\symbol{92} Q" := (\coqdocvar{and} \coqdocvar{P} \coqdocvar{Q}) : \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
(The \coqdocvar{type\_scope} annotation tells Coq that this notation
    will be appearing in propositions, not values.) 

 Consider the ``type'' of the constructor \coqdocvar{conj}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{conj}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Notice that it takes 4 inputs -- namely the propositions \coqdocvar{P}
    and \coqdocvar{Q} and evidence for \coqdocvar{P} and \coqdocvar{Q} -- and returns as output the
    evidence of \coqdocvar{P} \ensuremath{\land} \coqdocvar{Q}. 

\subsection{``Introducing'' conjunctions}

 Besides the elegance of building everything up from a tiny
    foundation, what's nice about defining conjunction this way is
    that we can prove statements involving conjunction using the
    tactics that we already know.  For example, if the goal statement
    is a conjuction, we can prove it by applying the single
    constructor \coqdocvar{conj}, which (as can be seen from the type of \coqdocvar{conj})
    solves the current goal and leaves the two parts of the
    conjunction as subgoals to be proved separately. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{and\_example} : \coqdoceol
\coqdocindent{1.00em}
(0 = 0) \ensuremath{\land} (4 = \coqdocvar{mult} 2 2).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{conj}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "left". \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "right". \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Just for convenience, we can use the tactic \coqdoctac{split} as a shorthand for
    \coqdoctac{apply} \coqdocvar{conj}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{and\_example'} : \coqdoceol
\coqdocindent{1.00em}
(0 = 0) \ensuremath{\land} (4 = \coqdocvar{mult} 2 2).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "left". \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "right". \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{``Eliminating'' conjunctions}

 Conversely, the \coqdoctac{destruct} tactic can be used to take a
    conjunction hypothesis in the context, calculate what evidence
    must have been used to build it, and add variables representing
    this evidence to the proof context. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{proj1} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{P} \ensuremath{\land} \coqdocvar{Q} \ensuremath{\rightarrow} \coqdocvar{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{HP} \coqdocvar{HQ}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{HP}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star, optional (proj2)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{proj2} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{P} \ensuremath{\land} \coqdocvar{Q} \ensuremath{\rightarrow} \coqdocvar{Q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{and\_commut} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{P} \ensuremath{\land} \coqdocvar{Q} \ensuremath{\rightarrow} \coqdocvar{Q} \ensuremath{\land} \coqdocvar{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{HP} \coqdocvar{HQ}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "left". \coqdoctac{apply} \coqdocvar{HQ}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "right". \coqdoctac{apply} \coqdocvar{HP}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars (and\_assoc)}

 In the following proof, notice how the \textit{nested pattern} in the
    \coqdoctac{destruct} breaks the hypothesis \coqdocvar{H} : \coqdocvar{P} \ensuremath{\land} (\coqdocvar{Q} \ensuremath{\land} \coqdocvar{R}) down into
    \coqdocvar{HP}: \coqdocvar{P}, \coqdocvar{HQ} : \coqdocvar{Q}, and \coqdocvar{HR} : \coqdocvar{R}.  Finish the proof from there: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{and\_assoc} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} : \coqdockw{Prop}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{P} \ensuremath{\land} (\coqdocvar{Q} \ensuremath{\land} \coqdocvar{R}) \ensuremath{\rightarrow} (\coqdocvar{P} \ensuremath{\land} \coqdocvar{Q}) \ensuremath{\land} \coqdocvar{R}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{HP} [\coqdocvar{HQ} \coqdocvar{HR}]].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Iff}



 The handy ``if and only if'' connective is just the conjunction of
    two implications. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{iff} (\coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}) := (\coqdocvar{P} \ensuremath{\rightarrow} \coqdocvar{Q}) \ensuremath{\land} (\coqdocvar{Q} \ensuremath{\rightarrow} \coqdocvar{P}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "P <-> Q" := (\coqdocvar{iff} \coqdocvar{P} \coqdocvar{Q}) \coqdoceol
\coqdocindent{11.00em}
(\coqdoctac{at} \coqdockw{level} 95, \coqdockw{no} \coqdockw{associativity}) \coqdoceol
\coqdocindent{11.00em}
: \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{iff\_implies} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}, \coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{P} \ensuremath{\leftrightarrow} \coqdocvar{Q}) \ensuremath{\rightarrow} \coqdocvar{P} \ensuremath{\rightarrow} \coqdocvar{Q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{HAB} \coqdocvar{HBA}]. \coqdoctac{apply} \coqdocvar{HAB}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{iff\_sym} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}, \coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{P} \ensuremath{\leftrightarrow} \coqdocvar{Q}) \ensuremath{\rightarrow} (\coqdocvar{Q} \ensuremath{\leftrightarrow} \coqdocvar{P}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{HAB} \coqdocvar{HBA}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "->". \coqdoctac{apply} \coqdocvar{HBA}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "<-". \coqdoctac{apply} \coqdocvar{HAB}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star, optional (iff\_properties)}

 Using the above proof that \ensuremath{\leftrightarrow} is symmetric (\coqdocvar{iff\_sym}) as
    a guide, prove that it is also reflexive and transitive. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{iff\_refl} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} : \coqdockw{Prop}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{P} \ensuremath{\leftrightarrow} \coqdocvar{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{iff\_trans} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} : \coqdockw{Prop}, \coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{P} \ensuremath{\leftrightarrow} \coqdocvar{Q}) \ensuremath{\rightarrow} (\coqdocvar{Q} \ensuremath{\leftrightarrow} \coqdocvar{R}) \ensuremath{\rightarrow} (\coqdocvar{P} \ensuremath{\leftrightarrow} \coqdocvar{R}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Hint: If you have an iff hypothesis in the context, you can use
    \coqdoctac{inversion} to break it into two separate implications.  (Think
    about why this works.)  \ensuremath{\Box} 

 Some of Coq's tactics treat \coqdocvar{iff} statements specially, thus
    avoiding the need for some low-level manipulation when reasoning
    with them.  In particular, \coqdoctac{rewrite} can be used with \coqdocvar{iff}
    statements, not just equalities. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Disjunction (Logical ``or'')}



\subsection{Implementing disjunction}



 Disjunction (``logical or'') can also be defined as an
    inductive proposition. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{or} (\coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{or\_introl} : \coqdocvar{P} \ensuremath{\rightarrow} \coqdocvar{or} \coqdocvar{P} \coqdocvar{Q}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{or\_intror} : \coqdocvar{Q} \ensuremath{\rightarrow} \coqdocvar{or} \coqdocvar{P} \coqdocvar{Q}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "P \symbol{92}/ Q" := (\coqdocvar{or} \coqdocvar{P} \coqdocvar{Q}) : \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Consider the ``type'' of the constructor \coqdocvar{or\_introl}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{or\_introl}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
It takes 3 inputs, namely the propositions \coqdocvar{P}, \coqdocvar{Q} and
    evidence of \coqdocvar{P}, and returns, as output, the evidence of \coqdocvar{P} \ensuremath{\lor} \coqdocvar{Q}.
    Next, look at the type of \coqdocvar{or\_intror}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{or\_intror}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
It is like \coqdocvar{or\_introl} but it requires evidence of \coqdocvar{Q}
    instead of evidence of \coqdocvar{P}. 

 Intuitively, there are two ways of giving evidence for \coqdocvar{P} \ensuremath{\lor} \coqdocvar{Q}:



\begin{itemize}
\item  give evidence for \coqdocvar{P} (and say that it is \coqdocvar{P} you are giving
      evidence for -- this is the function of the \coqdocvar{or\_introl}
      constructor), or



\item  give evidence for \coqdocvar{Q}, tagged with the \coqdocvar{or\_intror}
      constructor. 
\end{itemize}


\subsubsection{ }

 Since \coqdocvar{P} \ensuremath{\lor} \coqdocvar{Q} has two constructors, doing \coqdoctac{destruct} on a
    hypothesis of type \coqdocvar{P} \ensuremath{\lor} \coqdocvar{Q} yields two subgoals. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{or\_commut} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{P} \ensuremath{\lor} \coqdocvar{Q}  \ensuremath{\rightarrow} \coqdocvar{Q} \ensuremath{\lor} \coqdocvar{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{HP} \ensuremath{|} \coqdocvar{HQ}].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "left". \coqdoctac{apply} \coqdocvar{or\_intror}. \coqdoctac{apply} \coqdocvar{HP}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "right". \coqdoctac{apply} \coqdocvar{or\_introl}. \coqdoctac{apply} \coqdocvar{HQ}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
From here on, we'll use the shorthand tactics \coqdoctac{left} and \coqdoctac{right}
    in place of \coqdoctac{apply} \coqdocvar{or\_introl} and \coqdoctac{apply} \coqdocvar{or\_intror}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{or\_commut'} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{P} \ensuremath{\lor} \coqdocvar{Q}  \ensuremath{\rightarrow} \coqdocvar{Q} \ensuremath{\lor} \coqdocvar{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{HP} \ensuremath{|} \coqdocvar{HQ}].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "left". \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{HP}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "right". \coqdoctac{left}. \coqdoctac{apply} \coqdocvar{HQ}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{or\_distributes\_over\_and\_1} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{P} \ensuremath{\lor} (\coqdocvar{Q} \ensuremath{\land} \coqdocvar{R}) \ensuremath{\rightarrow} (\coqdocvar{P} \ensuremath{\lor} \coqdocvar{Q}) \ensuremath{\land} (\coqdocvar{P} \ensuremath{\lor} \coqdocvar{R}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R}. \coqdoctac{intros} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{HP} \ensuremath{|} [\coqdocvar{HQ} \coqdocvar{HR}]].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "left". \coqdoctac{split}.\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{SCase} "left". \coqdoctac{left}. \coqdoctac{apply} \coqdocvar{HP}.\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{SCase} "right". \coqdoctac{left}. \coqdoctac{apply} \coqdocvar{HP}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "right". \coqdoctac{split}.\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{SCase} "left". \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{HQ}.\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{SCase} "right". \coqdoctac{right}. \coqdoctac{apply} \coqdocvar{HR}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars (or\_distributes\_over\_and\_2)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{or\_distributes\_over\_and\_2} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{P} \ensuremath{\lor} \coqdocvar{Q}) \ensuremath{\land} (\coqdocvar{P} \ensuremath{\lor} \coqdocvar{R}) \ensuremath{\rightarrow} \coqdocvar{P} \ensuremath{\lor} (\coqdocvar{Q} \ensuremath{\land} \coqdocvar{R}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 1 star, optional (or\_distributes\_over\_and)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{or\_distributes\_over\_and} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{P} \ensuremath{\lor} (\coqdocvar{Q} \ensuremath{\land} \coqdocvar{R}) \ensuremath{\leftrightarrow} (\coqdocvar{P} \ensuremath{\lor} \coqdocvar{Q}) \ensuremath{\land} (\coqdocvar{P} \ensuremath{\lor} \coqdocvar{R}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Relating \ensuremath{\land} and \ensuremath{\lor} with \texorpdfstring{\protect}{andb}\coqdocvar{andb} and \texorpdfstring{\protect}{orb}\coqdocvar{orb}}



 We've already seen several places where analogous structures
    can be found in Coq's computational (\coqdockw{Type}) and logical (\coqdockw{Prop})
    worlds.  Here is one more: the boolean operators \coqdocvar{andb} and \coqdocvar{orb}
    are clearly analogs of the logical connectives \ensuremath{\land} and \ensuremath{\lor}.
    This analogy can be made more precise by the following theorems,
    which show how to translate knowledge about \coqdocvar{andb} and \coqdocvar{orb}'s
    behaviors on certain inputs into propositional facts about those
    inputs. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{andb\_prop} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{andb} \coqdocvar{b} \coqdocvar{c} = \coqdocvar{true} \ensuremath{\rightarrow} \coqdocvar{b} = \coqdocvar{true} \ensuremath{\land} \coqdocvar{c} = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{b} \coqdocvar{c} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{b}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "b = true". \coqdoctac{destruct} \coqdocvar{c}.\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{SCase} "c = true". \coqdoctac{apply} \coqdocvar{conj}. \coqdoctac{reflexivity}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{SCase} "c = false". \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "b = false". \coqdoctac{inversion} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{andb\_true\_intro} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{b} = \coqdocvar{true} \ensuremath{\land} \coqdocvar{c} = \coqdocvar{true} \ensuremath{\rightarrow} \coqdocvar{andb} \coqdocvar{b} \coqdocvar{c} = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{b} \coqdocvar{c} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{H}. \coqdoctac{rewrite} \coqdocvar{H0}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars, optional (andb\_false)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{andb\_false} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{andb} \coqdocvar{b} \coqdocvar{c} = \coqdocvar{false} \ensuremath{\rightarrow} \coqdocvar{b} = \coqdocvar{false} \ensuremath{\lor} \coqdocvar{c} = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars, optional (orb\_false)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{orb\_prop} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{orb} \coqdocvar{b} \coqdocvar{c} = \coqdocvar{true} \ensuremath{\rightarrow} \coqdocvar{b} = \coqdocvar{true} \ensuremath{\lor} \coqdocvar{c} = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars, optional (orb\_false\_elim)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{orb\_false\_elim} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{c},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{orb} \coqdocvar{b} \coqdocvar{c} = \coqdocvar{false} \ensuremath{\rightarrow} \coqdocvar{b} = \coqdocvar{false} \ensuremath{\land} \coqdocvar{c} = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Falsehood}



 Logical falsehood can be represented in Coq as an inductively
    defined proposition with no constructors. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{False} : \coqdockw{Prop} := .\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Intuition: \coqdocvar{False} is a proposition for which there is no way
    to give evidence. 

 Since \coqdocvar{False} has no constructors, inverting an assumption
    of type \coqdocvar{False} always yields zero subgoals, allowing us to
    immediately prove any goal. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{False\_implies\_nonsense} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{False} \ensuremath{\rightarrow} 2 + 2 = 5.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{contra}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{contra}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
How does this work? The \coqdoctac{inversion} tactic breaks \coqdocvar{contra} into
    each of its possible cases, and yields a subgoal for each case.
    As \coqdocvar{contra} is evidence for \coqdocvar{False}, it has \textit{no} possible cases,
    hence, there are no possible subgoals and the proof is done. 

\subsubsection{ }

 Conversely, the only way to prove \coqdocvar{False} is if there is already
    something nonsensical or contradictory in the context: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{nonsense\_implies\_False} :\coqdoceol
\coqdocindent{1.00em}
2 + 2 = 5 \ensuremath{\rightarrow} \coqdocvar{False}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{contra}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{contra}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Actually, since the proof of \coqdocvar{False\_implies\_nonsense}
    doesn't actually have anything to do with the specific nonsensical
    thing being proved; it can easily be generalized to work for an
    arbitrary \coqdocvar{P}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{ex\_falso\_quodlibet} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{P}:\coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{False} \ensuremath{\rightarrow} \coqdocvar{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{contra}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{contra}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The Latin \textit{ex falso quodlibet} means, literally, ``from
    falsehood follows whatever you please.''  This theorem is also
    known as the \textit{principle of explosion}. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Truth}



 Since we have defined falsehood in Coq, one might wonder whether
    it is possible to define truth in the same way.  We can. 

\paragraph{Exercise: 2 stars, advanced (True)}

 Define \coqdocvar{True} as another inductively defined proposition.  (The
    intution is that \coqdocvar{True} should be a proposition for which it is
    trivial to give evidence.) \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

 However, unlike \coqdocvar{False}, which we'll use extensively, \coqdocvar{True} is
    used fairly rarely. By itself, it is trivial (and therefore
    uninteresting) to prove as a goal, and it carries no useful
    information as a hypothesis. But it can be useful when defining
    complex \coqdockw{Prop}s using conditionals, or as a parameter to 
    higher-order \coqdockw{Prop}s. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Negation}



 The logical complement of a proposition \coqdocvar{P} is written \coqdocvar{not}
    \coqdocvar{P} or, for shorthand, \ensuremath{\lnot}\coqdocvar{P}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{not} (\coqdocvar{P}:\coqdockw{Prop}) := \coqdocvar{P} \ensuremath{\rightarrow} \coqdocvar{False}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The intuition is that, if \coqdocvar{P} is not true, then anything at
    all (even \coqdocvar{False}) follows from assuming \coqdocvar{P}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "\~{} x" := (\coqdocvar{not} \coqdocvar{x}) : \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{not}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
It takes a little practice to get used to working with
    negation in Coq.  Even though you can see perfectly well why
    something is true, it can be a little hard at first to get things
    into the right configuration so that Coq can see it!  Here are
    proofs of a few familiar facts about negation to get you warmed
    up. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{not\_False} : \coqdoceol
\coqdocindent{1.00em}
\ensuremath{\lnot} \coqdocvar{False}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{not}. \coqdoctac{intros} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{contradiction\_implies\_anything} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{P} \ensuremath{\land} \ensuremath{\lnot}\coqdocvar{P}) \ensuremath{\rightarrow} \coqdocvar{Q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} [\coqdocvar{HP} \coqdocvar{HNA}]. \coqdoctac{unfold} \coqdocvar{not} \coqdoctac{in} \coqdocvar{HNA}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{HNA} \coqdoctac{in} \coqdocvar{HP}. \coqdoctac{inversion} \coqdocvar{HP}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{double\_neg} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{P} \ensuremath{\rightarrow} \~{}\~{}\coqdocvar{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{H}. \coqdoctac{unfold} \coqdocvar{not}. \coqdoctac{intros} \coqdocvar{G}. \coqdoctac{apply} \coqdocvar{G}. \coqdoctac{apply} \coqdocvar{H}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars, advanced (double\_neg\_inf)}

 Write an informal proof of \coqdocvar{double\_neg}:


   \textit{Theorem}: \coqdocvar{P} implies \~{}\~{}\coqdocvar{P}, for any proposition \coqdocvar{P}.


   \textit{Proof}:
   \ensuremath{\Box}


\paragraph{Exercise: 2 stars (contrapositive)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{contrapositive} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{P} \ensuremath{\rightarrow} \coqdocvar{Q}) \ensuremath{\rightarrow} (\~{}\coqdocvar{Q} \ensuremath{\rightarrow} \ensuremath{\lnot}\coqdocvar{P}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 1 star (not\_both\_true\_and\_false)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{not\_both\_true\_and\_false} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\lnot} (\coqdocvar{P} \ensuremath{\land} \ensuremath{\lnot}\coqdocvar{P}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 1 star, advanced (informal\_not\_PNP)}

 Write an informal proof (in English) of the proposition \coqdockw{\ensuremath{\forall}} \coqdocvar{P}
    : \coqdockw{Prop}, \~{}(\coqdocvar{P} \ensuremath{\land} \ensuremath{\lnot}\coqdocvar{P}). \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\subsubsection{Constructive logic}

 Note that some theorems that are true in classical logic are \textit{not}
    provable in Coq's (constructive) logic.  E.g., let's look at how
    this proof gets stuck... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{classic\_double\_neg} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} : \coqdockw{Prop},\coqdoceol
\coqdocindent{1.00em}
\~{}\~{}\coqdocvar{P} \ensuremath{\rightarrow} \coqdocvar{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{H}. \coqdoctac{unfold} \coqdocvar{not} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 5 stars, advanced, optional (classical\_axioms)}

 For those who like a challenge, here is an exercise
    taken from the Coq'Art book (p. 123).  The following five
    statements are often considered as characterizations of
    classical logic (as opposed to constructive logic, which is
    what is ``built in'' to Coq).  We can't prove them in Coq, but
    we can consistently add any one of them as an unproven axiom
    if we wish to work in classical logic.  Prove that these five
    propositions are equivalent. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{peirce} := \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q}: \coqdockw{Prop}, \coqdoceol
\coqdocindent{1.00em}
((\coqdocvar{P}\ensuremath{\rightarrow}\coqdocvar{Q})->\coqdocvar{P})->\coqdocvar{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{classic} := \coqdockw{\ensuremath{\forall}} \coqdocvar{P}:\coqdockw{Prop}, \coqdoceol
\coqdocindent{1.00em}
\~{}\~{}\coqdocvar{P} \ensuremath{\rightarrow} \coqdocvar{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{excluded\_middle} := \coqdockw{\ensuremath{\forall}} \coqdocvar{P}:\coqdockw{Prop}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{P} \ensuremath{\lor} \ensuremath{\lnot}\coqdocvar{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{de\_morgan\_not\_and\_not} := \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q}:\coqdockw{Prop}, \coqdoceol
\coqdocindent{1.00em}
\~{}(\~{}\coqdocvar{P} \ensuremath{\land} \ensuremath{\lnot}\coqdocvar{Q}) \ensuremath{\rightarrow} \coqdocvar{P}\ensuremath{\lor}\coqdocvar{Q}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{implies\_to\_or} := \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q}:\coqdockw{Prop}, \coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{P}\ensuremath{\rightarrow}\coqdocvar{Q}) \ensuremath{\rightarrow} (\~{}\coqdocvar{P}\ensuremath{\lor}\coqdocvar{Q}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars (excluded\_middle\_irrefutable)}

 This theorem implies that it is always safe to add a decidability
axiom (i.e. an instance of excluded middle) for any \textit{particular} Prop \coqdocvar{P}.
Why? Because we cannot prove the negation of such an axiom; if we could,
we would have both \ensuremath{\lnot} (\coqdocvar{P} \ensuremath{\lor} \ensuremath{\lnot}\coqdocvar{P}) and \ensuremath{\lnot} \ensuremath{\lnot} (\coqdocvar{P} \ensuremath{\lor} \ensuremath{\lnot}\coqdocvar{P}), a contradiction. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{excluded\_middle\_irrefutable}:  \coqdockw{\ensuremath{\forall}} (\coqdocvar{P}:\coqdockw{Prop}), \ensuremath{\lnot} \ensuremath{\lnot} (\coqdocvar{P} \ensuremath{\lor} \ensuremath{\lnot} \coqdocvar{P}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Inequality}



 Saying \coqdocvar{x} \ensuremath{\not=} \coqdocvar{y} is just the same as saying \~{}(\coqdocvar{x} = \coqdocvar{y}). \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "x <> y" := (\~{} (\coqdocvar{x} = \coqdocvar{y})) : \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Since inequality involves a negation, it again requires
    a little practice to be able to work with it fluently.  Here
    is one very useful trick.  If you are trying to prove a goal
    that is nonsensical (e.g., the goal state is \coqdocvar{false} = \coqdocvar{true}),
    apply the lemma \coqdocvar{ex\_falso\_quodlibet} to change the goal to
    \coqdocvar{False}.  This makes it easier to use assumptions of the form
    \ensuremath{\lnot}\coqdocvar{P} that are available in the context -- in particular,
    assumptions of the form \coqdocvar{x}\ensuremath{\not=}\coqdocvar{y}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{not\_false\_then\_true} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} : \coqdocvar{bool},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{b} \ensuremath{\not=} \coqdocvar{false} \ensuremath{\rightarrow} \coqdocvar{b} = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{b} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{b}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "b = true". \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "b = false".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqdocvar{not} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{ex\_falso\_quodlibet}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{H}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }



\subsubsection{ }



\subsubsection{ }



\subsubsection{ }



\subsubsection{ }



\paragraph{Exercise: 2 stars (false\_beq\_nat)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{false\_beq\_nat} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat},\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{n} \ensuremath{\not=} \coqdocvar{m} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
\coqdocvar{beq\_nat} \coqdocvar{n} \coqdocvar{m} = \coqdocvar{false}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars, optional (beq\_nat\_false)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{beq\_nat\_false} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beq\_nat} \coqdocvar{n} \coqdocvar{m} = \coqdocvar{false} \ensuremath{\rightarrow} \coqdocvar{n} \ensuremath{\not=} \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 $Date: 2014-12-31 11:17:56 -0500 (Wed, 31 Dec 2014) $ \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{Top.Prop}{Library }{Top.Prop}

\begin{coqdoccode}
\end{coqdoccode}
\section{Prop: Propositions and Evidence}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqdocvar{Logic}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Inductively Defined Propositions}



 In chapter \coqdocvar{Basics} we defined a \textit{function} \coqdocvar{evenb} that tests a
    number for evenness, yielding \coqdocvar{true} if so.  We can use this
    function to define the \textit{proposition} that some number \coqdocvar{n} is
    even: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{even} (\coqdocvar{n}:\coqdocvar{nat}) : \coqdockw{Prop} := \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{evenb} \coqdocvar{n} = \coqdocvar{true}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
That is, we can define ``\coqdocvar{n} is even'' to mean ``the function \coqdocvar{evenb}
    returns \coqdocvar{true} when applied to \coqdocvar{n}.''  


    Note that here we have given a name
    to a proposition using a \coqdockw{Definition}, just as we have
    given names to expressions of other sorts. This isn't a fundamentally
    new kind of proposition;  it is still just an equality. 

 Another alternative is to define the concept of evenness
    directly.  Instead of going via the \coqdocvar{evenb} function (``a number is
    even if a certain computation yields \coqdocvar{true}''), we can say what the
    concept of evenness means by giving two different ways of
    presenting \textit{evidence} that a number is even. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{ev} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{ev\_0} : \coqdocvar{ev} \coqdocvar{O}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{ev\_SS} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat}, \coqdocvar{ev} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{ev} (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{n})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The first line declares that \coqdocvar{ev} is a proposition -- or,
    more formally, a family of propositions ``indexed by'' natural
    numbers.  (That is, for each number \coqdocvar{n}, the claim that ``\coqdocvar{n} is
    even'' is a proposition.)  Such a family of propositions is
    often called a \textit{property} of numbers.  


    The last two lines declare the two ways to give evidence that a
    number \coqdocvar{m} is even.  First, 0 is even, and \coqdocvar{ev\_0} is evidence
    for this.  Second, if \coqdocvar{m} = \coqdocvar{S} (\coqdocvar{S} \coqdocvar{n}) for some \coqdocvar{n} and we can give
    evidence \coqdocvar{e} that \coqdocvar{n} is even, then \coqdocvar{m} is also even, and \coqdocvar{ev\_SS} \coqdocvar{n}
    \coqdocvar{e} is the evidence.


\paragraph{Exercise: 1 star (double\_even)}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{double\_even} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ev} (\coqdocvar{double} \coqdocvar{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
For \coqdocvar{ev}, we had already defined \coqdocvar{even} as a function (returning a
   boolean), and then defined an inductive relation that agreed with
   it. However, we don't necessarily need to think about propositions
   first as boolean functions, we can start off with the inductive
   definition.


 As another example of an inductively defined proposition, let's
    define a simple property of natural numbers -- we'll call it
    ``\coqdocvar{beautiful}.'' 

 Informally, a number is \coqdocvar{beautiful} if it is 0, 3, 5, or the
    sum of two \coqdocvar{beautiful} numbers.  


    More pedantically, we can define \coqdocvar{beautiful} numbers by giving four
    rules:



\begin{itemize}
\item  Rule \coqdocvar{b\_0}: The number 0 is \coqdocvar{beautiful}.

\item  Rule \coqdocvar{b\_3}: The number 3 is \coqdocvar{beautiful}. 

\item  Rule \coqdocvar{b\_5}: The number 5 is \coqdocvar{beautiful}. 

\item  Rule \coqdocvar{b\_sum}: If \coqdocvar{n} and \coqdocvar{m} are both \coqdocvar{beautiful}, then so is
         their sum. 
\end{itemize}


 We will see many definitions like this one during the rest
    of the course, and for purposes of informal discussions, it is
    helpful to have a lightweight notation that makes them easy to
    read and write.  \textit{Inference rules} are one such notation: \par
\noindent\hrulefill\par
\noindent{}                               (b\_0)
                              beautiful 0
\par
\noindent\hrulefill\par
\noindent{}                              (b\_3)
                              beautiful 3
\par
\noindent\hrulefill\par
\noindent{}                              (b\_5)
                              beautiful 5    


                       beautiful n     beautiful m
\par
\noindent\hrulefill\par
\noindent{}                      (b\_sum)
                              beautiful (n+m)   


\subsubsection{ }

 Each of the textual rules above is reformatted here as an
    inference rule; the intended reading is that, if the \textit{premises}
    above the line all hold, then the \textit{conclusion} below the line
    follows.  For example, the rule \coqdocvar{b\_sum} says that, if \coqdocvar{n} and \coqdocvar{m}
    are both \coqdocvar{beautiful} numbers, then it follows that \coqdocvar{n}+\coqdocvar{m} is
    \coqdocvar{beautiful} too.  If a rule has no premises above the line, then
    its conclusion holds unconditionally.


    These rules \textit{define} the property \coqdocvar{beautiful}.  That is, if we
    want to convince someone that some particular number is \coqdocvar{beautiful},
    our argument must be based on these rules.  For a simple example,
    suppose we claim that the number 5 is \coqdocvar{beautiful}.  To support
    this claim, we just need to point out that rule \coqdocvar{b\_5} says so.
    Or, if we want to claim that 8 is \coqdocvar{beautiful}, we can support our
    claim by first observing that 3 and 5 are both \coqdocvar{beautiful} (by
    rules \coqdocvar{b\_3} and \coqdocvar{b\_5}) and then pointing out that their sum, 8,
    is therefore \coqdocvar{beautiful} by rule \coqdocvar{b\_sum}.  This argument can be
    expressed graphically with the following \textit{proof tree}: \par
\noindent\hrulefill\par
\noindent{} (b\_3)   ----------- (b\_5)
         beautiful 3         beautiful 5
\par
\noindent\hrulefill\par
\noindent{} (b\_sum)
                   beautiful 8   
\subsubsection{ }



    Of course, there are other ways of using these rules to argue that
    8 is \coqdocvar{beautiful}, for instance:
\par
\noindent\hrulefill\par
\noindent{} (b\_5)   ----------- (b\_3)
         beautiful 5         beautiful 3
\par
\noindent\hrulefill\par
\noindent{} (b\_sum)
                   beautiful 8   


\paragraph{Exercise: 1 star (varieties\_of\_beauty)}

 How many different ways are there to show that 8 is \coqdocvar{beautiful}? \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Constructing Evidence}



 In Coq, we can express the definition of \coqdocvar{beautiful} as
    follows: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{beautiful} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{b\_0}   : \coqdocvar{beautiful} 0\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdocvar{b\_3}   : \coqdocvar{beautiful} 3\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdocvar{b\_5}   : \coqdocvar{beautiful} 5\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdocvar{b\_sum} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m}, \coqdocvar{beautiful} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{beautiful} \coqdocvar{m} \ensuremath{\rightarrow} \coqdocvar{beautiful} (\coqdocvar{n}+\coqdocvar{m}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }



    The rules introduced this way have the same status as proven 
    theorems; that is, they are true axiomatically. 
    So we can use Coq's \coqdoctac{apply} tactic with the rule names to prove 
    that particular numbers are \coqdocvar{beautiful}.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{three\_is\_beautiful}: \coqdocvar{beautiful} 3.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{apply} \coqdocvar{b\_3}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{eight\_is\_beautiful}: \coqdocvar{beautiful} 8.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{apply} \coqdocvar{b\_sum} \coqdockw{with} (\coqdocvar{n}:=3) (\coqdocvar{m}:=5).\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{apply} \coqdocvar{b\_3}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{apply} \coqdocvar{b\_5}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 As you would expect, we can also prove theorems that have
hypotheses about \coqdocvar{beautiful}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{beautiful\_plus\_eight}: \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{beautiful} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{beautiful} (8+\coqdocvar{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{B}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{b\_sum} \coqdockw{with} (\coqdocvar{n}:=8) (\coqdocvar{m}:=\coqdocvar{n}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{eight\_is\_beautiful}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{B}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars (b\_times2)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{b\_times2}: \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{beautiful} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{beautiful} (2*\coqdocvar{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars (b\_timesm)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{b\_timesm}: \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m}, \coqdocvar{beautiful} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{beautiful} (\coqdocvar{m}\ensuremath{\times}\coqdocvar{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Using Evidence in Proofs}

\subsection{Induction over Evidence}



 Besides \textit{constructing} evidence that numbers are beautiful, we can
    also \textit{reason about} such evidence. 

 The fact that we introduced \coqdocvar{beautiful} with an \coqdockw{Inductive}
    declaration tells Coq not only that the constructors \coqdocvar{b\_0}, \coqdocvar{b\_3},
    \coqdocvar{b\_5} and \coqdocvar{b\_sum} are ways to build evidence, but also that these
    four constructors are the \textit{only} ways to build evidence that
    numbers are beautiful. 

 In other words, if someone gives us evidence \coqdocvar{E} for the assertion
    \coqdocvar{beautiful} \coqdocvar{n}, then we know that \coqdocvar{E} must have one of four shapes:



\begin{itemize}
\item  \coqdocvar{E} is \coqdocvar{b\_0} (and \coqdocvar{n} is \coqdocvar{O}),

\item  \coqdocvar{E} is \coqdocvar{b\_3} (and \coqdocvar{n} is 3), 

\item  \coqdocvar{E} is \coqdocvar{b\_5} (and \coqdocvar{n} is 5), or 

\item  \coqdocvar{E} is \coqdocvar{b\_sum} \coqdocvar{n1} \coqdocvar{n2} \coqdocvar{E1} \coqdocvar{E2} (and \coqdocvar{n} is \coqdocvar{n1}+\coqdocvar{n2}, where \coqdocvar{E1} is
        evidence that \coqdocvar{n1} is beautiful and \coqdocvar{E2} is evidence that \coqdocvar{n2}
        is beautiful). 
\end{itemize}


\subsubsection{ }

 This permits us to \textit{analyze} any hypothesis of the form \coqdocvar{beautiful}
    \coqdocvar{n} to see how it was constructed, using the tactics we already
    know.  In particular, we can use the \coqdoctac{induction} tactic that we
    have already seen for reasoning about inductively defined \textit{data}
    to reason about inductively defined \textit{evidence}.


    To illustrate this, let's define another property of numbers: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{gorgeous} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{g\_0} : \coqdocvar{gorgeous} 0\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdocvar{g\_plus3} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{gorgeous} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{gorgeous} (3+\coqdocvar{n})\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdocvar{g\_plus5} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{gorgeous} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{gorgeous} (5+\coqdocvar{n}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star (gorgeous\_tree)}

 Write out the definition of \coqdocvar{gorgeous} numbers using inference rule
    notation.


\ensuremath{\Box}


\paragraph{Exercise: 1 star (gorgeous\_plus13)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{gorgeous\_plus13}: \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{gorgeous} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{gorgeous} (13+\coqdocvar{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\subsubsection{ }

 It seems intuitively obvious that, although \coqdocvar{gorgeous} and
    \coqdocvar{beautiful} are presented using slightly different rules, they are
    actually the same property in the sense that they are true of the
    same numbers.  Indeed, we can prove this. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{gorgeous\_\_beautiful\_FAILED} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{gorgeous} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{beautiful} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [| \coqdocvar{n'}].\coqdoceol
\coqdocindent{1.50em}
\coqdocvar{Case} "n = 0". \coqdoctac{apply} \coqdocvar{b\_0}.\coqdoceol
\coqdocindent{1.50em}
\coqdocvar{Case} "n = S n'". \coqdocnoindent
\coqdockw{Abort}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The problem here is that doing induction on \coqdocvar{n} doesn't yield a
    useful induction hypothesis. Knowing how the property we are
    interested in behaves on the predecessor of \coqdocvar{n} doesn't help us
    prove that it holds for \coqdocvar{n}. Instead, we would like to be able to
    have induction hypotheses that mention other numbers, such as \coqdocvar{n} -
    3 and \coqdocvar{n} - 5. This is given precisely by the shape of the
    constructors for \coqdocvar{gorgeous}. 

\subsubsection{ }



 Let's see what happens if we try to prove this by induction on the evidence \coqdocvar{H}
   instead of on \coqdocvar{n}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{gorgeous\_\_beautiful} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{gorgeous} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{beautiful} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{induction} \coqdocvar{H} \coqdockw{as} [|\coqdocvar{n'}\ensuremath{|}\coqdocvar{n'}].\coqdoceol
\coqdocindent{1.50em}
\coqdocvar{Case} "g\_0".\coqdoceol
\coqdocindent{3.50em}
\coqdoctac{apply} \coqdocvar{b\_0}.\coqdoceol
\coqdocindent{1.50em}
\coqdocvar{Case} "g\_plus3".\coqdoceol
\coqdocindent{3.50em}
\coqdoctac{apply} \coqdocvar{b\_sum}. \coqdoctac{apply} \coqdocvar{b\_3}.\coqdoceol
\coqdocindent{3.50em}
\coqdoctac{apply} \coqdocvar{IHgorgeous}.\coqdoceol
\coqdocindent{1.50em}
\coqdocvar{Case} "g\_plus5".\coqdoceol
\coqdocindent{3.50em}
\coqdoctac{apply} \coqdocvar{b\_sum}. \coqdoctac{apply} \coqdocvar{b\_5}. \coqdoctac{apply} \coqdocvar{IHgorgeous}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars (gorgeous\_sum)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{gorgeous\_sum} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{gorgeous} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{gorgeous} \coqdocvar{m} \ensuremath{\rightarrow} \coqdocvar{gorgeous} (\coqdocvar{n} + \coqdocvar{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, advanced (beautiful\_\_gorgeous)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{beautiful\_\_gorgeous} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{beautiful} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{gorgeous} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, optional (g\_times2)}

 Prove the \coqdocvar{g\_times2} theorem below without using \coqdocvar{gorgeous\_\_beautiful}.
    You might find the following helper lemma useful. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{helper\_g\_times2} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}, \coqdocvar{x} + (\coqdocvar{z} + \coqdocvar{y}) = \coqdocvar{z} + \coqdocvar{x} + \coqdocvar{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{g\_times2}: \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{gorgeous} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{gorgeous} (2*\coqdocvar{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{H}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{induction} \coqdocvar{H}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 Here is a proof that the inductive definition of evenness implies
the computational one. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{ev\_\_even} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ev} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{even} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{E}. \coqdoctac{induction} \coqdocvar{E} \coqdockw{as} [| \coqdocvar{n'} \coqdocvar{E'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "E = ev\_0".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqdocvar{even}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "E = ev\_SS n' E'".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{unfold} \coqdocvar{even}. \coqdoctac{apply} \coqdocvar{IHE'}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star (ev\_\_even)}

 Could this proof also be carried out by induction on \coqdocvar{n} instead
    of \coqdocvar{E}?  If not, why not? \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

 Intuitively, the induction principle \coqdocvar{ev} \coqdocvar{n} evidence \coqdocvar{ev} \coqdocvar{n} is
    similar to induction on \coqdocvar{n}, but restricts our attention to only
    those numbers for which evidence \coqdocvar{ev} \coqdocvar{n} could be generated. 

\paragraph{Exercise: 1 star (l\_fails)}

 The following proof attempt will not succeed.
     Theorem l : forall n,
       ev n.
     Proof.
       intros n. induction n.
         Case ``O''. simpl. apply ev\_0.
         Case ``S''.
           ...
   Intuitively, we expect the proof to fail because not every
   number is even. However, what exactly causes the proof to fail?


 \ensuremath{\Box} 

 Here's another exercise requiring induction on evidence. \paragraph{Exercise: 2 stars (ev\_sum)}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{ev\_sum} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.50em}
\coqdocvar{ev} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{ev} \coqdocvar{m} \ensuremath{\rightarrow} \coqdocvar{ev} (\coqdocvar{n}+\coqdocvar{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Inversion on Evidence}



 Having evidence for a proposition is useful while proving, because we 
   can \textit{look} at that evidence for more information. For example, consider 
    proving that, if \coqdocvar{n} is even, then \coqdocvar{pred} (\coqdocvar{pred} \coqdocvar{n}) is
    too.  In this case, we don't need to do an inductive proof.  Instead 
    the \coqdoctac{inversion} tactic provides all of the information that we need.


 \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{ev\_minus2}: \coqdockw{\ensuremath{\forall}} \coqdocvar{n},  \coqdocvar{ev} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{ev} (\coqdocvar{pred} (\coqdocvar{pred} \coqdocvar{n})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{E}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{E} \coqdockw{as} [| \coqdocvar{n'} \coqdocvar{E'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "E = ev\_0". \coqdoctac{simpl}. \coqdoctac{apply} \coqdocvar{ev\_0}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "E = ev\_SS n' E'". \coqdoctac{simpl}. \coqdoctac{apply} \coqdocvar{E'}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star, optional (ev\_minus2\_n)}

 What happens if we try to use \coqdoctac{destruct} on \coqdocvar{n} instead of \coqdoctac{inversion} on \coqdocvar{E}? \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\subsubsection{ }

 Here is another example, in which \coqdoctac{inversion} helps narrow down to
the relevant cases. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{SSev\_\_even} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ev} (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{n})) \ensuremath{\rightarrow} \coqdocvar{ev} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{E}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{E} \coqdockw{as} [| \coqdocvar{n'} \coqdocvar{E'}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{E'}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{The Inversion Tactic Revisited}



 These uses of \coqdoctac{inversion} may seem a bit mysterious at first.
    Until now, we've only used \coqdoctac{inversion} on equality
    propositions, to utilize injectivity of constructors or to
    discriminate between different constructors.  But we see here
    that \coqdoctac{inversion} can also be applied to analyzing evidence
    for inductively defined propositions.


    (You might also expect that \coqdoctac{destruct} would be a more suitable
    tactic to use here. Indeed, it is possible to use \coqdoctac{destruct}, but 
    it often throws away useful information, and the \coqdocvar{eqn}: qualifier
    doesn't help much in this case.)    


    Here's how \coqdoctac{inversion} works in general.  Suppose the name
    \coqdocvar{I} refers to an assumption \coqdocvar{P} in the current context, where
    \coqdocvar{P} has been defined by an \coqdockw{Inductive} declaration.  Then,
    for each of the constructors of \coqdocvar{P}, \coqdoctac{inversion} \coqdocvar{I} generates
    a subgoal in which \coqdocvar{I} has been replaced by the exact,
    specific conditions under which this constructor could have
    been used to prove \coqdocvar{P}.  Some of these subgoals will be
    self-contradictory; \coqdoctac{inversion} throws these away.  The ones
    that are left represent the cases that must be proved to
    establish the original goal.


    In this particular case, the \coqdoctac{inversion} analyzed the construction
    \coqdocvar{ev} (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{n})), determined that this could only have been
    constructed using \coqdocvar{ev\_SS}, and generated a new subgoal with the
    arguments of that constructor as new hypotheses.  (It also
    produced an auxiliary equality, which happens to be useless here.)
    We'll begin exploring this more general behavior of inversion in
    what follows. 

\paragraph{Exercise: 1 star (inversion\_practice)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{SSSSev\_\_even} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ev} (\coqdocvar{S} (\coqdocvar{S} (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{n})))) \ensuremath{\rightarrow} \coqdocvar{ev} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqdoctac{inversion} tactic can also be used to derive goals by showing
    the absurdity of a hypothesis. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{even5\_nonsense} : \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ev} 5 \ensuremath{\rightarrow} 2 + 2 = 9.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, advanced (ev\_ev\_\_ev)}

 Finding the appropriate thing to do induction on is a
    bit tricky here: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{ev\_ev\_\_ev} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ev} (\coqdocvar{n}+\coqdocvar{m}) \ensuremath{\rightarrow} \coqdocvar{ev} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{ev} \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, optional (ev\_plus\_plus)}

 Here's an exercise that just requires applying existing lemmas.  No
    induction or even case analysis is needed, but some of the rewriting
    may be tedious. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{ev\_plus\_plus} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{p},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ev} (\coqdocvar{n}+\coqdocvar{m}) \ensuremath{\rightarrow} \coqdocvar{ev} (\coqdocvar{n}+\coqdocvar{p}) \ensuremath{\rightarrow} \coqdocvar{ev} (\coqdocvar{m}+\coqdocvar{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Discussion and Variations}

\subsection{Computational vs. Inductive Definitions}



 We have seen that the proposition ``\coqdocvar{n} is even'' can be
    phrased in two different ways -- indirectly, via a boolean testing
    function \coqdocvar{evenb}, or directly, by inductively describing what
    constitutes evidence for evenness.  These two ways of defining
    evenness are about equally easy to state and work with.  Which we
    choose is basically a question of taste.


    However, for many other properties of interest, the direct
    inductive definition is preferable, since writing a testing
    function may be awkward or even impossible.  


    One such property is \coqdocvar{beautiful}.  This is a perfectly sensible
    definition of a set of numbers, but we cannot translate its
    definition directly into a Coq Fixpoint (or into a recursive
    function in any other common programming language).  We might be
    able to find a clever way of testing this property using a
    \coqdockw{Fixpoint} (indeed, it is not too hard to find one in this case),
    but in general this could require arbitrarily deep thinking.  In
    fact, if the property we are interested in is uncomputable, then
    we cannot define it as a \coqdockw{Fixpoint} no matter how hard we try,
    because Coq requires that all \coqdockw{Fixpoint}s correspond to
    terminating computations.


    On the other hand, writing an inductive definition of what it
    means to give evidence for the property \coqdocvar{beautiful} is
    straightforward. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Parameterized Data Structures}



 So far, we have only looked at propositions about natural numbers. However, 
   we can define inductive predicates about any type of data. For example, 
   suppose we would like to characterize lists of \textit{even} length. We can 
   do that with the following definition.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{ev\_list} \{\coqdocvar{X}:\coqdockw{Type}\} : \coqdocvar{list} \coqdocvar{X} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{el\_nil} : \coqdocvar{ev\_list} []\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{el\_cc}  : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{l}, \coqdocvar{ev\_list} \coqdocvar{l} \ensuremath{\rightarrow} \coqdocvar{ev\_list} (\coqdocvar{x} :: \coqdocvar{y} :: \coqdocvar{l}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Of course, this proposition is equivalent to just saying that the
length of the list is even. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{ev\_list\_\_ev\_length}: \coqdockw{\ensuremath{\forall}} \coqdocvar{X} (\coqdocvar{l} : \coqdocvar{list} \coqdocvar{X}), \coqdocvar{ev\_list} \coqdocvar{l} \ensuremath{\rightarrow} \coqdocvar{ev} (\coqdocvar{length} \coqdocvar{l}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{l} \coqdocvar{H}. \coqdoctac{induction} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "el\_nil". \coqdoctac{simpl}. \coqdoctac{apply} \coqdocvar{ev\_0}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Case} "el\_cc". \coqdoctac{simpl}. \coqdoctac{apply} \coqdocvar{ev\_SS}. \coqdoctac{apply} \coqdocvar{IHev\_list}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
However, because evidence for \coqdocvar{ev} contains less information than
evidence for \coqdocvar{ev\_list}, the converse direction must be stated very
carefully. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{ev\_length\_\_ev\_list}: \coqdockw{\ensuremath{\forall}} \coqdocvar{X} \coqdocvar{n}, \coqdocvar{ev} \coqdocvar{n} \ensuremath{\rightarrow} \coqdockw{\ensuremath{\forall}} (\coqdocvar{l} : \coqdocvar{list} \coqdocvar{X}), \coqdocvar{n} = \coqdocvar{length} \coqdocvar{l} \ensuremath{\rightarrow} \coqdocvar{ev\_list} \coqdocvar{l}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{n} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "ev\_0". \coqdoctac{intros} \coqdocvar{l} \coqdocvar{H}. \coqdoctac{destruct} \coqdocvar{l}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "[]". \coqdoctac{apply} \coqdocvar{el\_nil}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "x::l". \coqdoctac{inversion} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "ev\_SS". \coqdoctac{intros} \coqdocvar{l} \coqdocvar{H2}. \coqdoctac{destruct} \coqdocvar{l}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "[]". \coqdoctac{inversion} \coqdocvar{H2}. \coqdoctac{destruct} \coqdocvar{l}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "[x]". \coqdoctac{inversion} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "x :: x0 :: l". \coqdoctac{apply} \coqdocvar{el\_cc}. \coqdoctac{apply} \coqdocvar{IHev}. \coqdoctac{inversion} \coqdocvar{H2}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 4 stars (palindromes)}

 A palindrome is a sequence that reads the same backwards as
    forwards.



\begin{itemize}
\item  Define an inductive proposition \coqdocvar{pal} on \coqdocvar{list} \coqdocvar{X} that
      captures what it means to be a palindrome. (Hint: You'll need
      three cases.  Your definition should be based on the structure
      of the list; just having a single constructor
        c : forall l, l = rev l -> pal l
      may seem obvious, but will not work very well.)



\item  Prove \coqdocvar{pal\_app\_rev} that 
       forall l, pal (l ++ rev l).

\item  Prove \coqdocvar{pal\_rev} that 
       forall l, pal l -> l = rev l.

\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 5 stars, optional (palindrome\_converse)}

 Using your definition of \coqdocvar{pal} from the previous exercise, prove
    that
     forall l, l = rev l -> pal l.
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\subsection{Relations}



 A proposition parameterized by a number (such as \coqdocvar{ev} or
    \coqdocvar{beautiful}) can be thought of as a \textit{property} -- i.e., it defines
    a subset of \coqdocvar{nat}, namely those numbers for which the proposition
    is provable.  In the same way, a two-argument proposition can be
    thought of as a \textit{relation} -- i.e., it defines a set of pairs for
    which the proposition is provable. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdocvar{LeModule}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
One useful example is the ``less than or equal to''
    relation on numbers. 

 The following definition should be fairly intuitive.  It
    says that there are two ways to give evidence that one number is
    less than or equal to another: either observe that they are the
    same number, or give evidence that the first is less than or equal
    to the predecessor of the second. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{le} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{le\_n} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{le} \coqdocvar{n} \coqdocvar{n}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{le\_S} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m}, (\coqdocvar{le} \coqdocvar{n} \coqdocvar{m}) \ensuremath{\rightarrow} (\coqdocvar{le} \coqdocvar{n} (\coqdocvar{S} \coqdocvar{m})).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "m <= n" := (\coqdocvar{le} \coqdocvar{m} \coqdocvar{n}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Proofs of facts about \ensuremath{\le} using the constructors \coqdocvar{le\_n} and
    \coqdocvar{le\_S} follow the same patterns as proofs about properties, like
    \coqdocvar{ev} in chapter \coqdockw{Prop}.  We can \coqdoctac{apply} the constructors to prove \ensuremath{\le}
    goals (e.g., to show that 3<=3 or 3<=6), and we can use
    tactics like \coqdoctac{inversion} to extract information from \ensuremath{\le}
    hypotheses in the context (e.g., to prove that (2 \ensuremath{\le} 1) \ensuremath{\rightarrow} 2+2=5.) 

\subsubsection{ }

 Here are some sanity checks on the definition.  (Notice that,
    although these are the same kind of simple ``unit tests'' as we gave
    for the testing functions we wrote in the first few lectures, we
    must construct their proofs explicitly -- \coqdoctac{simpl} and
    \coqdoctac{reflexivity} don't do the job, because the proofs aren't just a
    matter of simplifying computations.) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{test\_le1} :\coqdoceol
\coqdocindent{1.00em}
3 \ensuremath{\le} 3.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{le\_n}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{test\_le2} :\coqdoceol
\coqdocindent{1.00em}
3 \ensuremath{\le} 6.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{le\_S}. \coqdoctac{apply} \coqdocvar{le\_S}. \coqdoctac{apply} \coqdocvar{le\_S}. \coqdoctac{apply} \coqdocvar{le\_n}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{test\_le3} :\coqdoceol
\coqdocindent{1.00em}
(2 \ensuremath{\le} 1) \ensuremath{\rightarrow} 2 + 2 = 5.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H}. \coqdoctac{inversion} \coqdocvar{H2}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 The ``strictly less than'' relation \coqdocvar{n} < \coqdocvar{m} can now be defined
    in terms of \coqdocvar{le}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqdocvar{LeModule}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{lt} (\coqdocvar{n} \coqdocvar{m}:\coqdocvar{nat}) := \coqdocvar{le} (\coqdocvar{S} \coqdocvar{n}) \coqdocvar{m}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "m < n" := (\coqdocvar{lt} \coqdocvar{m} \coqdocvar{n}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here are a few more simple relations on numbers: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{square\_of} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{sq} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat}, \coqdocvar{square\_of} \coqdocvar{n} (\coqdocvar{n} \ensuremath{\times} \coqdocvar{n}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{next\_nat} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{nn} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat}, \coqdocvar{next\_nat} \coqdocvar{n} (\coqdocvar{S} \coqdocvar{n}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{next\_even} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{ne\_1} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{ev} (\coqdocvar{S} \coqdocvar{n}) \ensuremath{\rightarrow} \coqdocvar{next\_even} \coqdocvar{n} (\coqdocvar{S} \coqdocvar{n})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{ne\_2} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{ev} (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{n})) \ensuremath{\rightarrow} \coqdocvar{next\_even} \coqdocvar{n} (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{n})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars (total\_relation)}

 Define an inductive binary relation \coqdocvar{total\_relation} that holds
    between every pair of natural numbers. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars (empty\_relation)}

 Define an inductive binary relation \coqdocvar{empty\_relation} (on numbers)
    that never holds. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars, optional (le\_exercises)}

 Here are a number of facts about the \ensuremath{\le} and < relations that
    we are going to need later in the course.  The proofs make good
    practice exercises. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{le\_trans} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o}, \coqdocvar{m} \ensuremath{\le} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{n} \ensuremath{\le} \coqdocvar{o} \ensuremath{\rightarrow} \coqdocvar{m} \ensuremath{\le} \coqdocvar{o}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{O\_le\_n} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
0 \ensuremath{\le} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{n\_le\_m\_\_Sn\_le\_Sm} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} \ensuremath{\le} \coqdocvar{m} \ensuremath{\rightarrow} \coqdocvar{S} \coqdocvar{n} \ensuremath{\le} \coqdocvar{S} \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{Sn\_le\_Sm\_\_n\_le\_m} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{S} \coqdocvar{n} \ensuremath{\le} \coqdocvar{S} \coqdocvar{m} \ensuremath{\rightarrow} \coqdocvar{n} \ensuremath{\le} \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{le\_plus\_l} : \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{a} \ensuremath{\le} \coqdocvar{a} + \coqdocvar{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_lt} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n1} \coqdocvar{n2} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n1} + \coqdocvar{n2} < \coqdocvar{m} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n1} < \coqdocvar{m} \ensuremath{\land} \coqdocvar{n2} < \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{0.50em}
\coqdoctac{unfold} \coqdocvar{lt}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{lt\_S} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} < \coqdocvar{m} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} < \coqdocvar{S} \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{ble\_nat\_true} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ble\_nat} \coqdocvar{n} \coqdocvar{m} = \coqdocvar{true} \ensuremath{\rightarrow} \coqdocvar{n} \ensuremath{\le} \coqdocvar{m}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{le\_ble\_nat} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} \ensuremath{\le} \coqdocvar{m} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ble\_nat} \coqdocvar{n} \coqdocvar{m} = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{ble\_nat\_true\_trans} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ble\_nat} \coqdocvar{n} \coqdocvar{m} = \coqdocvar{true} \ensuremath{\rightarrow} \coqdocvar{ble\_nat} \coqdocvar{m} \coqdocvar{o} = \coqdocvar{true} \ensuremath{\rightarrow} \coqdocvar{ble\_nat} \coqdocvar{n} \coqdocvar{o} = \coqdocvar{true}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars, optional (ble\_nat\_false)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{ble\_nat\_false} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ble\_nat} \coqdocvar{n} \coqdocvar{m} = \coqdocvar{false} \ensuremath{\rightarrow} \~{}(\coqdocvar{n} \ensuremath{\le} \coqdocvar{m}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars (R\_provability2)}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Module} \coqdocvar{R}.\coqdoceol
\end{coqdoccode}
We can define three-place relations, four-place relations,
    etc., in just the same way as binary relations.  For example,
    consider the following three-place relation on numbers: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{R} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.50em}
\ensuremath{|} \coqdocvar{c1} : \coqdocvar{R} 0 0 0 \coqdoceol
\coqdocindent{1.50em}
\ensuremath{|} \coqdocvar{c2} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o}, \coqdocvar{R} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o} \ensuremath{\rightarrow} \coqdocvar{R} (\coqdocvar{S} \coqdocvar{m}) \coqdocvar{n} (\coqdocvar{S} \coqdocvar{o})\coqdoceol
\coqdocindent{1.50em}
\ensuremath{|} \coqdocvar{c3} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o}, \coqdocvar{R} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o} \ensuremath{\rightarrow} \coqdocvar{R} \coqdocvar{m} (\coqdocvar{S} \coqdocvar{n}) (\coqdocvar{S} \coqdocvar{o})\coqdoceol
\coqdocindent{1.50em}
\ensuremath{|} \coqdocvar{c4} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o}, \coqdocvar{R} (\coqdocvar{S} \coqdocvar{m}) (\coqdocvar{S} \coqdocvar{n}) (\coqdocvar{S} (\coqdocvar{S} \coqdocvar{o})) \ensuremath{\rightarrow} \coqdocvar{R} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o}\coqdoceol
\coqdocindent{1.50em}
\ensuremath{|} \coqdocvar{c5} : \coqdockw{\ensuremath{\forall}} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o}, \coqdocvar{R} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o} \ensuremath{\rightarrow} \coqdocvar{R} \coqdocvar{n} \coqdocvar{m} \coqdocvar{o}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}



\begin{itemize}
\item  Which of the following propositions are provable?

\begin{itemize}
\item  \coqdocvar{R} 1 1 2

\item  \coqdocvar{R} 2 2 6





\end{itemize}

\item  If we dropped constructor \coqdocvar{c5} from the definition of \coqdocvar{R},
      would the set of provable propositions change?  Briefly (1
      sentence) explain your answer.



\item  If we dropped constructor \coqdocvar{c4} from the definition of \coqdocvar{R},
      would the set of provable propositions change?  Briefly (1
      sentence) explain your answer.

\end{itemize}


\ensuremath{\Box}


\paragraph{Exercise: 3 stars, optional (R\_fact)}

 Relation \coqdocvar{R} actually encodes a familiar function.  State and prove two
    theorems that formally connects the relation and the function. 
    That is, if \coqdocvar{R} \coqdocvar{m} \coqdocvar{n} \coqdocvar{o} is true, what can we say about \coqdocvar{m},
    \coqdocvar{n}, and \coqdocvar{o}, and vice versa?
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqdocvar{R}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 4 stars, advanced (subsequence)}

 A list is a \textit{subsequence} of another list if all of the elements
    in the first list occur in the same order in the second list,
    possibly with some extra elements in between. For example,
    1,2,3
    is a subsequence of each of the lists
    1,2,3
    1,1,1,2,2,3
    1,2,7,3
    5,6,1,9,9,2,7,3,8
    but it is \textit{not} a subsequence of any of the lists
    1,2
    1,3
    5,6,2,1,7,3,8



\begin{itemize}
\item  Define an inductive proposition \coqdocvar{subseq} on \coqdocvar{list} \coqdocvar{nat} that
      captures what it means to be a subsequence. (Hint: You'll need
      three cases.)



\item  Prove \coqdocvar{subseq\_refl} that subsequence is reflexive, that is, 
      any list is a subsequence of itself.  



\item  Prove \coqdocvar{subseq\_app} that for any lists \coqdocvar{l1}, \coqdocvar{l2}, and \coqdocvar{l3}, 
      if \coqdocvar{l1} is a subsequence of \coqdocvar{l2}, then \coqdocvar{l1} is also a subsequence
      of \coqdocvar{l2} ++ \coqdocvar{l3}.



\item  (Optional, harder) Prove \coqdocvar{subseq\_trans} that subsequence is 
      transitive -- that is, if \coqdocvar{l1} is a subsequence of \coqdocvar{l2} and \coqdocvar{l2} 
      is a subsequence of \coqdocvar{l3}, then \coqdocvar{l1} is a subsequence of \coqdocvar{l3}.  
      Hint: choose your induction carefully!

\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars, optional (R\_provability)}

 Suppose we give Coq the following definition:
    Inductive R : nat -> list nat -> Prop :=
      | c1 : R 0 \ensuremath{\Box}
      | c2 : forall n l, R n l -> R (S n) (n :: l)
      | c3 : forall n l, R (S n) l -> R n l.
    Which of the following propositions are provable?



\begin{itemize}
\item  \coqdocvar{R} 2 [1,0]

\item  \coqdocvar{R} 1 [1,2,1,0]

\item  \coqdocvar{R} 6 [3,2,1,0]

\end{itemize}


 \ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Programming with Propositions}



 As we have seen, a \textit{proposition} is a statement expressing a factual claim,
    like ``two plus two equals four.''  In Coq, propositions are written
    as expressions of type \coqdockw{Prop}. . \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (2 + 2 = 4).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqdocvar{ble\_nat} 3 2 = \coqdocvar{false}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqdocvar{beautiful} 8).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 Both provable and unprovable claims are perfectly good
    propositions.  Simply \textit{being} a proposition is one thing; being
    \textit{provable} is something else! \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (2 + 2 = 5).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqdocvar{beautiful} 4).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Both 2 + 2 = 4 and 2 + 2 = 5 are legal expressions
    of type \coqdockw{Prop}. 

\subsubsection{ }

 We've mainly seen one place that propositions can appear in Coq: in
    \coqdockw{Theorem} (and \coqdockw{Lemma} and \coqdockw{Example}) declarations. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_2\_2\_is\_4} : \coqdoceol
\coqdocindent{1.00em}
2 + 2 = 4.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
But they can be used in many other ways.  For example, we have also seen that
    we can give a name to a proposition using a \coqdockw{Definition}, just as we have
    given names to expressions of other sorts. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{plus\_fact} : \coqdockw{Prop}  :=  2 + 2 = 4.\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqdocvar{plus\_fact}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can later use this name in any situation where a proposition is
    expected -- for example, as the claim in a \coqdockw{Theorem} declaration. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_fact\_is\_true} : \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{plus\_fact}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}. \coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 We've seen several ways of constructing propositions.  



\begin{itemize}
\item  We can define a new proposition primitively using \coqdockw{Inductive}.



\item  Given two expressions \coqdocvar{e1} and \coqdocvar{e2} of the same type, we can
         form the proposition \coqdocvar{e1} = \coqdocvar{e2}, which states that their
         values are equal.



\item  We can combine propositions using implication and
         quantification. 
\end{itemize}
\subsubsection{ }

 We have also seen \textit{parameterized propositions}, such as \coqdocvar{even} and
    \coqdocvar{beautiful}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqdocvar{even} 4).\coqdoceol
\coqdocnoindent
\coqdockw{Check} (\coqdocvar{even} 3).\coqdoceol
\coqdocnoindent
\coqdockw{Check} \coqdocvar{even}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 The type of \coqdocvar{even}, i.e., \coqdocvar{nat}\ensuremath{\rightarrow}\coqdockw{Prop}, can be pronounced in
    three equivalent ways: (1) ``\coqdocvar{even} is a \textit{function} from numbers to
    propositions,'' (2) ``\coqdocvar{even} is a \textit{family} of propositions, indexed
    by a number \coqdocvar{n},'' or (3) ``\coqdocvar{even} is a \textit{property} of numbers.''  

 Propositions -- including parameterized propositions -- are
    first-class citizens in Coq.  For example, we can define functions
    from numbers to propositions... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{between} (\coqdocvar{n} \coqdocvar{m} \coqdocvar{o}: \coqdocvar{nat}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{andb} (\coqdocvar{ble\_nat} \coqdocvar{n} \coqdocvar{o}) (\coqdocvar{ble\_nat} \coqdocvar{o} \coqdocvar{m}) = \coqdocvar{true}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
... and then partially apply them: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{teen} : \coqdocvar{nat}\ensuremath{\rightarrow}\coqdockw{Prop} := \coqdocvar{between} 13 19.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can even pass propositions -- including parameterized
    propositions -- as arguments to functions: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{true\_for\_zero} (\coqdocvar{P}:\coqdocvar{nat}\ensuremath{\rightarrow}\coqdockw{Prop}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{P} 0.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 Here are two more examples of passing parameterized propositions
    as arguments to a function.  


    The first function, \coqdocvar{true\_for\_all\_numbers}, takes a proposition
    \coqdocvar{P} as argument and builds the proposition that \coqdocvar{P} is true for
    all natural numbers. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{true\_for\_all\_numbers} (\coqdocvar{P}:\coqdocvar{nat}\ensuremath{\rightarrow}\coqdockw{Prop}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{P} \coqdocvar{n}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The second, \coqdocvar{preserved\_by\_S}, takes \coqdocvar{P} and builds the proposition
    that, if \coqdocvar{P} is true for some natural number \coqdocvar{n'}, then it is also
    true by the successor of \coqdocvar{n'} -- i.e. that \coqdocvar{P} is \textit{preserved by
    successor}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{preserved\_by\_S} (\coqdocvar{P}:\coqdocvar{nat}\ensuremath{\rightarrow}\coqdockw{Prop}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n'}, \coqdocvar{P} \coqdocvar{n'} \ensuremath{\rightarrow} \coqdocvar{P} (\coqdocvar{S} \coqdocvar{n'}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 Finally, we can put these ingredients together to define
a proposition stating that induction is valid for natural numbers: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{natural\_number\_induction\_valid} : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{P}:\coqdocvar{nat}\ensuremath{\rightarrow}\coqdockw{Prop}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{true\_for\_zero} \coqdocvar{P} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{preserved\_by\_S} \coqdocvar{P} \ensuremath{\rightarrow} \coqdoceol
\coqdocindent{2.00em}
\coqdocvar{true\_for\_all\_numbers} \coqdocvar{P}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 3 stars (combine\_odd\_even)}

 Complete the definition of the \coqdocvar{combine\_odd\_even} function
    below. It takes as arguments two properties of numbers \coqdocvar{Podd} and
    \coqdocvar{Peven}. As its result, it should return a new property \coqdocvar{P} such
    that \coqdocvar{P} \coqdocvar{n} is equivalent to \coqdocvar{Podd} \coqdocvar{n} when \coqdocvar{n} is odd, and
    equivalent to \coqdocvar{Peven} \coqdocvar{n} otherwise. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{combine\_odd\_even} (\coqdocvar{Podd} \coqdocvar{Peven} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop}) : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
To test your definition, see whether you can prove the following
    facts: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{combine\_odd\_even\_intro} : \coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{Podd} \coqdocvar{Peven} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop}) (\coqdocvar{n} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.00em}
(\coqdocvar{oddb} \coqdocvar{n} = \coqdocvar{true} \ensuremath{\rightarrow} \coqdocvar{Podd} \coqdocvar{n}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
(\coqdocvar{oddb} \coqdocvar{n} = \coqdocvar{false} \ensuremath{\rightarrow} \coqdocvar{Peven} \coqdocvar{n}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{combine\_odd\_even} \coqdocvar{Podd} \coqdocvar{Peven} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{combine\_odd\_even\_elim\_odd} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{Podd} \coqdocvar{Peven} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop}) (\coqdocvar{n} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{combine\_odd\_even} \coqdocvar{Podd} \coqdocvar{Peven} \coqdocvar{n} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{oddb} \coqdocvar{n} = \coqdocvar{true} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Podd} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{combine\_odd\_even\_elim\_even} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{Podd} \coqdocvar{Peven} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop}) (\coqdocvar{n} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{combine\_odd\_even} \coqdocvar{Podd} \coqdocvar{Peven} \coqdocvar{n} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{oddb} \coqdocvar{n} = \coqdocvar{false} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Peven} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
One more quick digression, for adventurous souls: if we can define
    parameterized propositions using \coqdockw{Definition}, then can we also
    define them using \coqdockw{Fixpoint}?  Of course we can!  However, this
    kind of ``recursive parameterization'' doesn't correspond to
    anything very familiar from everyday mathematics.  The following
    exercise gives a slightly contrived example. 

\paragraph{Exercise: 4 stars, optional (true\_upto\_n\_\_true\_everywhere)}

 Define a recursive function
    \coqdocvar{true\_upto\_n\_\_true\_everywhere} that makes
    \coqdocvar{true\_upto\_n\_example} work. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

 $Date: 2014-12-31 11:17:56 -0500 (Wed, 31 Dec 2014) $ \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{Top.MoreLogic}{Library }{Top.MoreLogic}

\begin{coqdoccode}
\end{coqdoccode}
\section{MoreLogic: More on Logic in Coq}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} "Prop".\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Existential Quantification}



 Another critical logical connective is \textit{existential
    quantification}.  We can express it with the following
    definition: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{ex} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{X}\ensuremath{\rightarrow}\coqdockw{Prop}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ex\_intro} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{witness}:\coqdocvar{X}), \coqdocvar{P} \coqdocvar{witness} \ensuremath{\rightarrow} \coqdocvar{ex} \coqdocvar{X} \coqdocvar{P}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
That is, \coqdocvar{ex} is a family of propositions indexed by a type \coqdocvar{X}
    and a property \coqdocvar{P} over \coqdocvar{X}.  In order to give evidence for the
    assertion ``there exists an \coqdocvar{x} for which the property \coqdocvar{P} holds''
    we must actually name a \textit{witness} -- a specific value \coqdocvar{x} -- and
    then give evidence for \coqdocvar{P} \coqdocvar{x}, i.e., evidence that \coqdocvar{x} has the
    property \coqdocvar{P}. 




\subsubsection{ }

 Coq's \coqdockw{Notation} facility can be used to introduce more
    familiar notation for writing existentially quantified
    propositions, exactly parallel to the built-in syntax for
    universally quantified propositions.  Instead of writing \coqdocvar{ex} \coqdocvar{nat}
    \coqdocvar{ev} to express the proposition that there exists some number that
    is even, for example, we can write \coqdoctac{\ensuremath{\exists}} \coqdocvar{x}:\coqdocvar{nat}, \coqdocvar{ev} \coqdocvar{x}.  (It is
    not necessary to understand exactly how the \coqdockw{Notation} definition
    works.) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "'exists' x , p" := (\coqdocvar{ex} \coqdocvar{\_} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{p}))\coqdoceol
\coqdocindent{1.00em}
(\coqdoctac{at} \coqdockw{level} 200, \coqdocvar{x} \coqdocvar{ident}, \coqdoctac{right} \coqdockw{associativity}) : \coqdocvar{type\_scope}.\coqdoceol
\coqdocnoindent
\coqdockw{Notation} "'exists' x : X , p" := (\coqdocvar{ex} \coqdocvar{\_} (\coqdockw{fun} \coqdocvar{x}:\coqdocvar{X} \ensuremath{\Rightarrow} \coqdocvar{p}))\coqdoceol
\coqdocindent{1.00em}
(\coqdoctac{at} \coqdockw{level} 200, \coqdocvar{x} \coqdocvar{ident}, \coqdoctac{right} \coqdockw{associativity}) : \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 We can use the usual set of tactics for
    manipulating existentials.  For example, to prove an
    existential, we can \coqdoctac{apply} the constructor \coqdocvar{ex\_intro}.  Since the
    premise of \coqdocvar{ex\_intro} involves a variable (\coqdocvar{witness}) that does
    not appear in its conclusion, we need to explicitly give its value
    when we use \coqdoctac{apply}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{exists\_example\_1} : \coqdoctac{\ensuremath{\exists}} \coqdocvar{n}, \coqdocvar{n} + (\coqdocvar{n} \ensuremath{\times} \coqdocvar{n}) = 6.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{ex\_intro} \coqdockw{with} (\coqdocvar{witness}:=2).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Note that we have to explicitly give the witness. 

\subsubsection{ }

 Or, instead of writing \coqdoctac{apply} \coqdocvar{ex\_intro} \coqdockw{with} (\coqdocvar{witness}:=\coqdocvar{e}) all the
    time, we can use the convenient shorthand \coqdoctac{\ensuremath{\exists}} \coqdocvar{e}, which means
    the same thing. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{exists\_example\_1'} : \coqdoctac{\ensuremath{\exists}} \coqdocvar{n}, \coqdocvar{n} + (\coqdocvar{n} \ensuremath{\times} \coqdocvar{n}) = 6.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{\ensuremath{\exists}} 2.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 Conversely, if we have an existential hypothesis in the
    context, we can eliminate it with \coqdoctac{inversion}.  Note the use
    of the \coqdockw{as}... pattern to name the variable that Coq
    introduces to name the witness value and get evidence that
    the hypothesis holds for the witness.  (If we don't
    explicitly choose one, Coq will just call it \coqdocvar{witness}, which
    makes proofs confusing.) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{exists\_example\_2} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n},\coqdoceol
\coqdocindent{1.00em}
(\coqdoctac{\ensuremath{\exists}} \coqdocvar{m}, \coqdocvar{n} = 4 + \coqdocvar{m}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
(\coqdoctac{\ensuremath{\exists}} \coqdocvar{o}, \coqdocvar{n} = 2 + \coqdocvar{o}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{H} \coqdockw{as} [\coqdocvar{m} \coqdocvar{Hm}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{\ensuremath{\exists}} (2 + \coqdocvar{m}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{Hm}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is another example of how to work with existentials. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{exists\_example\_3} : \coqdoceol
\coqdocindent{1.00em}
\coqdoctac{\ensuremath{\exists}} (\coqdocvar{n}:\coqdocvar{nat}), \coqdocvar{even} \coqdocvar{n} \ensuremath{\land} \coqdocvar{beautiful} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{\ensuremath{\exists}} 8.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{even}. \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{b\_sum} \coqdockw{with} (\coqdocvar{n}:=3) (\coqdocvar{m}:=5).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{b\_3}. \coqdoctac{apply} \coqdocvar{b\_5}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star, optional (english\_exists)}

 In English, what does the proposition 
      ex nat (fun n => beautiful (S n))
]] 
    mean? \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star (dist\_not\_exists)}

 Prove that ``\coqdocvar{P} holds for all \coqdocvar{x}'' implies ``there is no \coqdocvar{x} for
    which \coqdocvar{P} does not hold.'' \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{dist\_not\_exists} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{P} \coqdocvar{x}) \ensuremath{\rightarrow} \ensuremath{\lnot} (\coqdoctac{\ensuremath{\exists}} \coqdocvar{x}, \ensuremath{\lnot} \coqdocvar{P} \coqdocvar{x}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars, optional (not\_exists\_dist)}

 (The other direction of this theorem requires the classical ``law
    of the excluded middle''.) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{not\_exists\_dist} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{excluded\_middle} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdockw{Prop}),\coqdoceol
\coqdocindent{2.00em}
\ensuremath{\lnot} (\coqdoctac{\ensuremath{\exists}} \coqdocvar{x}, \ensuremath{\lnot} \coqdocvar{P} \coqdocvar{x}) \ensuremath{\rightarrow} (\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{P} \coqdocvar{x}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars (dist\_exists\_or)}

 Prove that existential quantification distributes over
    disjunction. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{dist\_exists\_or} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{P} \coqdocvar{Q} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdockw{Prop}),\coqdoceol
\coqdocindent{1.00em}
(\coqdoctac{\ensuremath{\exists}} \coqdocvar{x}, \coqdocvar{P} \coqdocvar{x} \ensuremath{\lor} \coqdocvar{Q} \coqdocvar{x}) \ensuremath{\leftrightarrow} (\coqdoctac{\ensuremath{\exists}} \coqdocvar{x}, \coqdocvar{P} \coqdocvar{x}) \ensuremath{\lor} (\coqdoctac{\ensuremath{\exists}} \coqdocvar{x}, \coqdocvar{Q} \coqdocvar{x}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Evidence-Carrying Booleans}



 So far we've seen two different forms of equality predicates:
    \coqdocvar{eq}, which produces a \coqdockw{Prop}, and the type-specific forms, like
    \coqdocvar{beq\_nat}, that produce \coqdocvar{boolean} values.  The former are more
    convenient to reason about, but we've relied on the latter to let
    us use equality tests in \textit{computations}.  While it is
    straightforward to write lemmas (e.g. \coqdocvar{beq\_nat\_true} and
    \coqdocvar{beq\_nat\_false}) that connect the two forms, using these lemmas
    quickly gets tedious. 

\subsubsection{ }

 It turns out that we can get the benefits of both forms at once by
    using a construct called \coqdocvar{sumbool}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{sumbool} (\coqdocvar{A} \coqdocvar{B} : \coqdockw{Prop}) : \coqdockw{Set} :=\coqdoceol
\coqdocindent{0.50em}
\ensuremath{|} \coqdoctac{left} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{sumbool} \coqdocvar{A} \coqdocvar{B} \coqdoceol
\coqdocindent{0.50em}
\ensuremath{|} \coqdoctac{right} : \coqdocvar{B} \ensuremath{\rightarrow} \coqdocvar{sumbool} \coqdocvar{A} \coqdocvar{B}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "\{ A \} + \{ B \}" :=  (\coqdocvar{sumbool} \coqdocvar{A} \coqdocvar{B}) : \coqdocvar{type\_scope}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Think of \coqdocvar{sumbool} as being like the \coqdocvar{boolean} type, but instead
    of its values being just \coqdocvar{true} and \coqdocvar{false}, they carry \textit{evidence}
    of truth or falsity. This means that when we \coqdoctac{destruct} them, we
    are left with the relevant evidence as a hypothesis -- just as
    with \coqdocvar{or}.  (In fact, the definition of \coqdocvar{sumbool} is almost the
    same as for \coqdocvar{or}.  The only difference is that values of \coqdocvar{sumbool}
    are declared to be in \coqdockw{Set} rather than in \coqdockw{Prop}; this is a
    technical distinction that allows us to compute with them.) 

\subsubsection{ }



 Here's how we can define a \coqdocvar{sumbool} for equality on \coqdocvar{nat}s \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{eq\_nat\_dec} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}, \{\coqdocvar{n} = \coqdocvar{m}\} + \{\coqdocvar{n} \ensuremath{\not=} \coqdocvar{m}\}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{n} \coqdockw{as} [|\coqdocvar{n'}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "n = 0".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{m}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{m} \coqdockw{as} [|\coqdocvar{m'}].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "m = 0".\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{left}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "m = S m'".\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{right}. \coqdoctac{intros} \coqdocvar{contra}. \coqdoctac{inversion} \coqdocvar{contra}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "n = S n'".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{m}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{m} \coqdockw{as} [|\coqdocvar{m'}].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "m = 0".\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{right}. \coqdoctac{intros} \coqdocvar{contra}. \coqdoctac{inversion} \coqdocvar{contra}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{SCase} "m = S m'".\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} \coqdocvar{IHn'} \coqdockw{with} (\coqdocvar{m} := \coqdocvar{m'}) \coqdockw{as} [\coqdocvar{eq} \ensuremath{|} \coqdocvar{neq}].\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{left}. \coqdoctac{apply} \coqdoctac{f\_equal}. \coqdoctac{apply} \coqdocvar{eq}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{right}. \coqdoctac{intros} \coqdocvar{Heq}. \coqdoctac{inversion} \coqdocvar{Heq} \coqdockw{as} [\coqdocvar{Heq'}]. \coqdoctac{apply} \coqdocvar{neq}. \coqdoctac{apply} \coqdocvar{Heq'}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Read as a theorem, this says that equality on \coqdocvar{nat}s is decidable:
    that is, given two \coqdocvar{nat} values, we can always produce either
    evidence that they are equal or evidence that they are not.  Read
    computationally, \coqdocvar{eq\_nat\_dec} takes two \coqdocvar{nat} values and returns a
    \coqdocvar{sumbool} constructed with \coqdoctac{left} if they are equal and \coqdoctac{right} if
    they are not; this result can be tested with a \coqdockw{match} or, better,
    with an \coqdockw{if}-\coqdockw{then}-\coqdockw{else}, just like a regular \coqdocvar{boolean}.  (Notice
    that we ended this proof with \coqdockw{Defined} rather than \coqdockw{Qed}.  The
    only difference this makes is that the proof becomes
    \textit{transparent}, meaning that its definition is available when Coq
    tries to do reductions, which is important for the computational
    interpretation.) 

\subsubsection{ }

 Here's a simple example illustrating the advantages of the
   \coqdocvar{sumbool} form. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{override'} \{\coqdocvar{X}: \coqdockw{Type}\} (\coqdocvar{f}: \coqdocvar{nat}\ensuremath{\rightarrow}\coqdocvar{X}) (\coqdocvar{k}:\coqdocvar{nat}) (\coqdocvar{x}:\coqdocvar{X}) : \coqdocvar{nat}\ensuremath{\rightarrow}\coqdocvar{X}:=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} (\coqdocvar{k'}:\coqdocvar{nat}) \ensuremath{\Rightarrow} \coqdockw{if} \coqdocvar{eq\_nat\_dec} \coqdocvar{k} \coqdocvar{k'} \coqdockw{then} \coqdocvar{x} \coqdockw{else} \coqdocvar{f} \coqdocvar{k'}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{override\_same'} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) \coqdocvar{x1} \coqdocvar{k1} \coqdocvar{k2} (\coqdocvar{f} : \coqdocvar{nat}\ensuremath{\rightarrow}\coqdocvar{X}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{f} \coqdocvar{k1} = \coqdocvar{x1} \ensuremath{\rightarrow} \coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{override'} \coqdocvar{f} \coqdocvar{k1} \coqdocvar{x1}) \coqdocvar{k2} = \coqdocvar{f} \coqdocvar{k2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{x1} \coqdocvar{k1} \coqdocvar{k2} \coqdocvar{f}. \coqdoctac{intros} \coqdocvar{Hx1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{override'}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqdocvar{eq\_nat\_dec} \coqdocvar{k1} \coqdocvar{k2}). \coqdocindent{1.00em}
\coqdocvar{Case} "k1 = k2".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{e}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{symmetry}. \coqdoctac{apply} \coqdocvar{Hx1}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "k1 <> k2".\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Compare this to the more laborious proof (in MoreCoq.v) for the
    version of \coqdocvar{override} defined using \coqdocvar{beq\_nat}, where we had to use
    the auxiliary lemma \coqdocvar{beq\_nat\_true} to convert a fact about
    booleans to a Prop. 

\paragraph{Exercise: 1 star (override\_shadow')}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{override\_shadow'} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) \coqdocvar{x1} \coqdocvar{x2} \coqdocvar{k1} \coqdocvar{k2} (\coqdocvar{f} : \coqdocvar{nat}\ensuremath{\rightarrow}\coqdocvar{X}),\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{override'} (\coqdocvar{override'} \coqdocvar{f} \coqdocvar{k1} \coqdocvar{x2}) \coqdocvar{k1} \coqdocvar{x1}) \coqdocvar{k2} = (\coqdocvar{override'} \coqdocvar{f} \coqdocvar{k1} \coqdocvar{x1}) \coqdocvar{k2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Additional Exercises}



\paragraph{Exercise: 3 stars (all\_forallb)}

 Inductively define a property \coqdocvar{all} of lists, parameterized by a
    type \coqdocvar{X} and a property \coqdocvar{P} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdockw{Prop}, such that \coqdocvar{all} \coqdocvar{X} \coqdocvar{P} \coqdocvar{l}
    asserts that \coqdocvar{P} is true for every element of the list \coqdocvar{l}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{all} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdockw{Prop}) : \coqdocvar{list} \coqdocvar{X} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoceol
\coqdocnoindent
.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Recall the function \coqdocvar{forallb}, from the exercise
    \coqdocvar{forall\_exists\_challenge} in chapter \coqdocvar{Poly}: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{forallb} \{\coqdocvar{X} : \coqdockw{Type}\} (\coqdocvar{test} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{bool}) (\coqdocvar{l} : \coqdocvar{list} \coqdocvar{X}) : \coqdocvar{bool} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{l} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} [] \ensuremath{\Rightarrow} \coqdocvar{true}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{x} :: \coqdocvar{l'} \ensuremath{\Rightarrow} \coqdocvar{andb} (\coqdocvar{test} \coqdocvar{x}) (\coqdocvar{forallb} \coqdocvar{test} \coqdocvar{l'})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Using the property \coqdocvar{all}, write down a specification for \coqdocvar{forallb},
    and prove that it satisfies the specification. Try to make your 
    specification as precise as possible.


    Are there any important properties of the function \coqdocvar{forallb} which
    are not captured by your specification? \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 4 stars, advanced (filter\_challenge)}

 One of the main purposes of Coq is to prove that programs match
    their specifications.  To this end, let's prove that our
    definition of \coqdocvar{filter} matches a specification.  Here is the
    specification, written out informally in English.


    Suppose we have a set \coqdocvar{X}, a function \coqdocvar{test}: \coqdocvar{X}\ensuremath{\rightarrow}\coqdocvar{bool}, and a list
    \coqdocvar{l} of type \coqdocvar{list} \coqdocvar{X}.  Suppose further that \coqdocvar{l} is an ``in-order
    merge'' of two lists, \coqdocvar{l1} and \coqdocvar{l2}, such that every item in \coqdocvar{l1}
    satisfies \coqdocvar{test} and no item in \coqdocvar{l2} satisfies test.  Then \coqdocvar{filter}
    \coqdocvar{test} \coqdocvar{l} = \coqdocvar{l1}.


    A list \coqdocvar{l} is an ``in-order merge'' of \coqdocvar{l1} and \coqdocvar{l2} if it contains
    all the same elements as \coqdocvar{l1} and \coqdocvar{l2}, in the same order as \coqdocvar{l1}
    and \coqdocvar{l2}, but possibly interleaved.  For example, 
    1,4,6,2,3
    is an in-order merge of
    1,6,2
    and
    4,3.
    Your job is to translate this specification into a Coq theorem and
    prove it.  (Hint: You'll need to begin by defining what it means
    for one list to be a merge of two others.  Do this with an
    inductive relation, not a \coqdockw{Fixpoint}.)  \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 5 stars, advanced, optional (filter\_challenge\_2)}

 A different way to formally characterize the behavior of \coqdocvar{filter}
    goes like this: Among all subsequences of \coqdocvar{l} with the property
    that \coqdocvar{test} evaluates to \coqdocvar{true} on all their members, \coqdocvar{filter} \coqdocvar{test}
    \coqdocvar{l} is the longest.  Express this claim formally and prove it. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 4 stars, advanced (no\_repeats)}

 The following inductively defined proposition... \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{appears\_in} \{\coqdocvar{X}:\coqdockw{Type}\} (\coqdocvar{a}:\coqdocvar{X}) : \coqdocvar{list} \coqdocvar{X} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{ai\_here} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l}, \coqdocvar{appears\_in} \coqdocvar{a} (\coqdocvar{a}::\coqdocvar{l})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{ai\_later} : \coqdockw{\ensuremath{\forall}} \coqdocvar{b} \coqdocvar{l}, \coqdocvar{appears\_in} \coqdocvar{a} \coqdocvar{l} \ensuremath{\rightarrow} \coqdocvar{appears\_in} \coqdocvar{a} (\coqdocvar{b}::\coqdocvar{l}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
...gives us a precise way of saying that a value \coqdocvar{a} appears at
    least once as a member of a list \coqdocvar{l}. 


    Here's a pair of warm-ups about \coqdocvar{appears\_in}.
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{appears\_in\_app} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{xs} \coqdocvar{ys} : \coqdocvar{list} \coqdocvar{X}) (\coqdocvar{x}:\coqdocvar{X}), \coqdoceol
\coqdocindent{2.50em}
\coqdocvar{appears\_in} \coqdocvar{x} (\coqdocvar{xs} ++ \coqdocvar{ys}) \ensuremath{\rightarrow} \coqdocvar{appears\_in} \coqdocvar{x} \coqdocvar{xs} \ensuremath{\lor} \coqdocvar{appears\_in} \coqdocvar{x} \coqdocvar{ys}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{app\_appears\_in} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{xs} \coqdocvar{ys} : \coqdocvar{list} \coqdocvar{X}) (\coqdocvar{x}:\coqdocvar{X}), \coqdoceol
\coqdocindent{2.50em}
\coqdocvar{appears\_in} \coqdocvar{x} \coqdocvar{xs} \ensuremath{\lor} \coqdocvar{appears\_in} \coqdocvar{x} \coqdocvar{ys} \ensuremath{\rightarrow} \coqdocvar{appears\_in} \coqdocvar{x} (\coqdocvar{xs} ++ \coqdocvar{ys}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now use \coqdocvar{appears\_in} to define a proposition \coqdocvar{disjoint} \coqdocvar{X} \coqdocvar{l1} \coqdocvar{l2},
    which should be provable exactly when \coqdocvar{l1} and \coqdocvar{l2} are
    lists (with elements of type X) that have no elements in common. \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Next, use \coqdocvar{appears\_in} to define an inductive proposition
    \coqdocvar{no\_repeats} \coqdocvar{X} \coqdocvar{l}, which should be provable exactly when \coqdocvar{l} is a
    list (with elements of type \coqdocvar{X}) where every member is different
    from every other.  For example, \coqdocvar{no\_repeats} \coqdocvar{nat} [1,2,3,4] and
    \coqdocvar{no\_repeats} \coqdocvar{bool} [] should be provable, while \coqdocvar{no\_repeats} \coqdocvar{nat}
    [1,2,1] and \coqdocvar{no\_repeats} \coqdocvar{bool} [\coqdocvar{true},\coqdocvar{true}] should not be.  \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Finally, state and prove one or more interesting theorems relating
    \coqdocvar{disjoint}, \coqdocvar{no\_repeats} and ++ (list append).  \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 3 stars (nostutter)}

 Formulating inductive definitions of predicates is an important
    skill you'll need in this course.  Try to solve this exercise
    without any help at all.


    We say that a list of numbers ``stutters'' if it repeats the same
    number consecutively.  The predicate ``\coqdocvar{nostutter} \coqdocvar{mylist}'' means
    that \coqdocvar{mylist} does not stutter.  Formulate an inductive definition
    for \coqdocvar{nostutter}.  (This is different from the \coqdocvar{no\_repeats}
    predicate in the exercise above; the sequence 1;4;1 repeats but
    does not stutter.) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{nostutter}:  \coqdocvar{list} \coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{0.50em}
\coqdoceol
\coqdocnoindent
.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Make sure each of these tests succeeds, but you are free
    to change the proof if the given one doesn't work for you.
    Your definition might be different from mine and still correct,
    in which case the examples might need a different proof.


    The suggested proofs for the examples (in comments) use a number
    of tactics we haven't talked about, to try to make them robust
    with respect to different possible ways of defining \coqdocvar{nostutter}.
    You should be able to just uncomment and use them as-is, but if
    you prefer you can also prove each example with more basic
    tactics.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_nostutter\_1}:      \coqdocvar{nostutter} [3;1;4;1;5;6].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_nostutter\_2}:  \coqdocvar{nostutter} [].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_nostutter\_3}:  \coqdocvar{nostutter} [5].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{test\_nostutter\_4}:      \coqdocvar{not} (\coqdocvar{nostutter} [3;1;1;4]).\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 4 stars, advanced (pigeonhole principle)}

 The ``pigeonhole principle'' states a basic fact about counting:
   if you distribute more than \coqdocvar{n} items into \coqdocvar{n} pigeonholes, some 
   pigeonhole must contain at least two items.  As is often the case,
   this apparently trivial fact about numbers requires non-trivial
   machinery to prove, but we now have enough... 

 First a pair of useful lemmas (we already proved these for lists
    of naturals, but not for arbitrary lists). \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{app\_length} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{l1} \coqdocvar{l2} : \coqdocvar{list} \coqdocvar{X}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{length} (\coqdocvar{l1} ++ \coqdocvar{l2}) = \coqdocvar{length} \coqdocvar{l1} + \coqdocvar{length} \coqdocvar{l2}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{appears\_in\_app\_split} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{x}:\coqdocvar{X}) (\coqdocvar{l}:\coqdocvar{list} \coqdocvar{X}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{appears\_in} \coqdocvar{x} \coqdocvar{l} \ensuremath{\rightarrow} \coqdoceol
\coqdocindent{1.00em}
\coqdoctac{\ensuremath{\exists}} \coqdocvar{l1}, \coqdoctac{\ensuremath{\exists}} \coqdocvar{l2}, \coqdocvar{l} = \coqdocvar{l1} ++ (\coqdocvar{x}::\coqdocvar{l2}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now define a predicate \coqdocvar{repeats} (analogous to \coqdocvar{no\_repeats} in the
   exercise above), such that \coqdocvar{repeats} \coqdocvar{X} \coqdocvar{l} asserts that \coqdocvar{l} contains
   at least one repeated element (of type \coqdocvar{X}).  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{repeats} \{\coqdocvar{X}:\coqdockw{Type}\} : \coqdocvar{list} \coqdocvar{X} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoceol
\coqdocnoindent
.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now here's a way to formalize the pigeonhole principle. List \coqdocvar{l2}
    represents a list of pigeonhole labels, and list \coqdocvar{l1} represents
    the labels assigned to a list of items: if there are more items
    than labels, at least two items must have the same label.  This
    proof is much easier if you use the \coqdocvar{excluded\_middle} hypothesis
    to show that \coqdocvar{appears\_in} is decidable, i.e. \coqdockw{\ensuremath{\forall}} \coqdocvar{x}
    \coqdocvar{l}, (\coqdocvar{appears\_in} \coqdocvar{x} \coqdocvar{l}) \ensuremath{\lor} \ensuremath{\lnot} (\coqdocvar{appears\_in} \coqdocvar{x} \coqdocvar{l}).  However, it is also
    possible to make the proof go through \textit{without} assuming that
    \coqdocvar{appears\_in} is decidable; if you can manage to do this, you will
    not need the \coqdocvar{excluded\_middle} hypothesis. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{pigeonhole\_principle}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{X}:\coqdockw{Type}) (\coqdocvar{l1}  \coqdocvar{l2}:\coqdocvar{list} \coqdocvar{X}), \coqdoceol
\coqdocindent{1.50em}
\coqdocvar{excluded\_middle} \ensuremath{\rightarrow} \coqdoceol
\coqdocindent{1.50em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{appears\_in} \coqdocvar{x} \coqdocvar{l1} \ensuremath{\rightarrow} \coqdocvar{appears\_in} \coqdocvar{x} \coqdocvar{l2}) \ensuremath{\rightarrow} \coqdoceol
\coqdocindent{1.50em}
\coqdocvar{length} \coqdocvar{l2} < \coqdocvar{length} \coqdocvar{l1} \ensuremath{\rightarrow} \coqdoceol
\coqdocindent{1.50em}
\coqdocvar{repeats} \coqdocvar{l1}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{l1}. \coqdoctac{induction} \coqdocvar{l1} \coqdockw{as} [|\coqdocvar{x} \coqdocvar{l1'}].\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
$Date: 2014-12-31 16:01:37 -0500 (Wed, 31 Dec 2014) $ \begin{coqdoccode}
\end{coqdoccode}
\coqlibrary{Top.ProofObjects}{Library }{Top.ProofObjects}

\begin{coqdoccode}
\end{coqdoccode}
\section{ProofObjects: Working with Explicit Evidence in Coq}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqdocvar{MoreLogic}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
 We have seen that Coq has mechanisms both for \textit{programming},
    using inductive data types (like \coqdocvar{nat} or \coqdocvar{list}) and functions
    over these types, and for \textit{proving} properties of these programs,
    using inductive propositions (like \coqdocvar{ev} or \coqdocvar{eq}), implication, and 
    universal quantification.  So far, we have treated these mechanisms
    as if they were quite separate, and for many purposes this is
    a good way to think. But we have also seen hints that Coq's programming and 
    proving facilities are closely related. For example, the
    keyword \coqdockw{Inductive} is used to declare both data types and 
    propositions, and \ensuremath{\rightarrow} is used both to describe the type of
    functions on data and logical implication. This is not just a
    syntactic accident!  In fact, programs and proofs in Coq are almost
    the same thing.  In this chapter we will study how this works.


    We have already seen the fundamental idea: provability in Coq is
    represented by concrete \textit{evidence}.  When we construct the proof
    of a basic proposition, we are actually building a tree of evidence, 
    which can be thought of as a data structure. If the proposition
    is an implication like \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}, then its proof will be an 
    evidence \textit{transformer}: a recipe for converting evidence for
    A into evidence for B.  So at a fundamental level, proofs are simply
    programs that manipulate evidence.


    Q. If evidence is data, what are propositions themselves?


    A. They are types!


    Look again at the formal definition of the \coqdocvar{beautiful} property.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqdocvar{beautiful}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }



 The trick is to introduce an alternative pronunciation of ``:''.
    Instead of ``has type,'' we can also say ``is a proof of.''  For
    example, the second line in the definition of \coqdocvar{beautiful} declares
    that \coqdocvar{b\_0} : \coqdocvar{beautiful} 0.  Instead of ``\coqdocvar{b\_0} has type 
    \coqdocvar{beautiful} 0,'' we can say that ``\coqdocvar{b\_0} is a proof of \coqdocvar{beautiful} 0.''
    Similarly for \coqdocvar{b\_3} and \coqdocvar{b\_5}. 

\subsubsection{ }



 This pun between types and propositions (between : as ``has type''
    and : as ``is a proof of'' or ``is evidence for'') is called the
    \textit{Curry-Howard correspondence}.  It proposes a deep connection
    between the world of logic and the world of computation.
\begin{verbatim}
                 propositions  ~  types
                 proofs        ~  data values
\end{verbatim}
    Many useful insights follow from this connection.  To begin with, it
    gives us a natural interpretation of the type of \coqdocvar{b\_sum} constructor: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{b\_sum}.\coqdoceol
\end{coqdoccode}
This can be read ``\coqdocvar{b\_sum} is a constructor that takes four
    arguments -- two numbers, \coqdocvar{n} and \coqdocvar{m}, and two pieces of evidence,
    for the propositions \coqdocvar{beautiful} \coqdocvar{n} and \coqdocvar{beautiful} \coqdocvar{m}, respectively -- 
    and yields evidence for the proposition \coqdocvar{beautiful} (\coqdocvar{n}+\coqdocvar{m}).'' 

 Now let's look again at a previous proof involving \coqdocvar{beautiful}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{eight\_is\_beautiful}: \coqdocvar{beautiful} 8.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{b\_sum} \coqdockw{with} (\coqdocvar{n} := 3) (\coqdocvar{m} := 5).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{b\_3}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{b\_5}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Just as with ordinary data values and functions, we can use the \coqdockw{Print}
command to see the \textit{proof object} that results from this proof script. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqdocvar{eight\_is\_beautiful}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In view of this, we might wonder whether we can write such
    an expression ourselves. Indeed, we can: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} (\coqdocvar{b\_sum} 3 5 \coqdocvar{b\_3} \coqdocvar{b\_5}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The expression \coqdocvar{b\_sum} 3 5 \coqdocvar{b\_3} \coqdocvar{b\_5} can be thought of as
    instantiating the parameterized constructor \coqdocvar{b\_sum} with the
    specific arguments 3 5 and the corresponding proof objects for
    its premises \coqdocvar{beautiful} 3 and \coqdocvar{beautiful} 5 (Coq is smart enough
    to figure out that 3+5=8).  Alternatively, we can think of \coqdocvar{b\_sum}
    as a primitive ``evidence constructor'' that, when applied to two
    particular numbers, wants to be further applied to evidence that
    those two numbers are beautiful; its type, 
    forall n m, beautiful n -> beautiful m -> beautiful (n+m),
    expresses this functionality, in the same way that the polymorphic
    type \coqdockw{\ensuremath{\forall}} \coqdocvar{X}, \coqdocvar{list} \coqdocvar{X} in the previous chapter expressed the fact
    that the constructor \coqdocvar{nil} can be thought of as a function from
    types to empty lists with elements of that type. 

 This gives us an alternative way to write the proof that 8 is
    beautiful: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{eight\_is\_beautiful'}: \coqdocvar{beautiful} 8.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{apply} (\coqdocvar{b\_sum} 3 5 \coqdocvar{b\_3} \coqdocvar{b\_5}).\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Notice that we're using \coqdoctac{apply} here in a new way: instead of just
    supplying the \textit{name} of a hypothesis or previously proved theorem
    whose type matches the current goal, we are supplying an
    \textit{expression} that directly builds evidence with the required
    type. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Proof Scripts and Proof Objects}



 These proof objects lie at the core of how Coq operates. 


    When Coq is following a proof script, what is happening internally
    is that it is gradually constructing a proof object -- a term
    whose type is the proposition being proved.  The tactics between
    the \coqdockw{Proof} command and the \coqdockw{Qed} instruct Coq how to build up a
    term of the required type.  To see this process in action, let's
    use the \coqdockw{Show} \coqdockw{Proof} command to display the current state of the
    proof tree at various points in the following tactic proof. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{eight\_is\_beautiful'{}'}: \coqdocvar{beautiful} 8.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdockw{Show} \coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{apply} \coqdocvar{b\_sum} \coqdockw{with} (\coqdocvar{n}:=3) (\coqdocvar{m}:=5).\coqdoceol
\coqdocindent{1.50em}
\coqdockw{Show} \coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{apply} \coqdocvar{b\_3}.\coqdoceol
\coqdocindent{1.50em}
\coqdockw{Show} \coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{apply} \coqdocvar{b\_5}.\coqdoceol
\coqdocindent{1.50em}
\coqdockw{Show} \coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
At any given moment, Coq has constructed a term with some
    ``holes'' (indicated by ?1, ?2, and so on), and it knows what
    type of evidence is needed at each hole.  



    Each of the holes corresponds to a subgoal, and the proof is
    finished when there are no more subgoals.  At this point, the
    \coqdockw{Theorem} command gives a name to the evidence we've built and
    stores it in the global context. 

 Tactic proofs are useful and convenient, but they are not
    essential: in principle, we can always construct the required
    evidence by hand, as shown above. Then we can use \coqdockw{Definition} 
    (rather than \coqdockw{Theorem}) to give a global name directly to a 
    piece of evidence. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{eight\_is\_beautiful'{}'{}'} : \coqdocvar{beautiful} 8 :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{b\_sum} 3 5 \coqdocvar{b\_3} \coqdocvar{b\_5}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
All these different ways of building the proof lead to exactly the
    same evidence being saved in the global environment. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqdocvar{eight\_is\_beautiful}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdocvar{eight\_is\_beautiful'}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdocvar{eight\_is\_beautiful'{}'}.\coqdoceol
\coqdocnoindent
\coqdockw{Print} \coqdocvar{eight\_is\_beautiful'{}'{}'}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 1 star (six\_is\_beautiful)}

 Give a tactic proof and a proof object showing that 6 is \coqdocvar{beautiful}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{six\_is\_beautiful} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beautiful} 6.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{six\_is\_beautiful'} : \coqdocvar{beautiful} 6 :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 1 star (nine\_is\_beautiful)}

 Give a tactic proof and a proof object showing that 9 is \coqdocvar{beautiful}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{nine\_is\_beautiful} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{beautiful} 9.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{nine\_is\_beautiful'} : \coqdocvar{beautiful} 9 :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Quantification, Implications and Functions}



 In Coq's computational universe (where we've mostly been living
    until this chapter), there are two sorts of values with arrows in
    their types: \textit{constructors} introduced by \coqdockw{Inductive}-ly defined
    data types, and \textit{functions}.


    Similarly, in Coq's logical universe, there are two ways of giving
    evidence for an implication: constructors introduced by
    \coqdockw{Inductive}-ly defined propositions, and... functions!


    For example, consider this statement: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{b\_plus3}: \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{beautiful} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{beautiful} (3+\coqdocvar{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{apply} \coqdocvar{b\_sum}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{apply} \coqdocvar{b\_3}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
What is the proof object corresponding to \coqdocvar{b\_plus3}? 


    We're looking for an expression whose \textit{type} is \coqdockw{\ensuremath{\forall}} \coqdocvar{n},
    \coqdocvar{beautiful} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{beautiful} (3+\coqdocvar{n}) -- that is, a \textit{function} that
    takes two arguments (one number and a piece of evidence) and
    returns a piece of evidence!  Here it is: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{b\_plus3'} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{beautiful} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{beautiful} (3+\coqdocvar{n}) := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} (\coqdocvar{n} : \coqdocvar{nat}) \ensuremath{\Rightarrow} \coqdockw{fun} (\coqdocvar{H} : \coqdocvar{beautiful} \coqdocvar{n}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{b\_sum} 3 \coqdocvar{n} \coqdocvar{b\_3} \coqdocvar{H}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{b\_plus3'}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Recall that \coqdockw{fun} \coqdocvar{n} \ensuremath{\Rightarrow} \coqdocvar{blah} means ``the function that, given \coqdocvar{n},
    yields \coqdocvar{blah}.''  Another equivalent way to write this definition is: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{b\_plus3'{}'} (\coqdocvar{n} : \coqdocvar{nat}) (\coqdocvar{H} : \coqdocvar{beautiful} \coqdocvar{n}) : \coqdocvar{beautiful} (3+\coqdocvar{n}) := \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{b\_sum} 3 \coqdocvar{n} \coqdocvar{b\_3} \coqdocvar{H}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{b\_plus3'{}'}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
When we view the proposition being proved by \coqdocvar{b\_plus3} as a function type,
    one aspect of it may seem a little unusual. The second argument's
    type, \coqdocvar{beautiful} \coqdocvar{n}, mentions the \textit{value} of the first argument, \coqdocvar{n}.
    While such \textit{dependent types} are not commonly found in programming
    languages, even functional ones like ML or Haskell, they can
    be useful there too.  


    Notice that both implication (\ensuremath{\rightarrow}) and quantification (\coqdockw{\ensuremath{\forall}})
    correspond to functions on evidence.  In fact, they are really the
    same thing: \ensuremath{\rightarrow} is just a shorthand for a degenerate use of
    \coqdockw{\ensuremath{\forall}} where there is no dependency, i.e., no need to give a name
    to the type on the LHS of the arrow. 

 For example, consider this proposition: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{beautiful\_plus3} : \coqdockw{Prop} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdockw{\ensuremath{\forall}} (\coqdocvar{E} : \coqdocvar{beautiful} \coqdocvar{n}), \coqdocvar{beautiful} (\coqdocvar{n}+3).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A proof term inhabiting this proposition would be a function
    with two arguments: a number \coqdocvar{n} and some evidence \coqdocvar{E} that \coqdocvar{n} is
    beautiful.  But the name \coqdocvar{E} for this evidence is not used in the
    rest of the statement of \coqdocvar{funny\_prop1}, so it's a bit silly to
    bother making up a name for it.  We could write it like this
    instead, using the dummy identifier \coqdocvar{\_} in place of a real
    name: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{beautiful\_plus3'} : \coqdockw{Prop} := \coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdockw{\ensuremath{\forall}} (\coqdocvar{\_} : \coqdocvar{beautiful} \coqdocvar{n}), \coqdocvar{beautiful} (\coqdocvar{n}+3).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Or, equivalently, we can write it in more familiar notation: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{beatiful\_plus3'{}'} : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{beautiful} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{beautiful} (\coqdocvar{n}+3).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In general, ``\coqdocvar{P} \ensuremath{\rightarrow} \coqdocvar{Q}'' is just syntactic sugar for
    ``\coqdockw{\ensuremath{\forall}} (\coqdocvar{\_}:\coqdocvar{P}), \coqdocvar{Q}''. 

\paragraph{Exercise: 2 stars b\_times2}



 Give a proof object corresponding to the theorem \coqdocvar{b\_times2} from Prop.v \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{b\_times2'}: \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{beautiful} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{beautiful} (2*\coqdocvar{n}) :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars, optional (gorgeous\_plus13\_po)}

 Give a proof object corresponding to the theorem \coqdocvar{gorgeous\_plus13} from Prop.v \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{gorgeous\_plus13\_po}: \coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{gorgeous} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{gorgeous} (13+\coqdocvar{n}):=\coqdoceol
\coqdocindent{1.50em}
 \coqdocvar{admit}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

 It is particularly revealing to look at proof objects involving the 
logical connectives that we defined with inductive propositions in Logic.v. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{and\_example} : \coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{beautiful} 0) \ensuremath{\land} (\coqdocvar{beautiful} 3).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{conj}.\coqdoceol
 \coqdoctac{apply} \coqdocvar{b\_0}.\coqdoceol
 \coqdoctac{apply} \coqdocvar{b\_3}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Let's take a look at the proof object for the above theorem. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqdocvar{and\_example}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Note that the proof is of the form
    conj (beautiful 0) (beautiful 3) 
         (...pf of beautiful 3...) (...pf of beautiful 3...)
    as you'd expect, given the type of \coqdocvar{conj}. 

\paragraph{Exercise: 1 star, optional (case\_proof\_objects)}

 The \coqdocvar{Case} tactics were commented out in the proof of
    \coqdocvar{and\_example} to avoid cluttering the proof object.  What would
    you guess the proof object will look like if we uncomment them?
    Try it and see.  \ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{and\_commut} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} : \coqdockw{Prop}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{P} \ensuremath{\land} \coqdocvar{Q} \ensuremath{\rightarrow} \coqdocvar{Q} \ensuremath{\land} \coqdocvar{P}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{H} \coqdockw{as} [\coqdocvar{HP} \coqdocvar{HQ}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
 \coqdoctac{apply} \coqdocvar{HQ}.\coqdoceol
 \coqdoctac{apply} \coqdocvar{HP}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Once again, we have commented out the \coqdocvar{Case} tactics to make the
    proof object for this theorem easier to understand. It is still
    a little complicated, but after performing some simple reduction
    steps, we can see that all that is really happening is taking apart 
    a record containing evidence for \coqdocvar{P} and \coqdocvar{Q} and rebuilding it in the
    opposite order: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqdocvar{and\_commut}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
After simplifying some direct application of \coqdockw{fun} expressions to arguments,
we get: \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars, optional (conj\_fact)}

 Construct a proof object demonstrating the following proposition. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{conj\_fact} : \coqdockw{\ensuremath{\forall}} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{R}, \coqdocvar{P} \ensuremath{\land} \coqdocvar{Q} \ensuremath{\rightarrow} \coqdocvar{Q} \ensuremath{\land} \coqdocvar{R} \ensuremath{\rightarrow} \coqdocvar{P} \ensuremath{\land} \coqdocvar{R} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars, advanced, optional (beautiful\_iff\_gorgeous)}



 We have seen that the families of propositions \coqdocvar{beautiful} and
    \coqdocvar{gorgeous} actually characterize the same set of numbers.
    Prove that \coqdocvar{beautiful} \coqdocvar{n} \ensuremath{\leftrightarrow} \coqdocvar{gorgeous} \coqdocvar{n} for all \coqdocvar{n}.  Just for
    fun, write your proof as an explicit proof object, rather than
    using tactics. (\textit{Hint}: if you make use of previously defined
    theorems, you should only need a single line!) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{beautiful\_iff\_gorgeous} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{n}, \coqdocvar{beautiful} \coqdocvar{n} \ensuremath{\leftrightarrow} \coqdocvar{gorgeous} \coqdocvar{n} :=\coqdoceol
\coqdocindent{1.00em}
 \coqdocvar{admit}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} 

\paragraph{Exercise: 2 stars, optional (or\_commut'')}

 Try to write down an explicit proof object for \coqdocvar{or\_commut} (without
    using \coqdockw{Print} to peek at the ones we already defined!). \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\ensuremath{\Box} 

 Recall that we model an existential for a property as a pair consisting of 
a witness value and a proof that the witness obeys that property. 
We can choose to construct the proof explicitly. 


For example, consider this existentially quantified proposition: \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Check} \coqdocvar{ex}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{some\_nat\_is\_even} : \coqdockw{Prop} := \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ex} \coqdocvar{\_} \coqdocvar{ev}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
To prove this proposition, we need to choose a particular number
    as witness -- say, 4 -- and give some evidence that that number is
    even. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{snie} : \coqdocvar{some\_nat\_is\_even} := \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{ex\_intro} \coqdocvar{\_} \coqdocvar{ev} 4 (\coqdocvar{ev\_SS} 2 (\coqdocvar{ev\_SS} 0 \coqdocvar{ev\_0})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars, optional (ex\_beautiful\_Sn)}

 Complete the definition of the following proof object: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{p} : \coqdocvar{ex} \coqdocvar{\_} (\coqdockw{fun} \coqdocvar{n} \ensuremath{\Rightarrow} \coqdocvar{beautiful} (\coqdocvar{S} \coqdocvar{n})) :=\coqdoceol
\coqdocnoindent
 \coqdocvar{admit}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Giving Explicit Arguments to Lemmas and Hypotheses}



 Even when we are using tactic-based proof, it can be very useful to
understand the underlying functional nature of implications and quantification. 


For example, it is often convenient to \coqdoctac{apply} or \coqdoctac{rewrite} 
using a lemma or hypothesis with one or more quantifiers or 
assumptions already instantiated in order to direct what
happens.  For example: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{plus\_comm}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{plus\_comm\_r} : \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c}, \coqdocvar{c} + (\coqdocvar{b} + \coqdocvar{a}) = \coqdocvar{c} + (\coqdocvar{a} + \coqdocvar{b}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{intros} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{rewrite} (\coqdocvar{plus\_comm} \coqdocvar{b} \coqdocvar{a}). \coqdocindent{1.50em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In this case, giving just one argument would be sufficient. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{plus\_comm\_r'} : \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c}, \coqdocvar{c} + (\coqdocvar{b} + \coqdocvar{a}) = \coqdocvar{c} + (\coqdocvar{a} + \coqdocvar{b}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{intros} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c}.\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{rewrite} (\coqdocvar{plus\_comm} \coqdocvar{b}).\coqdoceol
\coqdocindent{1.50em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Arguments must be given in order, but wildcards (\_)
may be used to skip arguments that Coq can infer.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{plus\_comm\_r'{}'} : \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c}, \coqdocvar{c} + (\coqdocvar{b} + \coqdocvar{a}) = \coqdocvar{c} + (\coqdocvar{a} + \coqdocvar{b}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} (\coqdocvar{plus\_comm} \coqdocvar{\_} \coqdocvar{a}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The author of a lemma can choose to declare easily inferable arguments
to be implicit, just as with functions and constructors. 


  The \coqdockw{with} clauses we've already seen is really just a way of
  specifying selected arguments by name rather than position:  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{plus\_comm\_r'{}'{}'} : \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c}, \coqdocvar{c} + (\coqdocvar{b} + \coqdocvar{a}) = \coqdocvar{c} + (\coqdocvar{a} + \coqdocvar{b}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{rewrite} \coqdocvar{plus\_comm} \coqdockw{with} (\coqdocvar{n} := \coqdocvar{b}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\paragraph{Exercise: 2 stars (trans\_eq\_example\_redux)}

 Redo the proof of the following theorem (from MoreCoq.v) using
an \coqdoctac{apply} of \coqdocvar{trans\_eq} but \textit{not} using a \coqdockw{with} clause. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Example} \coqdocvar{trans\_eq\_example'} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{a} \coqdocvar{b} \coqdocvar{c} \coqdocvar{d} \coqdocvar{e} \coqdocvar{f} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{a};\coqdocvar{b}] = [\coqdocvar{c};\coqdocvar{d}] \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{c};\coqdocvar{d}] = [\coqdocvar{e};\coqdocvar{f}] \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.50em}
[\coqdocvar{a};\coqdocvar{b}] = [\coqdocvar{e};\coqdocvar{f}].\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
 \coqdocvar{Admitted}.\coqdoceol
\end{coqdoccode}
\ensuremath{\Box} \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Programming with Tactics (Advanced)}



 If we can build proofs with explicit terms rather than tactics,
    you may be wondering if we can build programs using tactics rather
    than explicit terms.  Sure! \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{add1} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat}.\coqdoceol
\coqdocnoindent
\coqdoctac{intro} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Show} \coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdoctac{apply} \coqdocvar{S}.\coqdoceol
\coqdocnoindent
\coqdockw{Show} \coqdockw{Proof}.\coqdoceol
\coqdocnoindent
\coqdoctac{apply} \coqdocvar{n}. \coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Print} \coqdocvar{add1}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Eval} \coqdoctac{compute} \coqdoctac{in} \coqdocvar{add1} 2.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Notice that we terminate the \coqdockw{Definition} with a . rather than with
:= followed by a term.  This tells Coq to enter proof scripting mode
to build an object of type \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{nat}.  Also, we terminate the proof
with \coqdockw{Defined} rather than \coqdockw{Qed}; this makes the definition \textit{transparent}
so that it can be used in computation like a normally-defined function.  


This feature is mainly useful for writing functions with dependent types,
which we won't explore much further in this book.
But it does illustrate the uniformity and orthogonality of the basic ideas in Coq. 

 $Date: 2014-12-31 15:31:47 -0500 (Wed, 31 Dec 2014) $ \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{Top.MoreInd}{Library }{Top.MoreInd}

\begin{coqdoccode}
\end{coqdoccode}
\section{MoreInd: More on Induction}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} "ProofObjects".\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Induction Principles}



 This is a good point to pause and take a deeper look at induction
    principles. 


    Every time we declare a new \coqdockw{Inductive} datatype, Coq
    automatically generates and proves an \textit{induction principle} 
    for this type.


    The induction principle for a type \coqdocvar{t} is called \coqdocvar{t\_ind}.  Here is
    the one for natural numbers: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Check} \coqdocvar{nat\_ind}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{ }

 The \coqdoctac{induction} tactic is a straightforward wrapper that, at
    its core, simply performs \coqdoctac{apply} \coqdocvar{t\_ind}.  To see this more
    clearly, let's experiment a little with using \coqdoctac{apply} \coqdocvar{nat\_ind}
    directly, instead of the \coqdoctac{induction} tactic, to carry out some
    proofs.  Here, for example, is an alternate proof of a theorem
    that we saw in the \coqdocvar{Basics} chapter. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{mult\_0\_r'} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} \ensuremath{\times} 0 = 0.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{nat\_ind}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "O". \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Case} "S". \coqdoctac{simpl}. \coqdoctac{intros} \coqdocvar{n} \coqdocvar{IHn}. \coqdoctac{rewrite} \ensuremath{\rightarrow} \coqdocvar{IHn}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{reflexivity}. \coqdockw{Qed}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This proof is basically the same as the earlier one, but a
    few minor differences are worth noting.  First, in the induction
    step of the proof (the "\coqdocvar{S}" case), we have to do a little
    bookkeeping manually (the \coqdoctac{intros}) that \coqdoctac{induction} does
    automatically.


    Second, we do not introduce \coqdocvar{n} into the context before applying
    \coqdocvar{nat\_ind} -- the conclusion of \coqdocvar{nat\_ind} is a quantified formula,
    and \coqdoctac{apply} needs this conclusion to exactly match the shape of
    the goal state, including the quantifier.  The \coqdoctac{induction} tactic
    works either with a variable in the context or a quantified
    variable in the goal.


    Third, the \coqdoctac{apply} tactic automatically chooses variable names for
    us (in the second subgoal, here), whereas \coqdoctac{induction} lets us
    specify (with the \coqdockw{as}...  clause) what names should be used.  The
    automatic choice is actually a little unfortunate, since it
    re-uses the name \coqdocvar{n} for a variable that is different from the \coqdocvar{n}
    in the original theorem.  This is why the \coqdocvar{Case} annotation is
    just \coqdocvar{S} -- if we tried to write it out in the more explicit form
    that we've been using for most proofs, we'd have to write \coqdocvar{n} = \coqdocvar{S}
    \coqdocvar{n}, which doesn't make a lot of sense!  All of these conveniences
    make \coqdoctac{induction} nicer to use in practice than applying induction
    principles like \coqdocvar{nat\_ind} directly.  But it is important to
    realize that, modulo this little bit of bookkeeping, applying
    \coqdocvar{nat\_ind} is what we are really doing. 

\paragraph{Exercise: 2 stars, optional (plus\_one\_r')}

 Complete this proof as we did \coqdocvar{mult\_0\_r'} above, without using
    the \coqdoctac{induction} tactic. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{plus\_one\_r'} : \coqdockw{\ensuremath{\forall}} \coqdocvar{n}:\coqdocvar{nat}, \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} + 1 = \coqdocvar{S} \coqdocvar{n}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.